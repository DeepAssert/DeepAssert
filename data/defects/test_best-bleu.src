@Test public void test2947660(){ AbstractCategoryItemRenderer r = new LineAndShapeRenderer(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; DefaultCategoryDataset dataset = new DefaultCategoryDataset(); CategoryPlot plot = new CategoryPlot(); plot.setDataset(dataset); plot.setRenderer(r); "<AssertPlaceHolder>"; dataset.addValue(1.0, "S1", "C1"); LegendItemCollection lic = r.getLegendItems(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public LegendItemCollection getLegendItems(){ if (this.plot == null) { return new LegendItemCollection(); } LegendItemCollection result = new LegendItemCollection(); int index = this.plot.getIndexOf(this); XYDataset dataset = this.plot.getDataset(index); if (dataset != null) { int seriesCount = dataset.getSeriesCount(); for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; }
@Test public void testCreateCopy3() throws CloneNotSupportedException{ TimeSeries s1 = new TimeSeries("S1"); s1.add(new Year(2009), 100.0); s1.add(new Year(2010), 101.0); s1.add(new Year(2011), 102.0); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; TimeSeries s2 = s1.createCopy(0, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; TimeSeries s3 = s1.createCopy(1, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public XYSeries createCopy(int start, int end) throws CloneNotSupportedException{ XYSeries copy = (XYSeries) super.clone(); copy.data = new java.util.ArrayList(); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { XYDataItem item = (XYDataItem) this.data.get(index); XYDataItem clone = (XYDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { System.err.println("Unable to add cloned data item."); } } } return copy; }
@Test public void testSerialization(){ ShapeList l1 = new ShapeList(); l1.setShape(0, new Rectangle(1, 2, 3, 4)); l1.setShape(1, new Line2D.Double(1.0, 2.0, 3.0, 4.0)); l1.setShape(2, null); ShapeList l2 = null; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ObjectOutput out = new ObjectOutputStream(buffer); out.writeObject(l1); out.close(); ObjectInput in = new ObjectInputStream(new ByteArrayInputStream( buffer.toByteArray())); l2 = (ShapeList) in.readObject(); in.close(); } catch (Exception e) { e.printStackTrace(); } "<AssertPlaceHolder>"; } public void setShape(Shape shape){ this.shape = shape; }
@Test public void testEquals(){ ShapeList l1 = new ShapeList(); l1.setShape(0, new Rectangle(1, 2, 3, 4)); l1.setShape(1, new Line2D.Double(1.0, 2.0, 3.0, 4.0)); l1.setShape(2, null); ShapeList l2 = new ShapeList(); l2.setShape(0, new Rectangle(1, 2, 3, 4)); l2.setShape(1, new Line2D.Double(1.0, 2.0, 3.0, 4.0)); l2.setShape(2, null); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public void setShape(Shape shape){ this.shape = shape; }
@Test public void testGetMaxMiddleIndex(){ TimePeriodValues s = new TimePeriodValues("Test"); "<AssertPlaceHolder>"; s.add(new SimpleTimePeriod(100L, 200L), 1.0); "<AssertPlaceHolder>"; s.add(new SimpleTimePeriod(300L, 400L), 2.0); "<AssertPlaceHolder>"; s.add(new SimpleTimePeriod(0L, 50L), 3.0); "<AssertPlaceHolder>"; s.add(new SimpleTimePeriod(150L, 200L), 4.0); "<AssertPlaceHolder>"; } public int getMaxMiddleIndex(){ return this.maxMiddleIndex; }
@Test public void testConstructor(){ Locale savedLocale = Locale.getDefault(); TimeZone savedZone = TimeZone.getDefault(); Locale.setDefault(new Locale("da", "DK")); TimeZone.setDefault(TimeZone.getTimeZone("Europe/Copenhagen")); GregorianCalendar cal = (GregorianCalendar) Calendar.getInstance( TimeZone.getDefault(), Locale.getDefault()); "<AssertPlaceHolder>"; cal.set(2007, Calendar.AUGUST, 26, 1, 0, 0); cal.set(Calendar.MILLISECOND, 0); Date t = cal.getTime(); Week w = new Week(t, TimeZone.getTimeZone("Europe/Copenhagen")); "<AssertPlaceHolder>"; Locale.setDefault(Locale.US); TimeZone.setDefault(TimeZone.getTimeZone("US/Detroit")); cal = (GregorianCalendar) Calendar.getInstance(TimeZone.getDefault()); "<AssertPlaceHolder>"; cal.set(2007, Calendar.AUGUST, 26, 1, 0, 0); cal.set(Calendar.MILLISECOND, 0); t = cal.getTime(); w = new Week(t, TimeZone.getTimeZone("Europe/Copenhagen")); "<AssertPlaceHolder>"; w = new Week(t, TimeZone.getTimeZone("Europe/Copenhagen"), new Locale("da", "DK")); "<AssertPlaceHolder>"; Locale.setDefault(savedLocale); TimeZone.setDefault(savedZone); } public int getWeek(){ return this.week; }
@Test public void testGenerateURLFragment(){ StandardToolTipTagFragmentGenerator g = new StandardToolTipTagFragmentGenerator(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String generateToolTipFragment(String toolTipText){ return " onMouseOver=\"return overlib('" + ImageMapUtilities.htmlEscape(toolTipText) + "');\" onMouseOut=\"return nd();\""; }
@Test public void testConstructor(){ MultiplePiePlot plot = new MultiplePiePlot(); "<AssertPlaceHolder>"; DefaultCategoryDataset dataset = new DefaultCategoryDataset(); plot = new MultiplePiePlot(dataset); "<AssertPlaceHolder>"; } public boolean hasListener(EventListener listener){ List list = Arrays.asList(this.listenerList.getListenerList()); return list.contains(listener); }
@Test public void testSetCategoryKeys(){ DefaultIntervalCategoryDataset empty = new DefaultIntervalCategoryDataset(new double[0][0], new double[0][0]); boolean pass = true; try { empty.setCategoryKeys(new String[0]); } catch (RuntimeException e) { pass = false; } "<AssertPlaceHolder>"; } public void setCategoryKeys(Comparable[] categoryKeys){ if (categoryKeys == null) { throw new IllegalArgumentException("Null 'categoryKeys' argument."); } if (categoryKeys.length != this.startData[0].length) { throw new IllegalArgumentException( "The number of categories does not match the data."); } for (int i = 0; i < categoryKeys.length; i++) { if (categoryKeys[i] == null) { throw new IllegalArgumentException( "DefaultIntervalCategoryDataset.setCategoryKeys(): " + "null category not permitted."); } } this.categoryKeys = categoryKeys; fireDatasetChanged(); }
@Test public void testRemoveValue(){ DefaultKeyedValues data = new DefaultKeyedValues(); data.addValue("A", new Double(1.0)); data.addValue("B", null); data.addValue("C", new Double(3.0)); data.addValue("D", new Double(2.0)); "<AssertPlaceHolder>"; data.removeValue("B"); "<AssertPlaceHolder>"; boolean pass = false; try { data.removeValue("XXX"); } catch (UnknownKeyException e) { pass = true; } "<AssertPlaceHolder>"; } public void removeValue(Comparable rowKey, Comparable columnKey){ setValue(null, rowKey, columnKey); boolean allNull = true; int rowIndex = getRowIndex(rowKey); DefaultKeyedValues row = (DefaultKeyedValues) this.rows.get(rowIndex); for (int item = 0, itemCount = row.getItemCount(); item < itemCount; item++) { if (row.getValue(item) != null) { allNull = false; break; } } if (allNull) { this.rowKeys.remove(rowIndex); this.rows.remove(rowIndex); } allNull = true; for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (DefaultKeyedValues) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0 && row.getValue(columnIndex) != null) { allNull = false; break; } } if (allNull) { for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (DefaultKeyedValues) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0) { row.removeValue(columnIndex); } } this.columnKeys.remove(columnKey); } }
@Test public void testRemoveValue(){ DefaultKeyedValues data = new DefaultKeyedValues(); data.addValue("A", new Double(1.0)); data.addValue("B", null); data.addValue("C", new Double(3.0)); data.addValue("D", new Double(2.0)); "<AssertPlaceHolder>"; data.removeValue("B"); "<AssertPlaceHolder>"; boolean pass = false; try { data.removeValue("XXX"); } catch (UnknownKeyException e) { pass = true; } "<AssertPlaceHolder>"; } public void addValue(Number value, Comparable rowKey, Comparable columnKey){ setValue(value, rowKey, columnKey); }
@Test public void testGetIndex2(){ DefaultKeyedValues v = new DefaultKeyedValues(); "<AssertPlaceHolder>"; v.addValue("K1", 1.0); "<AssertPlaceHolder>"; v.removeValue("K1"); "<AssertPlaceHolder>"; } public void addValue(Number value, Comparable rowKey, Comparable columnKey){ setValue(value, rowKey, columnKey); }
@Test public void testGetIndex2(){ DefaultKeyedValues v = new DefaultKeyedValues(); "<AssertPlaceHolder>"; v.addValue("K1", 1.0); "<AssertPlaceHolder>"; v.removeValue("K1"); "<AssertPlaceHolder>"; } public void removeValue(Comparable rowKey, Comparable columnKey){ setValue(null, rowKey, columnKey); boolean allNull = true; int rowIndex = getRowIndex(rowKey); DefaultKeyedValues row = (DefaultKeyedValues) this.rows.get(rowIndex); for (int item = 0, itemCount = row.getItemCount(); item < itemCount; item++) { if (row.getValue(item) != null) { allNull = false; break; } } if (allNull) { this.rowKeys.remove(rowIndex); this.rows.remove(rowIndex); } allNull = true; for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (DefaultKeyedValues) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0 && row.getValue(columnIndex) != null) { allNull = false; break; } } if (allNull) { for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (DefaultKeyedValues) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0) { row.removeValue(columnIndex); } } this.columnKeys.remove(columnKey); } }
@Test public void testGetRangeAxisIndex(){ CategoryAxis domainAxis1 = new CategoryAxis("X1"); NumberAxis rangeAxis1 = new NumberAxis("Y1"); NumberAxis rangeAxis2 = new NumberAxis("Y2"); CategoryPlot plot = new CategoryPlot(null, domainAxis1, rangeAxis1, null); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; plot.setRangeAxis(1, rangeAxis2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; boolean pass = false; try { plot.getRangeAxisIndex(null); } catch (IllegalArgumentException e) { pass = true; } "<AssertPlaceHolder>"; } public int getRangeAxisIndex(ValueAxis axis){ int result = this.rangeAxes.indexOf(axis); if (result < 0) { Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot p = (CategoryPlot) parent; result = p.getRangeAxisIndex(axis); } } return result; }
@Test public void testGetDomainAxisIndex(){ CategoryAxis domainAxis1 = new CategoryAxis("X1"); CategoryAxis domainAxis2 = new CategoryAxis("X2"); NumberAxis rangeAxis1 = new NumberAxis("Y1"); CategoryPlot plot = new CategoryPlot(null, domainAxis1, rangeAxis1, null); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; plot.setDomainAxis(1, domainAxis2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; boolean pass = false; try { plot.getDomainAxisIndex(null); } catch (IllegalArgumentException e) { pass = true; } "<AssertPlaceHolder>"; } public int getDomainAxisIndex(CategoryAxis axis){ return this.domainAxes.indexOf(axis); }
@Test public void test1808376(){ Stroke stroke = new BasicStroke(1.0f); Stroke outlineStroke = new BasicStroke(2.0f); ValueMarker m = new ValueMarker(1.0, Color.red, stroke, Color.blue, outlineStroke, 0.5f); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public float getAlpha(){ return this.alpha; }
@Test public void test1808376(){ Stroke stroke = new BasicStroke(1.0f); Stroke outlineStroke = new BasicStroke(2.0f); ValueMarker m = new ValueMarker(1.0, Color.red, stroke, Color.blue, outlineStroke, 0.5f); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Stroke getOutlineStroke(){ return this.outlineStroke; }
@Test public void test1808376(){ Stroke stroke = new BasicStroke(1.0f); Stroke outlineStroke = new BasicStroke(2.0f); ValueMarker m = new ValueMarker(1.0, Color.red, stroke, Color.blue, outlineStroke, 0.5f); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Paint getOutlinePaint(){ return this.outlinePaint; }
@Test public void test1808376(){ Stroke stroke = new BasicStroke(1.0f); Stroke outlineStroke = new BasicStroke(2.0f); ValueMarker m = new ValueMarker(1.0, Color.red, stroke, Color.blue, outlineStroke, 0.5f); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Stroke getStroke(Comparable key){ if (key == null) { throw new IllegalArgumentException("Null 'key' argument."); } return (Stroke) this.store.get(key); }
@Test public void test1808376(){ Stroke stroke = new BasicStroke(1.0f); Stroke outlineStroke = new BasicStroke(2.0f); ValueMarker m = new ValueMarker(1.0, Color.red, stroke, Color.blue, outlineStroke, 0.5f); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Paint getPaint(Comparable key){ if (key == null) { throw new IllegalArgumentException("Null 'key' argument."); } return (Paint) this.store.get(key); }
@Test public void test1808376(){ Stroke stroke = new BasicStroke(1.0f); Stroke outlineStroke = new BasicStroke(2.0f); ValueMarker m = new ValueMarker(1.0, Color.red, stroke, Color.blue, outlineStroke, 0.5f); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Number getValue(){ return this.value; }
@Test public void testGetRangeBounds(){ DefaultBoxAndWhiskerCategoryDataset d1 = new DefaultBoxAndWhiskerCategoryDataset(); d1.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList()), "R1", "C1"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; d1.add(new BoxAndWhiskerItem(1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, new ArrayList()), "R1", "C1"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; d1.add(new BoxAndWhiskerItem(2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, new ArrayList()), "R2", "C1"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; d1.add(new BoxAndWhiskerItem(1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 8.6, 9.6, new ArrayList()), "R1", "C1"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Range getRangeBounds(boolean includeInterval){ Range result = null; if (includeInterval) { if (!Double.isNaN(this.minimumRangeValueIncStdDev) && !Double.isNaN(this.maximumRangeValueIncStdDev)) result = new Range(this.minimumRangeValueIncStdDev, this.maximumRangeValueIncStdDev); } else { if (!Double.isNaN(this.minimumRangeValue) && !Double.isNaN(this.maximumRangeValue)) result = new Range(this.minimumRangeValue, this.maximumRangeValue); } return result; }
@Test public void testRemoveValue(){ KeyedObjects2D data = new KeyedObjects2D(); data.setObject("Obj1", "R1", "C1"); data.setObject("Obj2", "R2", "C2"); data.removeObject("R2", "C2"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public void setObject(Object object, Comparable rowKey, Comparable columnKey){ if (rowKey == null) { throw new IllegalArgumentException("Null 'rowKey' argument."); } if (columnKey == null) { throw new IllegalArgumentException("Null 'columnKey' argument."); } KeyedObjects row; int rowIndex = this.rowKeys.indexOf(rowKey); if (rowIndex >= 0) { row = (KeyedObjects) this.rows.get(rowIndex); } else { this.rowKeys.add(rowKey); row = new KeyedObjects(); this.rows.add(row); } row.setObject(columnKey, object); int columnIndex = this.columnKeys.indexOf(columnKey); if (columnIndex < 0) { this.columnKeys.add(columnKey); } }
@Test public void testRemoveValue(){ KeyedObjects2D data = new KeyedObjects2D(); data.setObject("Obj1", "R1", "C1"); data.setObject("Obj2", "R2", "C2"); data.removeObject("R2", "C2"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public void removeObject(Comparable rowKey, Comparable columnKey){ setObject(null, rowKey, columnKey); boolean allNull = true; int rowIndex = getRowIndex(rowKey); KeyedObjects row = (KeyedObjects) this.rows.get(rowIndex); for (int item = 0, itemCount = row.getItemCount(); item < itemCount; item++) { if (row.getObject(item) != null) { allNull = false; break; } } if (allNull) { this.rowKeys.remove(rowIndex); this.rows.remove(rowIndex); } }
@Test public void testRemoveValue(){ KeyedObjects2D data = new KeyedObjects2D(); data.setObject("Obj1", "R1", "C1"); data.setObject("Obj2", "R2", "C2"); data.removeObject("R2", "C2"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getRowCount(){ return this.rowKeys.size(); }
@Test public void testRemoveValue(){ KeyedObjects2D data = new KeyedObjects2D(); data.setObject("Obj1", "R1", "C1"); data.setObject("Obj2", "R2", "C2"); data.removeObject("R2", "C2"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getColumnCount(){ return this.columnKeys.size(); }
@Test public void testRemoveValue(){ KeyedObjects2D data = new KeyedObjects2D(); data.setObject("Obj1", "R1", "C1"); data.setObject("Obj2", "R2", "C2"); data.removeObject("R2", "C2"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Object getObject(Comparable rowKey, Comparable columnKey){ if (rowKey == null) { throw new IllegalArgumentException("Null 'rowKey' argument."); } if (columnKey == null) { throw new IllegalArgumentException("Null 'columnKey' argument."); } int row = this.rowKeys.indexOf(rowKey); if (row < 0) { throw new UnknownKeyException("Row key (" + rowKey + ") not recognised."); } int column = this.columnKeys.indexOf(columnKey); if (column < 0) { throw new UnknownKeyException("Column key (" + columnKey + ") not recognised."); } if (row >= 0) { KeyedObjects rowData = (KeyedObjects) this.rows.get(row); return rowData.getObject(columnKey); } else { return null; } }
@Test public void testEquals(){ MinMaxCategoryRenderer r1 = new MinMaxCategoryRenderer(); MinMaxCategoryRenderer r2 = new MinMaxCategoryRenderer(); "<AssertPlaceHolder>"; r1.setDrawLines(true); "<AssertPlaceHolder>"; r2.setDrawLines(true); "<AssertPlaceHolder>"; r1.setGroupPaint(new GradientPaint(1.0f, 2.0f, Color.red, 3.0f, 4.0f, Color.yellow)); "<AssertPlaceHolder>"; r2.setGroupPaint(new GradientPaint(1.0f, 2.0f, Color.red, 3.0f, 4.0f, Color.yellow)); "<AssertPlaceHolder>"; r1.setGroupStroke(new BasicStroke(1.2f)); "<AssertPlaceHolder>"; r2.setGroupStroke(new BasicStroke(1.2f)); "<AssertPlaceHolder>"; } public void setGroupStroke(Stroke stroke){ if (stroke == null) { throw new IllegalArgumentException("Null 'stroke' argument."); } this.groupStroke = stroke; notifyListeners(new RendererChangeEvent(this)); }
@Test public void testEquals(){ MinMaxCategoryRenderer r1 = new MinMaxCategoryRenderer(); MinMaxCategoryRenderer r2 = new MinMaxCategoryRenderer(); "<AssertPlaceHolder>"; r1.setDrawLines(true); "<AssertPlaceHolder>"; r2.setDrawLines(true); "<AssertPlaceHolder>"; r1.setGroupPaint(new GradientPaint(1.0f, 2.0f, Color.red, 3.0f, 4.0f, Color.yellow)); "<AssertPlaceHolder>"; r2.setGroupPaint(new GradientPaint(1.0f, 2.0f, Color.red, 3.0f, 4.0f, Color.yellow)); "<AssertPlaceHolder>"; r1.setGroupStroke(new BasicStroke(1.2f)); "<AssertPlaceHolder>"; r2.setGroupStroke(new BasicStroke(1.2f)); "<AssertPlaceHolder>"; } public void setDrawLines(boolean draw){ if (this.plotLines != draw) { this.plotLines = draw; this.notifyListeners(new RendererChangeEvent(this)); } }
@Test public void testDrawWithNullMeanVertical(){ boolean success = false; try { DefaultStatisticalCategoryDataset dataset = new DefaultStatisticalCategoryDataset(); dataset.add(1.0, 2.0, "S1", "C1"); dataset.add(null, new Double(4.0), "S1", "C2"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), new StatisticalBarRenderer()); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullDeviationVertical(){ boolean success = false; try { DefaultStatisticalCategoryDataset dataset = new DefaultStatisticalCategoryDataset(); dataset.add(1.0, 2.0, "S1", "C1"); dataset.add(new Double(4.0), null, "S1", "C2"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), new StatisticalBarRenderer()); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullMeanHorizontal(){ boolean success = false; try { DefaultStatisticalCategoryDataset dataset = new DefaultStatisticalCategoryDataset(); dataset.add(1.0, 2.0, "S1", "C1"); dataset.add(null, new Double(4.0), "S1", "C2"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), new StatisticalBarRenderer()); plot.setOrientation(PlotOrientation.HORIZONTAL); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullDeviationHorizontal(){ boolean success = false; try { DefaultStatisticalCategoryDataset dataset = new DefaultStatisticalCategoryDataset(); dataset.add(1.0, 2.0, "S1", "C1"); dataset.add(new Double(4.0), null, "S1", "C2"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), new StatisticalBarRenderer()); plot.setOrientation(PlotOrientation.HORIZONTAL); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void testDrawWithNullInfo2(){ boolean success = false; try { JFreeChart chart = createGanttChart(); CategoryPlot plot = (CategoryPlot) chart.getPlot(); plot.setDataset(createDataset()); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void test1654215(){ DefaultCategoryDataset dataset = new DefaultCategoryDataset(); JFreeChart chart = ChartFactory.createLineChart("Title", "X", "Y", dataset, PlotOrientation.VERTICAL, true, false, false); CategoryPlot plot = (CategoryPlot) chart.getPlot(); plot.setRenderer(1, new LineAndShapeRenderer()); boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public void draw(Graphics2D g2, Rectangle2D chartArea, Point2D anchor, ChartRenderingInfo info){ notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_STARTED, 0)); if (info != null) { info.clear(); info.setChartArea(chartArea); } Shape savedClip = g2.getClip(); g2.clip(chartArea); g2.addRenderingHints(this.renderingHints); if (this.backgroundPaint != null) { g2.setPaint(this.backgroundPaint); g2.fill(chartArea); } if (this.backgroundImage != null) { Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, this.backgroundImageAlpha)); Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, this.backgroundImage.getWidth(null), this.backgroundImage.getHeight(null)); Align.align(dest, chartArea, this.backgroundImageAlignment); g2.drawImage(this.backgroundImage, (int) dest.getX(), (int) dest.getY(), (int) dest.getWidth(), (int) dest.getHeight(), null); g2.setComposite(originalComposite); } if (isBorderVisible()) { Paint paint = getBorderPaint(); Stroke stroke = getBorderStroke(); if (paint != null && stroke != null) { Rectangle2D borderArea = new Rectangle2D.Double( chartArea.getX(), chartArea.getY(), chartArea.getWidth() - 1.0, chartArea.getHeight() - 1.0); g2.setPaint(paint); g2.setStroke(stroke); g2.draw(borderArea); } } Rectangle2D nonTitleArea = new Rectangle2D.Double(); nonTitleArea.setRect(chartArea); this.padding.trim(nonTitleArea); EntityCollection entities = null; if (info != null) { entities = info.getEntityCollection(); } if (this.title != null) { EntityCollection e = drawTitle(this.title, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Iterator iterator = this.subtitles.iterator(); while (iterator.hasNext()) { Title currentTitle = (Title) iterator.next(); EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, (entities != null)); if (e != null) { entities.addAll(e); } } Rectangle2D plotArea = nonTitleArea; PlotRenderingInfo plotInfo = null; if (info != null) { plotInfo = info.getPlotInfo(); } this.plot.draw(g2, plotArea, anchor, null, plotInfo); g2.setClip(savedClip); notifyListeners(new ChartProgressEvent(this, this, ChartProgressEvent.DRAWING_FINISHED, 100)); }
@Test public void testSerialization3(){ DefaultCategoryDataset dataset = new DefaultCategoryDataset(); JFreeChart chart = ChartFactory.createBarChart( "Test Chart", "Category Axis", "Value Axis", dataset, PlotOrientation.VERTICAL, true, true, false ); JFreeChart chart2 = null; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ObjectOutput out = new ObjectOutputStream(buffer); out.writeObject(chart); out.close(); ObjectInput in = new ObjectInputStream( new ByteArrayInputStream(buffer.toByteArray())); chart2 = (JFreeChart) in.readObject(); in.close(); } catch (Exception e) { fail(e.toString()); } boolean passed = true; try { chart2.createBufferedImage(300, 200); } catch (Exception e) { passed = false; e.printStackTrace(); } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testSerialization4(){ DefaultCategoryDataset dataset = new DefaultCategoryDataset(); JFreeChart chart = ChartFactory.createBarChart( "Test Chart", "Category Axis", "Value Axis", dataset, PlotOrientation.VERTICAL, true, true, false ); CategoryPlot plot = (CategoryPlot) chart.getPlot(); plot.addRangeMarker(new ValueMarker(1.1), Layer.FOREGROUND); plot.addRangeMarker(new IntervalMarker(2.2, 3.3), Layer.BACKGROUND); JFreeChart chart2 = null; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ObjectOutput out = new ObjectOutputStream(buffer); out.writeObject(chart); out.close(); ObjectInput in = new ObjectInputStream( new ByteArrayInputStream(buffer.toByteArray())); chart2 = (JFreeChart) in.readObject(); in.close(); } catch (Exception e) { fail(e.toString()); } "<AssertPlaceHolder>"; boolean passed = true; try { chart2.createBufferedImage(300, 200); } catch (Exception e) { passed = false; e.printStackTrace(); } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testSerialization4(){ DefaultCategoryDataset dataset = new DefaultCategoryDataset(); JFreeChart chart = ChartFactory.createBarChart( "Test Chart", "Category Axis", "Value Axis", dataset, PlotOrientation.VERTICAL, true, true, false ); CategoryPlot plot = (CategoryPlot) chart.getPlot(); plot.addRangeMarker(new ValueMarker(1.1), Layer.FOREGROUND); plot.addRangeMarker(new IntervalMarker(2.2, 3.3), Layer.BACKGROUND); JFreeChart chart2 = null; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ObjectOutput out = new ObjectOutputStream(buffer); out.writeObject(chart); out.close(); ObjectInput in = new ObjectInputStream( new ByteArrayInputStream(buffer.toByteArray())); chart2 = (JFreeChart) in.readObject(); in.close(); } catch (Exception e) { fail(e.toString()); } "<AssertPlaceHolder>"; boolean passed = true; try { chart2.createBufferedImage(300, 200); } catch (Exception e) { passed = false; e.printStackTrace(); } "<AssertPlaceHolder>"; } private void writeObject(ObjectOutputStream stream) throws IOException{ stream.defaultWriteObject(); }
@Test public void testSerialization4(){ DefaultCategoryDataset dataset = new DefaultCategoryDataset(); JFreeChart chart = ChartFactory.createBarChart( "Test Chart", "Category Axis", "Value Axis", dataset, PlotOrientation.VERTICAL, true, true, false ); CategoryPlot plot = (CategoryPlot) chart.getPlot(); plot.addRangeMarker(new ValueMarker(1.1), Layer.FOREGROUND); plot.addRangeMarker(new IntervalMarker(2.2, 3.3), Layer.BACKGROUND); JFreeChart chart2 = null; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ObjectOutput out = new ObjectOutputStream(buffer); out.writeObject(chart); out.close(); ObjectInput in = new ObjectInputStream( new ByteArrayInputStream(buffer.toByteArray())); chart2 = (JFreeChart) in.readObject(); in.close(); } catch (Exception e) { fail(e.toString()); } "<AssertPlaceHolder>"; boolean passed = true; try { chart2.createBufferedImage(300, 200); } catch (Exception e) { passed = false; e.printStackTrace(); } "<AssertPlaceHolder>"; } private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException{ stream.defaultReadObject(); this.listenerList = new EventListenerList(); stream.registerValidation(this, 10); }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(0.0), new Double(4.0), new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), "S1", "C1"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), new BoxAndWhiskerRenderer()); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { DefaultCategoryDataset dataset = new DefaultCategoryDataset(); dataset.addValue(1.0, "S1", "C1"); dataset.addValue(2.0, "S1", "C2"); dataset.addValue(3.0, "S2", "C1"); dataset.addValue(4.0, "S2", "C2"); GroupedStackedBarRenderer renderer = new GroupedStackedBarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), renderer); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { double[][] starts = new double[][] {{0.1, 0.2, 0.3}, {0.3, 0.4, 0.5}}; double[][] ends = new double[][] {{0.5, 0.6, 0.7}, {0.7, 0.8, 0.9}}; DefaultIntervalCategoryDataset dataset = new DefaultIntervalCategoryDataset(starts, ends); IntervalBarRenderer renderer = new IntervalBarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), renderer); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { DefaultCategoryDataset dataset = new DefaultCategoryDataset(); dataset.addValue(1.0, "S1", "C1"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), new LayeredBarRenderer()); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { DefaultCategoryDataset dataset = new DefaultCategoryDataset(); dataset.addValue(1.0, "S1", "C1"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), new LevelRenderer()); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { DefaultCategoryDataset dataset = new DefaultCategoryDataset(); dataset.addValue(1.0, "S1", "C1"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), new MinMaxCategoryRenderer()); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { DefaultStatisticalCategoryDataset dataset = new DefaultStatisticalCategoryDataset(); dataset.add(1.0, 2.0, "S1", "C1"); dataset.add(3.0, 4.0, "S1", "C2"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), new StatisticalBarRenderer()); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testDrawWithNullInfo(){ boolean success = false; try { DefaultStatisticalCategoryDataset dataset = new DefaultStatisticalCategoryDataset(); dataset.add(1.0, 2.0, "S1", "C1"); dataset.add(3.0, 4.0, "S1", "C2"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis("Category"), new NumberAxis("Value"), new StatisticalLineAndShapeRenderer()); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200, null); success = true; } catch (NullPointerException e) { e.printStackTrace(); success = false; } "<AssertPlaceHolder>"; } public BufferedImage createBufferedImage(int imageWidth, int imageHeight, double drawWidth, double drawHeight, ChartRenderingInfo info){ BufferedImage image = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); double scaleX = imageWidth / drawWidth; double scaleY = imageHeight / drawHeight; AffineTransform st = AffineTransform.getScaleInstance(scaleX, scaleY); g2.transform(st); draw(g2, new Rectangle2D.Double(0, 0, drawWidth, drawHeight), null, info); g2.dispose(); return image; }
@Test public void testGuessModuleName(){ ProcessCommonJSModules pass = new ProcessCommonJSModules(null, "foo"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } String guessCJSModuleName(String filename){ return toModuleName(normalizeSourceName(filename)); }
@Test public void testModuleName(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; setFilename("foo/bar"); test( "var name = require('name');", "goog.provide('module$foo$bar'); var module$foo$bar = {};" + "goog.require('module$name');" + "var name$$module$foo$bar = module$name;"); test( "var name = require('./name');", "goog.provide('module$foo$bar');" + "var module$foo$bar = {};" + "goog.require('module$foo$name');" + "var name$$module$foo$bar = module$foo$name;"); } public static String toModuleName(String requiredFilename, String currentFilename){ requiredFilename = requiredFilename.replaceAll("\\.js$", ""); currentFilename = currentFilename.replaceAll("\\.js$", ""); if (requiredFilename.startsWith("." + File.separator) || requiredFilename.startsWith(".." + File.separator)) { try { requiredFilename = (new URI(currentFilename)).resolve(new URI(requiredFilename)) .toString(); } catch (URISyntaxException e) { throw new RuntimeException(e); } } return toModuleName(requiredFilename); }
@Test public void testIssue701(){ String ascii = "/**\n" + " * @preserve\n" + "   This\n" + "     is\n" + "       ASCII    ART\n" + "*/"; String result = "/*\n\n" + "   This\n" + "     is\n" + "       ASCII    ART\n" + "*/\n"; testSame(createCompilerOptions(), ascii); "<AssertPlaceHolder>"; } private static String toSource(Node root, Format outputFormat, boolean lineBreak,  boolean preferEndOfFileBreak, int lineLengthThreshold, SourceMap sourceMap, SourceMap.DetailLevel sourceMapDetailLevel, Charset outputCharset, boolean tagAsStrict){ Preconditions.checkState(sourceMapDetailLevel != null); boolean createSourceMap = (sourceMap != null); MappedCodePrinter mcp = outputFormat == Format.COMPACT ? new CompactCodePrinter( lineBreak, preferEndOfFileBreak, lineLengthThreshold, createSourceMap, sourceMapDetailLevel) : new PrettyCodePrinter( lineLengthThreshold, createSourceMap, sourceMapDetailLevel); CodeGenerator cg = outputFormat == Format.TYPED ? new TypedCodeGenerator(mcp, outputCharset) : new CodeGenerator(mcp, outputCharset); if (tagAsStrict) { cg.tagAsStrict(); } cg.add(root); mcp.endFile(); String code = mcp.getCode(); if (createSourceMap) { mcp.generateSourceMap(sourceMap); } return code; }
@Test public void testParseLicense() throws Exception{ Node node = new Node(1); this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); String comment = "@license Foo\nBar\n\nBaz*/"; parse(comment); "<AssertPlaceHolder>"; } public String getLicense(){ return (info == null) ? null : info.license; }
@Test public void testParsePreserve() throws Exception{ Node node = new Node(1); this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); String comment = "@preserve Foo\nBar\n\nBaz*/"; parse(comment); "<AssertPlaceHolder>"; } public String getLicense(){ return (info == null) ? null : info.license; }
@Test public void testParseLicenseAscii() throws Exception{ Node node = new Node(1); this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); String comment = "@license Foo\n *   Bar\n\n  Baz*/"; parse(comment); "<AssertPlaceHolder>"; } public String getLicense(){ return (info == null) ? null : info.license; }
@Test public void testRecursiveRecord(){ ProxyObjectType loop = new ProxyObjectType(registry, NUMBER_TYPE); JSType record = new RecordTypeBuilder(registry) .addProperty("loop", loop, null) .addProperty("number", NUMBER_TYPE, null) .addProperty("string", STRING_TYPE, null) .build(); "<AssertPlaceHolder>"; loop.setReferencedType(record); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Asserts.assertEquivalenceOperations(record, loop); } public final String toAnnotationString(){ return toStringHelper(true); }
@Test public void testRecursiveRecord(){ ProxyObjectType loop = new ProxyObjectType(registry, NUMBER_TYPE); JSType record = new RecordTypeBuilder(registry) .addProperty("loop", loop, null) .addProperty("number", NUMBER_TYPE, null) .addProperty("string", STRING_TYPE, null) .build(); "<AssertPlaceHolder>"; loop.setReferencedType(record); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Asserts.assertEquivalenceOperations(record, loop); } public String toString(){ return name; }
@Test public void testLongToString(){ JSType record = new RecordTypeBuilder(registry) .addProperty("a1", NUMBER_TYPE, null) .addProperty("a2", NUMBER_TYPE, null) .addProperty("a3", NUMBER_TYPE, null) .addProperty("a4", NUMBER_TYPE, null) .addProperty("a5", NUMBER_TYPE, null) .addProperty("a6", NUMBER_TYPE, null) .build(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public final String toAnnotationString(){ return toStringHelper(true); }
@Test public void testLongToString(){ JSType record = new RecordTypeBuilder(registry) .addProperty("a1", NUMBER_TYPE, null) .addProperty("a2", NUMBER_TYPE, null) .addProperty("a3", NUMBER_TYPE, null) .addProperty("a4", NUMBER_TYPE, null) .addProperty("a5", NUMBER_TYPE, null) .addProperty("a6", NUMBER_TYPE, null) .build(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String toString(){ return name; }
@Test public void testPropertyOnUnknownSuperClass2(){ testSame( "var goog = this.foo();" + "/** @constructor \n * @extends {goog.Unknown} */" + "function Foo() {}" + "Foo.prototype = {bar: 1};" + "var x = new Foo();", RhinoErrorReporter.TYPE_PARSE_ERROR); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String toString(){ return "{" + Joiner.on(", ").join(orders) + "}"; }
@Test public void testPropertyOnUnknownSuperClass2(){ testSame( "var goog = this.foo();" + "/** @constructor \n * @extends {goog.Unknown} */" + "function Foo() {}" + "Foo.prototype = {bar: 1};" + "var x = new Foo();", RhinoErrorReporter.TYPE_PARSE_ERROR); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } ConcreteInstanceType getImplicitPrototype(){ if ((prototype == null) && (instanceType.getImplicitPrototype() != null)) { ObjectType proto = instanceType.getImplicitPrototype(); if ((proto != instanceType) && !(proto instanceof UnknownType)) { prototype = factory.createConcreteInstance(proto); } } return prototype; }
@Test public void testPropertyOnUnknownSuperClass2(){ testSame( "var goog = this.foo();" + "/** @constructor \n * @extends {goog.Unknown} */" + "function Foo() {}" + "Foo.prototype = {bar: 1};" + "var x = new Foo();", RhinoErrorReporter.TYPE_PARSE_ERROR); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean hasOwnProperty(String propertyName){ return properties.get(propertyName) != null; }
@Test public void testPropertyOnUnknownSuperClass2(){ testSame( "var goog = this.foo();" + "/** @constructor \n * @extends {goog.Unknown} */" + "function Foo() {}" + "Foo.prototype = {bar: 1};" + "var x = new Foo();", RhinoErrorReporter.TYPE_PARSE_ERROR); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } ConcreteType getPropertyType(final String name){ ConcreteType ret = NONE; for (StaticSlot<ConcreteType> slot : getPropertySlots(name)) { ret = ret.unionWith(slot.getType()); } return ret; }
@Test public void testPropertyOnUnknownSuperClass2(){ testSame( "var goog = this.foo();" + "/** @constructor \n * @extends {goog.Unknown} */" + "function Foo() {}" + "Foo.prototype = {bar: 1};" + "var x = new Foo();", RhinoErrorReporter.TYPE_PARSE_ERROR); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isPropertyTypeInferred(String property){ StaticSlot<JSType> slot = getSlot(property); if (slot == null) { return false; } return slot.isTypeInferred(); }
@Test public void testExceptNoNewLine() throws Exception{ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String getSourceLine(String sourceName, int lineNumber){ if (lineNumber < 1) { return null; } SourceFile input = getSourceFileByName(sourceName); if (input != null) { return input.getLine(lineNumber); } return null; }
@Test public void testSyntaxError1(){ try { extractMessage("if (true) {}}"); fail("Expected exception"); } catch (RuntimeException e) { "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } } @Override public final String getMessage(){ String details = details(); if (sourceName == null || lineNumber <= 0) { return details; } StringBuilder buf = new StringBuilder(details); buf.append(" ("); if (sourceName != null) { buf.append(sourceName); } if (lineNumber > 0) { buf.append('#'); buf.append(lineNumber); } buf.append(')'); return buf.toString(); }
@Test public void testSyntaxError2(){ try { extractMessage("", "if (true) {}}"); fail("Expected exception"); } catch (RuntimeException e) { "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } } @Override public final String getMessage(){ String details = details(); if (sourceName == null || lineNumber <= 0) { return details; } StringBuilder buf = new StringBuilder(details); buf.append(" ("); if (sourceName != null) { buf.append(sourceName); } if (lineNumber > 0) { buf.append('#'); buf.append(lineNumber); } buf.append(')'); return buf.toString(); }
@Test public void testFormatErrorSpaceEndOfLine1() throws Exception{ JSError error = JSError.make("javascript/complex.js", 1, 10, FOO_TYPE); LightweightMessageFormatter formatter = formatter("assert (1;"); "<AssertPlaceHolder>"; } public String formatError(JSError error){ return getLevelName(CheckLevel.ERROR) + ": " + format(error); }
@Test public void testFormatErrorSpaceEndOfLine2() throws Exception{ JSError error = JSError.make("javascript/complex.js", 6, 7, FOO_TYPE); LightweightMessageFormatter formatter = formatter("if (foo"); "<AssertPlaceHolder>"; } public String formatError(JSError error){ return getLevelName(CheckLevel.ERROR) + ": " + format(error); }
@Test public void testES5StrictUseStrictMultipleInputs(){ args.add("--language_in=ECMASCRIPT5_STRICT"); Compiler compiler = compile(new String[] {"var x = f.function", "var y = f.function", "var z = f.function"}); String outputSource = compiler.toSource(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int indexOf(Object obj){ int N = size; for (int i = 0; i != N; ++i) { Object current = getImpl(i); if (current == obj || (current != null && current.equals(obj))) { return i; } } return -1; }
@Test public void testGetTypedPercent5() throws Exception{ String js = "/** @enum {number} */ keys = {A: 1,B: 2,C: 3};"; "<AssertPlaceHolder>"; } public double getTypedPercent(){ return typedPercent; }
@Test public void testGetTypedPercent6() throws Exception{ String js = "a = {TRUE: 1, FALSE: 0};"; "<AssertPlaceHolder>"; } public double getTypedPercent(){ return typedPercent; }
@Test public void testIsBooleanResult(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } static boolean isBooleanResult(Node n){ return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }
@Test public void testEmptyFunctionTypes(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public final boolean isEmptyType(){ return isNoType() || isNoObjectType() || isNoResolvedType(); }
@Test public void testGlobalQualifiedNameInLocalScope(){ testSame( "var ns = {}; " + "(function() { " + "    /** @param {number} x */ ns.foo = function(x) {}; })();" + "(function() { ns.foo(3); })();"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Var getVar(String name){ Var var = vars.get(name); if (var != null) { return var; } else if (parent != null) { return parent.getVar(name); } else { return null; } }
@Test public void testGreatestSubtypeUnionTypes5() throws Exception{ JSType errUnion = createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE); "<AssertPlaceHolder>"; } public JSType getGreatestSubtype(JSType that){ return that; }
@Test public void testParseLicenseWithAnnotation() throws Exception{ Node node = new Node(1); this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); String comment = "@license Foo \n * @author Charlie Brown */"; parse(comment); "<AssertPlaceHolder>"; } public String getLicense(){ return (info == null) ? null : info.license; }
@Test public void testDontAddMethodsIfNoConstructor() throws Exception{ Node js1Node = parseAndTypeCheck( "function A() {}" + "A.prototype = {m1: 5, m2: true}"); JSType functionAType = js1Node.getFirstChild().getJSType(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } ConcreteType getPropertyType(final String name){ ConcreteType ret = NONE; for (StaticSlot<ConcreteType> slot : getPropertySlots(name)) { ret = ret.unionWith(slot.getType()); } return ret; }
@Test public void testBug911118() throws Exception{ Scope s = parseAndTypeCheckWithScope("var a = function(){};").scope; JSType type = s.getVar("a").getType(); "<AssertPlaceHolder>"; testTypes("function nullFunction() {};" + "var foo = nullFunction;" + "foo = function() {};" + "foo();"); } public Var getVar(String name){ Var var = vars.get(name); if (var != null) { return var; } else if (parent != null) { return parent.getVar(name); } else { return null; } }
@Test public void testBug911118() throws Exception{ Scope s = parseAndTypeCheckWithScope("var a = function(){};").scope; JSType type = s.getVar("a").getType(); "<AssertPlaceHolder>"; testTypes("function nullFunction() {};" + "var foo = nullFunction;" + "foo = function() {};" + "foo();"); } @Override public JSType getType( StaticScope<JSType> scope, Node node, String prop){ if (node.getJSType() == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return node.getJSType(); }
@Test public void testBug911118() throws Exception{ Scope s = parseAndTypeCheckWithScope("var a = function(){};").scope; JSType type = s.getVar("a").getType(); "<AssertPlaceHolder>"; testTypes("function nullFunction() {};" + "var foo = nullFunction;" + "foo = function() {};" + "foo();"); } public ConcreteType getType( StaticScope<ConcreteType> scope, Node node, String prop){ if (scope != null) { ConcreteType c = tt.inferConcreteType( (TightenTypes.ConcreteScope) scope, node); return maybeAddAutoboxes(c, node, prop); } else { return null; } }
@Test public void testPrototypePropertyReference() throws Exception{ TypeCheckResult p = parseAndTypeCheckWithScope("" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @param {number} a */\n" + "Foo.prototype.bar = function(a){};\n" + "/** @param {Foo} f */\n" + "function baz(f) {\n" + "  Foo.prototype.bar.call(f, 3);\n" + "}"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType(); "<AssertPlaceHolder>"; } public Node getPrototype(){ return getValueParent().getFirstChild().getFirstChild(); }
@Test public void testPrototypePropertyReference() throws Exception{ TypeCheckResult p = parseAndTypeCheckWithScope("" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @param {number} a */\n" + "Foo.prototype.bar = function(a){};\n" + "/** @param {Foo} f */\n" + "function baz(f) {\n" + "  Foo.prototype.bar.call(f, 3);\n" + "}"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType(); "<AssertPlaceHolder>"; } public Node getPrototype(){ return assign.getFirstChild(); }
@Test public void testPrototypePropertyReference() throws Exception{ TypeCheckResult p = parseAndTypeCheckWithScope("" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @param {number} a */\n" + "Foo.prototype.bar = function(a){};\n" + "/** @param {Foo} f */\n" + "function baz(f) {\n" + "  Foo.prototype.bar.call(f, 3);\n" + "}"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType(); "<AssertPlaceHolder>"; } ConcreteType getPropertyType(final String name){ ConcreteType ret = NONE; for (StaticSlot<ConcreteType> slot : getPropertySlots(name)) { ret = ret.unionWith(slot.getType()); } return ret; }
@Test public void testDontAddMethodsIfNoConstructor() throws Exception{ Node js1Node = parseAndTypeCheck( "function A() {}" + "A.prototype = {m1: 5, m2: true}"); JSType functionAType = js1Node.getFirstChild().getJSType(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } ConcreteType getPropertyType(final String name){ ConcreteType ret = NONE; for (StaticSlot<ConcreteType> slot : getPropertySlots(name)) { ret = ret.unionWith(slot.getType()); } return ret; }
@Test public void testPrototypePropertyReference() throws Exception{ TypeCheckResult p = parseAndTypeCheckWithScope("" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @param {number} a */\n" + "Foo.prototype.bar = function(a){};\n" + "/** @param {Foo} f */\n" + "function baz(f) {\n" + "  Foo.prototype.bar.call(f, 3);\n" + "}"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType(); "<AssertPlaceHolder>"; } public Node getPrototype(){ return getValueParent().getFirstChild().getFirstChild(); }
@Test public void testPrototypePropertyReference() throws Exception{ TypeCheckResult p = parseAndTypeCheckWithScope("" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @param {number} a */\n" + "Foo.prototype.bar = function(a){};\n" + "/** @param {Foo} f */\n" + "function baz(f) {\n" + "  Foo.prototype.bar.call(f, 3);\n" + "}"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType(); "<AssertPlaceHolder>"; } public Node getPrototype(){ return assign.getFirstChild(); }
@Test public void testPrototypePropertyReference() throws Exception{ TypeCheckResult p = parseAndTypeCheckWithScope("" + "/** @constructor */\n" + "function Foo() {}\n" + "/** @param {number} a */\n" + "Foo.prototype.bar = function(a){};\n" + "/** @param {Foo} f */\n" + "function baz(f) {\n" + "  Foo.prototype.bar.call(f, 3);\n" + "}"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; FunctionType fooType = (FunctionType) p.scope.getVar("Foo").getType(); "<AssertPlaceHolder>"; } ConcreteType getPropertyType(final String name){ ConcreteType ret = NONE; for (StaticSlot<ConcreteType> slot : getPropertySlots(name)) { ret = ret.unionWith(slot.getType()); } return ret; }
@Test public void testConstructorNode(){ testSame("var goog = {}; /** @constructor */ goog.Foo = function() {};"); ObjectType ctor = (ObjectType) (findNameType("goog.Foo", globalScope)); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isConstructor(){ return getFlag(MASK_CONSTRUCTOR); }
@Test public void testPropertiesOnInterface() throws Exception{ testSame("/** @interface */ var I = function() {};" + "/** @type {number} */ I.prototype.bar;" + "I.prototype.baz = function(){};"); Var i = globalScope.getVar("I"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; ObjectType iPrototype = (ObjectType) ((ObjectType) i.getType()).getPropertyType("prototype"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } ConcreteType getPropertyType(final String name){ ConcreteType ret = NONE; for (StaticSlot<ConcreteType> slot : getPropertySlots(name)) { ret = ret.unionWith(slot.getType()); } return ret; }
@Test public void testPropertiesOnInterface() throws Exception{ testSame("/** @interface */ var I = function() {};" + "/** @type {number} */ I.prototype.bar;" + "I.prototype.baz = function(){};"); Var i = globalScope.getVar("I"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; ObjectType iPrototype = (ObjectType) ((ObjectType) i.getType()).getPropertyType("prototype"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isFunctionPrototypeType(){ return true; }
@Test public void testMethodBeforeFunction() throws Exception{ testSame( "var y = Window.prototype;" + "Window.prototype.alert = function(message) {};" + "/** @constructor */ function Window() {}\n" + "var window = new Window(); \n" + "var x = window;"); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; ObjectType y = (ObjectType) findNameType("y", globalScope); "<AssertPlaceHolder>"; } ConcreteType getPropertyType(final String name){ ConcreteType ret = NONE; for (StaticSlot<ConcreteType> slot : getPropertySlots(name)) { ret = ret.unionWith(slot.getType()); } return ret; }
@Test public void testMethodBeforeFunction() throws Exception{ testSame( "var y = Window.prototype;" + "Window.prototype.alert = function(message) {};" + "/** @constructor */ function Window() {}\n" + "var window = new Window(); \n" + "var x = window;"); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; ObjectType y = (ObjectType) findNameType("y", globalScope); "<AssertPlaceHolder>"; } public boolean isPropertyTypeDeclared(String property){ Property p = properties.get(property); if (p == null) { ObjectType implicitPrototype = getImplicitPrototype(); if (implicitPrototype != null) { return implicitPrototype.isPropertyTypeDeclared(property); } return false; } return !p.inferred; }
@Test public void testConstructorProperty(){ testSame("var foo = {}; /** @constructor */ foo.Bar = function() {};"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; JSType fooBar = foo.getPropertyType("Bar"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean hasProperty(String propertyName){ if (properties.get(propertyName) != null) { return true; } ObjectType implicitPrototype = getImplicitPrototype(); if (implicitPrototype != null) { return implicitPrototype.hasProperty(propertyName); } return false; }
@Test public void testConstructorProperty(){ testSame("var foo = {}; /** @constructor */ foo.Bar = function() {};"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; JSType fooBar = foo.getPropertyType("Bar"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isPropertyTypeInferred(String property){ Property p = properties.get(property); if (p == null) { ObjectType implicitPrototype = getImplicitPrototype(); if (implicitPrototype != null) { return implicitPrototype.isPropertyTypeInferred(property); } return false; } return p.inferred; }
@Test public void testConstructorProperty(){ testSame("var foo = {}; /** @constructor */ foo.Bar = function() {};"); ObjectType foo = (ObjectType) findNameType("foo", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; JSType fooBar = foo.getPropertyType("Bar"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Set<ObjectType> getTypesWithProperty(String propertyName){ Set<ObjectType> typeSet = typesIndexedByProperty.get(propertyName); if (typeSet == null) { return Sets.newHashSet(getNativeObjectType(NO_TYPE)); } return typeSet; }
@Test public void testNamespacedFunctionStubLocal(){ testSame( "(function() {" + "var goog = {};" + "/** @param {number} x */ goog.foo;" + "});"); ObjectType goog = (ObjectType) findNameType("goog", lastLocalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean hasProperty(String propertyName){ if (properties.get(propertyName) != null) { return true; } ObjectType implicitPrototype = getImplicitPrototype(); if (implicitPrototype != null) { return implicitPrototype.hasProperty(propertyName); } return false; }
@Test public void testNamespacedFunctionStubLocal(){ testSame( "(function() {" + "var goog = {};" + "/** @param {number} x */ goog.foo;" + "});"); ObjectType goog = (ObjectType) findNameType("goog", lastLocalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } ConcreteType getPropertyType(final String name){ ConcreteType ret = NONE; for (StaticSlot<ConcreteType> slot : getPropertySlots(name)) { ret = ret.unionWith(slot.getType()); } return ret; }
@Test public void testNamespacedFunctionStubLocal(){ testSame( "(function() {" + "var goog = {};" + "/** @param {number} x */ goog.foo;" + "});"); ObjectType goog = (ObjectType) findNameType("goog", lastLocalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isPropertyTypeDeclared(String property){ Property p = properties.get(property); if (p == null) { ObjectType implicitPrototype = getImplicitPrototype(); if (implicitPrototype != null) { return implicitPrototype.isPropertyTypeDeclared(property); } return false; } return !p.inferred; }
@Test public void testNamespacedFunctionStubLocal(){ testSame( "(function() {" + "var goog = {};" + "/** @param {number} x */ goog.foo;" + "});"); ObjectType goog = (ObjectType) findNameType("goog", lastLocalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } @Override public JSType getType( StaticScope<JSType> scope, Node node, String prop){ if (node.getJSType() == null) { return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE); } return node.getJSType(); }
@Test public void testNamespacedFunctionStubLocal(){ testSame( "(function() {" + "var goog = {};" + "/** @param {number} x */ goog.foo;" + "});"); ObjectType goog = (ObjectType) findNameType("goog", lastLocalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public ConcreteType getType( StaticScope<ConcreteType> scope, Node node, String prop){ if (scope != null) { ConcreteType c = tt.inferConcreteType( (TightenTypes.ConcreteScope) scope, node); return maybeAddAutoboxes(c, node, prop); } else { return null; } }
@Test public void testCollectedFunctionStubLocal(){ testSame( "(function() {" + "/** @constructor */ function f() { " + "  /** @return {number} */ this.foo;" + "}" + "var x = new f();" + "});"); ObjectType x = (ObjectType) findNameType("x", lastLocalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean hasProperty(String propertyName){ if (properties.get(propertyName) != null) { return true; } ObjectType implicitPrototype = getImplicitPrototype(); if (implicitPrototype != null) { return implicitPrototype.hasProperty(propertyName); } return false; }
@Test public void testCollectedFunctionStubLocal(){ testSame( "(function() {" + "/** @constructor */ function f() { " + "  /** @return {number} */ this.foo;" + "}" + "var x = new f();" + "});"); ObjectType x = (ObjectType) findNameType("x", lastLocalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } ConcreteType getPropertyType(final String name){ ConcreteType ret = NONE; for (StaticSlot<ConcreteType> slot : getPropertySlots(name)) { ret = ret.unionWith(slot.getType()); } return ret; }
@Test public void testCollectedFunctionStubLocal(){ testSame( "(function() {" + "/** @constructor */ function f() { " + "  /** @return {number} */ this.foo;" + "}" + "var x = new f();" + "});"); ObjectType x = (ObjectType) findNameType("x", lastLocalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isPropertyTypeInferred(String property){ Property p = properties.get(property); if (p == null) { ObjectType implicitPrototype = getImplicitPrototype(); if (implicitPrototype != null) { return implicitPrototype.isPropertyTypeInferred(property); } return false; } return p.inferred; }
@Test public void testObjectLiteralDoc1(){ Node n = parse("var x = {/** @type {number} */ 1: 2};"); Node objectLit = n.getFirstChild().getFirstChild().getFirstChild(); "<AssertPlaceHolder>"; Node number = objectLit.getFirstChild(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Node getFirstChild(){ return first; }
@Test public void testObjectLiteralDoc1(){ Node n = parse("var x = {/** @type {number} */ 1: 2};"); Node objectLit = n.getFirstChild().getFirstChild().getFirstChild(); "<AssertPlaceHolder>"; Node number = objectLit.getFirstChild(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public JSDocInfo getJSDocInfo(){ return (JSDocInfo) getProp(JSDOC_INFO_PROP); }
@Test public void testSubtypeWithUnknowns2() throws Exception{ JSType recordA = new RecordTypeBuilder(registry) .addProperty("a", new FunctionBuilder(registry) .withReturnType(NUMBER_TYPE) .build(), null) .build(); JSType recordB = new RecordTypeBuilder(registry) .addProperty("a", new FunctionBuilder(registry) .withReturnType(UNKNOWN_TYPE) .build(), null) .build(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isSubtype(JSType that){ if (JSType.isSubtypeHelper(this, that)) { return true; } if (that.isUnionType()) { return false; } if (that.isRecordType()) { return RecordType.isSubtype(this, that.toMaybeRecordType()); } ObjectType thatObj = that.toObjectType(); FunctionType thatCtor = thatObj == null ? null : thatObj.getConstructor(); if (getConstructor() != null && getConstructor().isInterface()) { for (ObjectType thisInterface : getCtorExtendedInterfaces()) { if (thisInterface.isSubtype(that)) { return true; } } } else if (thatCtor != null && thatCtor.isInterface()) { Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces(); for (ObjectType thisInterface : thisInterfaces) { if (thisInterface.isSubtype(that)) { return true; } } } if (isUnknownType() || implicitPrototypeChainIsUnknown()) { return true; } return thatObj != null && this.isImplicitPrototype(thatObj); }
@Test public void testMethodBeforeFunction2() throws Exception{ testSame( "var y = Window.prototype;" + "Window.prototype = {alert: function(message) {}};" + "/** @constructor */ function Window() {}\n" + "var window = new Window(); \n" + "var x = window;"); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; ObjectType y = (ObjectType) findNameType("y", globalScope); "<AssertPlaceHolder>"; } ConcreteType getPropertyType(final String name){ ConcreteType ret = NONE; for (StaticSlot<ConcreteType> slot : getPropertySlots(name)) { ret = ret.unionWith(slot.getType()); } return ret; }
@Test public void testMethodBeforeFunction2() throws Exception{ testSame( "var y = Window.prototype;" + "Window.prototype = {alert: function(message) {}};" + "/** @constructor */ function Window() {}\n" + "var window = new Window(); \n" + "var x = window;"); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; ObjectType y = (ObjectType) findNameType("y", globalScope); "<AssertPlaceHolder>"; } public boolean isPropertyTypeDeclared(String propertyName){ StaticSlot<JSType> slot = getSlot(propertyName); return slot == null ? false : !slot.isTypeInferred(); }
@Test public void testMethodBeforeFunction2() throws Exception{ testSame( "var y = Window.prototype;" + "Window.prototype = {alert: function(message) {}};" + "/** @constructor */ function Window() {}\n" + "var window = new Window(); \n" + "var x = window;"); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; ObjectType y = (ObjectType) findNameType("y", globalScope); "<AssertPlaceHolder>"; } boolean hasOwnProperty(String propertyName){ return properties.get(propertyName) != null; }
@Test public void testMethodBeforeFunction2() throws Exception{ testSame( "var y = Window.prototype;" + "Window.prototype = {alert: function(message) {}};" + "/** @constructor */ function Window() {}\n" + "var window = new Window(); \n" + "var x = window;"); ObjectType x = (ObjectType) findNameType("x", globalScope); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; ObjectType y = (ObjectType) findNameType("y", globalScope); "<AssertPlaceHolder>"; } ConcreteInstanceType getImplicitPrototype(){ if ((prototype == null) && (instanceType.getImplicitPrototype() != null)) { ObjectType proto = instanceType.getImplicitPrototype(); if ((proto != instanceType) && !(proto instanceof UnknownType)) { prototype = factory.createConcreteInstance(proto); } } return prototype; }
@Test public void testEqualsAfterSerializationOfDerivedClass() throws IOException, ClassNotFoundException{ final DerivedMultiKey<?> mk = new DerivedMultiKey<String>("A", "B"); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectOutputStream out = new ObjectOutputStream(baos); out.writeObject(mk); out.close(); final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); final ObjectInputStream in = new ObjectInputStream(bais); final DerivedMultiKey<?> mk2 = (DerivedMultiKey<?>)in.readObject(); in.close(); "<AssertPlaceHolder>"; } private void writeObject(final ObjectOutputStream stream) throws IOException{ stream.defaultWriteObject(); stream.writeInt(this.size()); for (final Entry<K, V> entry : entrySet()) { stream.writeObject(entry.getKey()); stream.writeObject(entry.getValue()); } }
@Test public void testEqualsAfterSerializationOfDerivedClass() throws IOException, ClassNotFoundException{ final DerivedMultiKey<?> mk = new DerivedMultiKey<String>("A", "B"); final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final ObjectOutputStream out = new ObjectOutputStream(baos); out.writeObject(mk); out.close(); final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); final ObjectInputStream in = new ObjectInputStream(bais); final DerivedMultiKey<?> mk2 = (DerivedMultiKey<?>)in.readObject(); in.close(); "<AssertPlaceHolder>"; } private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException{ stream.defaultReadObject(); root = new TrieEntry<K, V>(null, null, -1); int size = stream.readInt(); for(int i = 0; i < size; i++){ K k = (K) stream.readObject(); V v = (V) stream.readObject(); put(k, v); } }
@Test public void testGetLineNumberWithCR() throws Exception{ CSVParser parser = new CSVParser("a\rb\rc", CSVFormat.DEFAULT.withLineSeparator("\r")); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getLineNumber(){ return lexer.getLineNumber(); }
@Test public void testGetLineNumberWithCR() throws Exception{ CSVParser parser = new CSVParser("a\rb\rc", CSVFormat.DEFAULT.withLineSeparator("\r")); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } CSVRecord getRecord() throws IOException{ CSVRecord result = new CSVRecord(null, headerMapping); record.clear(); do { reusableToken.reset(); lexer.nextToken(reusableToken); switch (reusableToken.type) { case TOKEN: record.add(reusableToken.content.toString()); break; case EORECORD: record.add(reusableToken.content.toString()); break; case EOF: if (reusableToken.isReady) { record.add(reusableToken.content.toString()); } else { result = null; } break; case INVALID: throw new IOException("(line " + getLineNumber() + ") invalid parse sequence"); } } while (reusableToken.type == TOKEN); if (!record.isEmpty()) { result = new CSVRecord(record.toArray(new String[record.size()]), headerMapping); } return result; }
@Test public void testEscapedMySqlNullValue() throws Exception{ final Lexer lexer = getLexer("character\\NEscaped", formatWithEscaping); "<AssertPlaceHolder>"; } Token nextToken(final Token token) throws IOException{ int lastChar = in.getLastChar(); int c = in.read(); boolean eol = readEndOfLine(c); if (ignoreEmptyLines) { while (eol && isStartOfLine(lastChar)) { lastChar = c; c = in.read(); eol = readEndOfLine(c); if (isEndOfFile(c)) { token.type = EOF; return token; } } } if (isEndOfFile(lastChar) || (!isDelimiter(lastChar) && isEndOfFile(c))) { token.type = EOF; return token; } if (isStartOfLine(lastChar) && isCommentStart(c)) { final String comment = in.readLine().trim(); token.content.append(comment); token.type = COMMENT; return token; } while (token.type == INVALID) { if (ignoreSurroundingSpaces) { while (isWhitespace(c) && !eol) { c = in.read(); eol = readEndOfLine(c); } } if (isDelimiter(c)) { token.type = TOKEN; } else if (eol) { token.type = EORECORD; } else if (isQuoteChar(c)) { parseEncapsulatedToken(token); } else if (isEndOfFile(c)) { token.type = EOF; token.isReady = true; } else { parseSimpleToken(token, c); } } return token; }
@Test public void testEscapedCharacter() throws Exception{ final Lexer lexer = getLexer("character\\aEscaped", formatWithEscaping); "<AssertPlaceHolder>"; } Token nextToken(final Token token) throws IOException{ int lastChar = in.getLastChar(); int c = in.read(); boolean eol = readEndOfLine(c); if (ignoreEmptyLines) { while (eol && isStartOfLine(lastChar)) { lastChar = c; c = in.read(); eol = readEndOfLine(c); if (isEndOfFile(c)) { token.type = EOF; return token; } } } if (isEndOfFile(lastChar) || (!isDelimiter(lastChar) && isEndOfFile(c))) { token.type = EOF; return token; } if (isStartOfLine(lastChar) && isCommentStart(c)) { final String comment = in.readLine().trim(); token.content.append(comment); token.type = COMMENT; return token; } while (token.type == INVALID) { if (ignoreSurroundingSpaces) { while (isWhitespace(c) && !eol) { c = in.read(); eol = readEndOfLine(c); } } if (isDelimiter(c)) { token.type = TOKEN; } else if (eol) { token.type = EORECORD; } else if (isQuoteChar(c)) { parseEncapsulatedToken(token); } else if (isEndOfFile(c)) { token.type = EOF; token.isReady = true; } else { parseSimpleToken(token, c); } } return token; }
@Test public void testBackslashEscaping() throws IOException{ final String code = "one,two,three\n" + "'',''\n" + "/',/'\n" + "'/'','/''\n" + "'''',''''\n" + "/,,/,\n" + "//,//\n" + "'//','//'\n" + "   8   ,   \"quoted \"\" /\" // string\"   \n" + "9,   /\n   \n" + ""; final String[][] res = { {"one", "two", "three"}, {"", ""}, {"'", "'"}, {"'", "'"}, {"'", "'"}, {",", ","}, {"/", "/"}, {"/", "/"}, {"   8   ", "   \"quoted \"\" /\" / string\"   "}, {"9", "   \n   "}, }; final CSVFormat format = CSVFormat.newBuilder(',').withQuoteChar('\'').withEscape('/') .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build(); final CSVParser parser = new CSVParser(code, format); final List<CSVRecord> records = parser.getRecords(); "<AssertPlaceHolder>"; Utils.compare("Records do not match expected result", res, records); } public List<CSVRecord> getRecords() throws IOException{ final List<CSVRecord> records = new ArrayList<CSVRecord>(); CSVRecord rec; while ((rec = nextRecord()) != null) { records.add(rec); } return records; }
@Test public void testNullRecordSeparatorCsv106(){ final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord(true).withHeader("H1", "H2"); final String formatStr = format.format("A", "B"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String format(final Object... values){ final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } }
@Test public void testHeader() throws IOException{ final StringWriter sw = new StringWriter(); final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null) .withHeader("C1", "C2", "C3")); printer.printRecord("a", "b", "c"); printer.printRecord("x", "y", "z"); "<AssertPlaceHolder>"; printer.close(); } public CSVFormat withHeader(final String... header){ return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); }
@Test public void testHeader() throws IOException{ final StringWriter sw = new StringWriter(); final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null) .withHeader("C1", "C2", "C3")); printer.printRecord("a", "b", "c"); printer.printRecord("x", "y", "z"); "<AssertPlaceHolder>"; printer.close(); } public void printRecord(final Iterable<?> values) throws IOException{ for (final Object value : values) { print(value); } println(); }
@Test public void testEscapeNull1() throws IOException{ StringWriter sw = new StringWriter(); try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) { printer.print("\\"); } "<AssertPlaceHolder>"; } private void print(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException{ if (!newRecord) { out.append(getDelimiter()); } if (object == null) { out.append(value); } else if (isQuoteCharacterSet()) { printAndQuote(object, value, offset, len, out, newRecord); } else if (isEscapeCharacterSet()) { printAndEscape(value, offset, len, out); } else { out.append(value, offset, offset + len); } }
@Test public void testEscapeNull4() throws IOException{ StringWriter sw = new StringWriter(); try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) { printer.print("\\\\"); } "<AssertPlaceHolder>"; } private void print(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException{ if (!newRecord) { out.append(getDelimiter()); } if (object == null) { out.append(value); } else if (isQuoteCharacterSet()) { printAndQuote(object, value, offset, len, out, newRecord); } else if (isEscapeCharacterSet()) { printAndEscape(value, offset, len, out); } else { out.append(value, offset, offset + len); } }
@Test public void testEscapeNull5() throws IOException{ StringWriter sw = new StringWriter(); try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) { printer.print("\\\\"); } "<AssertPlaceHolder>"; } private void print(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException{ if (!newRecord) { out.append(getDelimiter()); } if (object == null) { out.append(value); } else if (isQuoteCharacterSet()) { printAndQuote(object, value, offset, len, out, newRecord); } else if (isEscapeCharacterSet()) { printAndEscape(value, offset, len, out); } else { out.append(value, offset, offset + len); } }
@Test public void testEscapeBackslash1() throws IOException{ StringWriter sw = new StringWriter(); try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) { printer.print("\\"); } "<AssertPlaceHolder>"; } private void print(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException{ if (!newRecord) { out.append(getDelimiter()); } if (object == null) { out.append(value); } else if (isQuoteCharacterSet()) { printAndQuote(object, value, offset, len, out, newRecord); } else if (isEscapeCharacterSet()) { printAndEscape(value, offset, len, out); } else { out.append(value, offset, offset + len); } }
@Test public void testEscapeBackslash4() throws IOException{ StringWriter sw = new StringWriter(); try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) { printer.print("\\\\"); } "<AssertPlaceHolder>"; } private void print(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException{ if (!newRecord) { out.append(getDelimiter()); } if (object == null) { out.append(value); } else if (isQuoteCharacterSet()) { printAndQuote(object, value, offset, len, out, newRecord); } else if (isEscapeCharacterSet()) { printAndEscape(value, offset, len, out); } else { out.append(value, offset, offset + len); } }
@Test public void testEscapeBackslash5() throws IOException{ StringWriter sw = new StringWriter(); try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(QUOTE_CH))) { printer.print("\\\\"); } "<AssertPlaceHolder>"; } private void print(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException{ if (!newRecord) { out.append(getDelimiter()); } if (object == null) { out.append(value); } else if (isQuoteCharacterSet()) { printAndQuote(object, value, offset, len, out, newRecord); } else if (isEscapeCharacterSet()) { printAndEscape(value, offset, len, out); } else { out.append(value, offset, offset + len); } }
@Test public void testDontQuoteEuroFirstChar() throws IOException{ final StringWriter sw = new StringWriter(); try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) { printer.printRecord(EURO_CH, "Deux"); "<AssertPlaceHolder>"; } } public void printRecord(final Appendable out, final Object... values) throws IOException{ for (int i = 0; i < values.length; i++) { print(values[i], out, i == 0); } println(out); }
@Test public void testIteratorSequenceBreaking() throws IOException{ final String fiveRows = "1\n2\n3\n4\n5\n"; CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows)); int recordNumber = 0; Iterator<CSVRecord> iter = parser.iterator(); recordNumber = 0; while (iter.hasNext()) { CSVRecord record = iter.next(); recordNumber++; "<AssertPlaceHolder>"; if (recordNumber >= 2) { break; } } iter.hasNext(); while (iter.hasNext()) { CSVRecord record = iter.next(); recordNumber++; "<AssertPlaceHolder>"; } parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows)); recordNumber = 0; for (CSVRecord record : parser) { recordNumber++; "<AssertPlaceHolder>"; if (recordNumber >= 2) { break; } } for (CSVRecord record : parser) { recordNumber++; "<AssertPlaceHolder>"; } parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows)); recordNumber = 0; for (CSVRecord record : parser) { recordNumber++; "<AssertPlaceHolder>"; if (recordNumber >= 2) { break; } } parser.iterator().hasNext(); for (CSVRecord record : parser) { recordNumber++; "<AssertPlaceHolder>"; } } public String get(final String name){ if (mapping == null) { throw new IllegalStateException( "No header mapping was specified, the record values can't be accessed by name"); } final Integer index = mapping.get(name); if (index == null) { throw new IllegalArgumentException(String.format("Mapping for %s not found, expected one of %s", name, mapping.keySet())); } try { return values[index.intValue()]; } catch (final ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException(String.format( "Index for header '%s' is %d but CSVRecord only has %d values!", name, index, Integer.valueOf(values.length))); } }
@Test public void testOffsetWithInputOffset() throws Exception{ final JsonFactory f = new JsonFactory(); JsonLocation loc; JsonParser p; byte[] b = "   { }  ".getBytes("UTF-8"); p = f.createParser(b, 3, b.length-5); assertToken(JsonToken.START_OBJECT, p.nextToken()); loc = p.getTokenLocation(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; loc = p.getCurrentLocation(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; p.close(); } public JsonLocation getTokenLocation(){ return new JsonLocation(_ioContext.getSourceReference(), getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr()); }
@Test public void testOffsetWithInputOffset() throws Exception{ final JsonFactory f = new JsonFactory(); JsonLocation loc; JsonParser p; byte[] b = "   { }  ".getBytes("UTF-8"); p = f.createParser(b, 3, b.length-5); assertToken(JsonToken.START_OBJECT, p.nextToken()); loc = p.getTokenLocation(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; loc = p.getCurrentLocation(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; p.close(); } public JsonLocation getCurrentLocation(){ int col = _inputPtr - _currInputRowStart + 1; return new JsonLocation(_ioContext.getSourceReference(), _currInputProcessed + _inputPtr, -1L, _currInputRow, col); }
@Test public void testOffsetWithInputOffset() throws Exception{ final JsonFactory f = new JsonFactory(); JsonLocation loc; JsonParser p; byte[] b = "   { }  ".getBytes("UTF-8"); p = f.createParser(b, 3, b.length-5); assertToken(JsonToken.START_OBJECT, p.nextToken()); loc = p.getTokenLocation(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; loc = p.getCurrentLocation(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; p.close(); } public long getByteOffset(){ return _totalBytes; }
@Test public void testOffsetWithInputOffset() throws Exception{ final JsonFactory f = new JsonFactory(); JsonLocation loc; JsonParser p; byte[] b = "   { }  ".getBytes("UTF-8"); p = f.createParser(b, 3, b.length-5); assertToken(JsonToken.START_OBJECT, p.nextToken()); loc = p.getTokenLocation(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; loc = p.getCurrentLocation(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; p.close(); } public long getCharOffset(){ return _totalChars; }
@Test public void testIZeroIndex() throws Exception{ JsonPointer ptr = JsonPointer.compile("/0"); "<AssertPlaceHolder>"; ptr = JsonPointer.compile("/00"); "<AssertPlaceHolder>"; } public int getMatchingIndex(){ return _matchingElementIndex; }
@Test public void testOffsetWithObjectFieldsUsingReader() throws Exception{ final JsonFactory f = new JsonFactory(); char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray(); JsonParser p = f.createParser(c); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; p.close(); } public JsonLocation getTokenLocation(){ final Object src = _ioContext.getSourceReference(); if (_currToken == JsonToken.FIELD_NAME) { return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol); } return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr()); }
@Test public void testOffsetWithObjectFieldsUsingReader() throws Exception{ final JsonFactory f = new JsonFactory(); char[] c = "{\"f1\":\"v1\",\"f2\":{\"f3\":\"v3\"},\"f4\":[true,false],\"f5\":5}".toCharArray(); JsonParser p = f.createParser(c); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; p.close(); } public long getCharOffset(){ return _totalChars; }
@Test public void testInitialized() throws Exception{ JsonParser p1 = JSON_FACTORY.createParser("1 2"); JsonParser p2 = JSON_FACTORY.createParser("3 false"); assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken()); assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken()); JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2); assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken()); "<AssertPlaceHolder>"; assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken()); "<AssertPlaceHolder>"; seq.close(); } public JsonParser createParser(InputStream in) throws IOException, JsonParseException{ IOContext ctxt = _createContext(in, false); return _createParser(_decorate(in, ctxt), ctxt); }
@Test public void testInitialized() throws Exception{ JsonParser p1 = JSON_FACTORY.createParser("1 2"); JsonParser p2 = JSON_FACTORY.createParser("3 false"); assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken()); assertToken(JsonToken.VALUE_NUMBER_INT, p1.nextToken()); JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2); assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken()); "<AssertPlaceHolder>"; assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken()); "<AssertPlaceHolder>"; seq.close(); } public static JsonParserSequence createFlattened(JsonParser first, JsonParser second){ if (!(first instanceof JsonParserSequence || second instanceof JsonParserSequence)) { return new JsonParserSequence(new JsonParser[] { first, second }); } ArrayList<JsonParser> p = new ArrayList<JsonParser>(); if (first instanceof JsonParserSequence) { ((JsonParserSequence) first).addFlattenedActiveParsers(p); } else { p.add(first); } if (second instanceof JsonParserSequence) { ((JsonParserSequence) second).addFlattenedActiveParsers(p); } else { p.add(second); } return new JsonParserSequence(p.toArray(new JsonParser[p.size()])); }
@Test public void testTokensSingleMatchWithPath() throws Exception{ JsonParser p0 = JSON_F.createParser(SIMPLE); JsonParser p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), true, false ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.START_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.FIELD_NAME, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.START_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; assertToken(JsonToken.FIELD_NAME, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.END_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; assertToken(JsonToken.END_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; p.clearCurrentToken(); "<AssertPlaceHolder>"; p.close(); } @Override public JsonToken getCurrentToken(){ return _currToken; }
@Test public void testTokensSingleMatchWithPath() throws Exception{ JsonParser p0 = JSON_F.createParser(SIMPLE); JsonParser p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), true, false ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.START_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.FIELD_NAME, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.START_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; assertToken(JsonToken.FIELD_NAME, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.END_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; assertToken(JsonToken.END_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; p.clearCurrentToken(); "<AssertPlaceHolder>"; p.close(); } public JsonToken nextToken() throws IOException{ if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) { if (_currToken.isStructEnd()) { if (_headContext.isStartHandled()) { return (_currToken = null); } } else if (_currToken.isScalarValue()) { if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) { return (_currToken = null); } } } TokenFilterContext ctxt = _exposedContext; if (ctxt != null) { while (true) { JsonToken t = ctxt.nextTokenToRead(); if (t != null) { _currToken = t; return t; } if (ctxt == _headContext) { _exposedContext = null; if (ctxt.inArray()) { t = delegate.getCurrentToken(); _currToken = t; return t; } break; } ctxt = _headContext.findChildOf(ctxt); _exposedContext = ctxt; if (ctxt == null) { throw _constructError("Unexpected problem: chain of filtered context broken"); } } } JsonToken t = delegate.nextToken(); if (t == null) { _currToken = t; return t; } TokenFilter f; switch (t.id()) { case ID_START_ARRAY: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildArrayContext(f, true); return (_currToken = t); } if (f == null) { delegate.skipChildren(); break; } f = _headContext.checkValue(f); if (f == null) { delegate.skipChildren(); break; } if (f != TokenFilter.INCLUDE_ALL) { f = f.filterStartArray(); } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildArrayContext(f, true); return (_currToken = t); } _headContext = _headContext.createChildArrayContext(f, false); if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } break; case ID_START_OBJECT: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildObjectContext(f, true); return (_currToken = t); } if (f == null) { delegate.skipChildren(); break; } f = _headContext.checkValue(f); if (f == null) { delegate.skipChildren(); break; } if (f != TokenFilter.INCLUDE_ALL) { f = f.filterStartObject(); } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildObjectContext(f, true); return (_currToken = t); } _headContext = _headContext.createChildObjectContext(f, false); if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } break; case ID_END_ARRAY: case ID_END_OBJECT: { boolean returnEnd = _headContext.isStartHandled(); f = _headContext.getFilter(); if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) { f.filterFinishArray(); } _headContext = _headContext.getParent(); _itemFilter = _headContext.getFilter(); if (returnEnd) { return (_currToken = t); } } break; case ID_FIELD_NAME: { final String name = delegate.getCurrentName(); f = _headContext.setFieldName(name); if (f == TokenFilter.INCLUDE_ALL) { _itemFilter = f; if (!_includePath) { if (_includeImmediateParent && !_headContext.isStartHandled()) { t = _headContext.nextTokenToRead(); _exposedContext = _headContext; } } return (_currToken = t); } if (f == null) { delegate.nextToken(); delegate.skipChildren(); break; } f = f.includeProperty(name); if (f == null) { delegate.nextToken(); delegate.skipChildren(); break; } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_includePath) { return (_currToken = t); } } if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } break; } default: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { return (_currToken = t); } if (f != null) { f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { return (_currToken = t); } } break; } return _nextToken2(); }
@Test public void testTokensSingleMatchWithPath() throws Exception{ JsonParser p0 = JSON_F.createParser(SIMPLE); JsonParser p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), true, false ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.START_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.FIELD_NAME, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.START_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; assertToken(JsonToken.FIELD_NAME, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.END_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; assertToken(JsonToken.END_OBJECT, p.nextToken()); "<AssertPlaceHolder>"; p.clearCurrentToken(); "<AssertPlaceHolder>"; p.close(); } public String getCurrentName() throws IOException{ JsonStreamContext ctxt = _filterContext(); if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { JsonStreamContext parent = ctxt.getParent(); return (parent == null) ? null : parent.getCurrentName(); } return ctxt.getCurrentName(); }
@Test public void testBasicSingleMatchFilteringWithPath() throws Exception{ JsonParser p0 = JSON_F.createParser(SIMPLE); JsonParser p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), true, false ); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; } public JsonParser createParser(InputStream in) throws IOException, JsonParseException{ IOContext ctxt = _createContext(in, false); return _createParser(_decorate(in, ctxt), ctxt); }
@Test public void testSkippingForSingleWithPath() throws Exception{ JsonParser p0 = JSON_F.createParser(SIMPLE); JsonParser p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), true, false ); assertToken(JsonToken.START_OBJECT, p.nextToken()); p.skipChildren(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } @Override public JsonToken getCurrentToken(){ return _currToken; }
@Test public void testSkippingForSingleWithPath() throws Exception{ JsonParser p0 = JSON_F.createParser(SIMPLE); JsonParser p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), true, false ); assertToken(JsonToken.START_OBJECT, p.nextToken()); p.skipChildren(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public JsonToken nextToken() throws IOException{ if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) { if (_currToken.isStructEnd()) { if (_headContext.isStartHandled()) { return (_currToken = null); } } else if (_currToken.isScalarValue()) { if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) { return (_currToken = null); } } } TokenFilterContext ctxt = _exposedContext; if (ctxt != null) { while (true) { JsonToken t = ctxt.nextTokenToRead(); if (t != null) { _currToken = t; return t; } if (ctxt == _headContext) { _exposedContext = null; if (ctxt.inArray()) { t = delegate.getCurrentToken(); _currToken = t; return t; } break; } ctxt = _headContext.findChildOf(ctxt); _exposedContext = ctxt; if (ctxt == null) { throw _constructError("Unexpected problem: chain of filtered context broken"); } } } JsonToken t = delegate.nextToken(); if (t == null) { _currToken = t; return t; } TokenFilter f; switch (t.id()) { case ID_START_ARRAY: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildArrayContext(f, true); return (_currToken = t); } if (f == null) { delegate.skipChildren(); break; } f = _headContext.checkValue(f); if (f == null) { delegate.skipChildren(); break; } if (f != TokenFilter.INCLUDE_ALL) { f = f.filterStartArray(); } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildArrayContext(f, true); return (_currToken = t); } _headContext = _headContext.createChildArrayContext(f, false); if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } break; case ID_START_OBJECT: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildObjectContext(f, true); return (_currToken = t); } if (f == null) { delegate.skipChildren(); break; } f = _headContext.checkValue(f); if (f == null) { delegate.skipChildren(); break; } if (f != TokenFilter.INCLUDE_ALL) { f = f.filterStartObject(); } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildObjectContext(f, true); return (_currToken = t); } _headContext = _headContext.createChildObjectContext(f, false); if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } break; case ID_END_ARRAY: case ID_END_OBJECT: { boolean returnEnd = _headContext.isStartHandled(); f = _headContext.getFilter(); if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) { f.filterFinishArray(); } _headContext = _headContext.getParent(); _itemFilter = _headContext.getFilter(); if (returnEnd) { return (_currToken = t); } } break; case ID_FIELD_NAME: { final String name = delegate.getCurrentName(); f = _headContext.setFieldName(name); if (f == TokenFilter.INCLUDE_ALL) { _itemFilter = f; if (!_includePath) { if (_includeImmediateParent && !_headContext.isStartHandled()) { t = _headContext.nextTokenToRead(); _exposedContext = _headContext; } } return (_currToken = t); } if (f == null) { delegate.nextToken(); delegate.skipChildren(); break; } f = f.includeProperty(name); if (f == null) { delegate.nextToken(); delegate.skipChildren(); break; } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_includePath) { return (_currToken = t); } } if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } break; } default: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { return (_currToken = t); } if (f != null) { f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { return (_currToken = t); } } break; } return _nextToken2(); }
@Test public void testSingleMatchFilteringWithPath() throws Exception{ String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}"); JsonParser p0 = JSON_F.createParser(jsonString); FilteringParserDelegate p = new FilteringParserDelegate(p0, new NameMatchFilter("a"), true, false ); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testAllowMultipleMatchesWithPath1() throws Exception{ String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'value':\"val\",'b':true}"); JsonParser p0 = JSON_F.createParser(jsonString); FilteringParserDelegate p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), true, true ); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testAllowMultipleMatchesWithPath2() throws Exception{ String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'array':[3,4],'value':{'value0':2}},'value':\"val\",'b':true}"); JsonParser p0 = JSON_F.createParser(jsonString); FilteringParserDelegate p = new FilteringParserDelegate(p0, new IndexMatchFilter(1), true, true ); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testMultipleMatchFilteringWithPath1() throws Exception{ JsonParser p0 = JSON_F.createParser(SIMPLE); FilteringParserDelegate p = new FilteringParserDelegate(p0, new NameMatchFilter("value0", "value2"), true,   true   ); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testMultipleMatchFilteringWithPath2() throws Exception{ String INPUT = aposToQuotes("{'a':123,'ob':{'value0':2,'value':3,'value2':4},'b':true}"); JsonParser p0 = JSON_F.createParser(INPUT); FilteringParserDelegate p = new FilteringParserDelegate(p0, new NameMatchFilter("b", "value"), true, true); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testMultipleMatchFilteringWithPath3() throws Exception{ final String JSON = aposToQuotes("{'root':{'a0':true,'a':{'value':3},'b':{'value':\"foo\"}},'b0':false}"); JsonParser p0 = JSON_F.createParser(JSON); FilteringParserDelegate p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), true, true); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testSingleMatchFilteringWithoutPath() throws Exception{ JsonParser p0 = JSON_F.createParser(SIMPLE); FilteringParserDelegate p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), false, false ); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testNotAllowMultipleMatchesWithoutPath1() throws Exception{ String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'b':true}"); JsonParser p0 = JSON_F.createParser(jsonString); FilteringParserDelegate p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), false, false ); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testNotAllowMultipleMatchesWithoutPath2() throws Exception{ String jsonString = aposToQuotes("{'a':123,'array':[1,2],'array':[3,4],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'value':\"val\",'b':true}"); JsonParser p0 = JSON_F.createParser(jsonString); FilteringParserDelegate p = new FilteringParserDelegate(p0, new IndexMatchFilter(1), false, false ); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testIndexMatchWithPath1() throws Exception{ FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE), new IndexMatchFilter(1), true, true); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE), new IndexMatchFilter(0), true, true); result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testIndexMatchWithPath2() throws Exception{ FilteringParserDelegate p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE), new IndexMatchFilter(0, 1), true, true); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; String JSON = aposToQuotes("{'a':123,'array':[1,2,3,4,5],'b':[1,2,3]}"); p = new FilteringParserDelegate(JSON_F.createParser(JSON), new IndexMatchFilter(1, 3), true, true); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testAllowMultipleMatchesWithoutPath() throws Exception{ String jsonString = aposToQuotes("{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4,'value':{'value0':2}},'value':\"val\",'b':true}"); JsonParser p0 = JSON_F.createParser(jsonString); FilteringParserDelegate p = new FilteringParserDelegate(p0, new NameMatchFilter("value"), false, true ); String result = readAndWrite(JSON_F, p); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getMatchCount(){ return _matchCount; }
@Test public void testLocationOffsets() throws Exception{ JsonParser parser = DEFAULT_F.createNonBlockingByteArrayParser(); ByteArrayFeeder feeder = (ByteArrayFeeder) parser.getNonBlockingInputFeeder(); byte[] input = utf8Bytes("[[["); feeder.feedInput(input, 2, 3); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; feeder.feedInput(input, 0, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; parser.close(); } public JsonLocation getCurrentLocation(){ int col = _inputPtr - _currInputRowStart + 1; int row = Math.max(_currInputRow, _currInputRowAlt); return new JsonLocation(_getSourceReference(), _currInputProcessed + (_inputPtr - _currBufferStart), -1L, row, col); }
@Test public void testLocationOffsets() throws Exception{ JsonParser parser = DEFAULT_F.createNonBlockingByteArrayParser(); ByteArrayFeeder feeder = (ByteArrayFeeder) parser.getNonBlockingInputFeeder(); byte[] input = utf8Bytes("[[["); feeder.feedInput(input, 2, 3); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; feeder.feedInput(input, 0, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; parser.close(); } public long getByteOffset(){ return _totalBytes; }
@Test public void testXmlAttributesWithNextTextValue() throws Exception{ final String XML = "<data max=\"7\" offset=\"9\"/>"; FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML)); assertToken(JsonToken.START_OBJECT, xp.nextToken()); assertToken(JsonToken.FIELD_NAME, xp.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.FIELD_NAME, xp.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.END_OBJECT, xp.nextToken()); xp.close(); } public JsonToken nextToken() throws IOException{ _binaryValue = null; if (_nextToken != null) { JsonToken t = _nextToken; _currToken = t; _nextToken = null; switch (t) { case START_OBJECT: _parsingContext = _parsingContext.createChildObjectContext(-1, -1); break; case START_ARRAY: _parsingContext = _parsingContext.createChildArrayContext(-1, -1); break; case END_OBJECT: case END_ARRAY: _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); break; case FIELD_NAME: _parsingContext.setCurrentName(_xmlTokens.getLocalName()); break; default: } return t; } int token = _xmlTokens.next(); while (token == XmlTokenStream.XML_START_ELEMENT) { if (_mayBeLeaf) { _nextToken = JsonToken.FIELD_NAME; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } if (_parsingContext.inArray()) { token = _xmlTokens.next(); _mayBeLeaf = true; continue; } String name = _xmlTokens.getLocalName(); _parsingContext.setCurrentName(name); if (_namesToWrap != null && _namesToWrap.contains(name)) { _xmlTokens.repeatStartElement(); } _mayBeLeaf = true; return (_currToken = JsonToken.FIELD_NAME); } while (true) { switch (token) { case XmlTokenStream.XML_END_ELEMENT: if (_mayBeLeaf) { _mayBeLeaf = false; if (_parsingContext.inArray()) { _nextToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } return (_currToken = JsonToken.VALUE_NULL); } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); return _currToken; case XmlTokenStream.XML_ATTRIBUTE_NAME: if (_mayBeLeaf) { _mayBeLeaf = false; _nextToken = JsonToken.FIELD_NAME; _currText = _xmlTokens.getText(); _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } _parsingContext.setCurrentName(_xmlTokens.getLocalName()); return (_currToken = JsonToken.FIELD_NAME); case XmlTokenStream.XML_ATTRIBUTE_VALUE: _currText = _xmlTokens.getText(); return (_currToken = JsonToken.VALUE_STRING); case XmlTokenStream.XML_TEXT: _currText = _xmlTokens.getText(); if (_mayBeLeaf) { _mayBeLeaf = false; _xmlTokens.skipEndElement(); if (_parsingContext.inArray()) { if (_isEmpty(_currText)) { _nextToken = JsonToken.END_OBJECT; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); return (_currToken = JsonToken.START_OBJECT); } } return (_currToken = JsonToken.VALUE_STRING); } else { if (_parsingContext.inObject()) { if ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) { token = _xmlTokens.next(); continue; } } } _parsingContext.setCurrentName(_cfgNameForTextElement); _nextToken = JsonToken.VALUE_STRING; return (_currToken = JsonToken.FIELD_NAME); case XmlTokenStream.XML_END: return (_currToken = null); } } }
@Test public void testXmlAttributesWithNextTextValue() throws Exception{ final String XML = "<data max=\"7\" offset=\"9\"/>"; FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML)); assertToken(JsonToken.START_OBJECT, xp.nextToken()); assertToken(JsonToken.FIELD_NAME, xp.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.FIELD_NAME, xp.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.END_OBJECT, xp.nextToken()); xp.close(); } public String getCurrentName() throws IOException{ String name; if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { XmlReadContext parent = _parsingContext.getParent(); name = parent.getCurrentName(); } else { name = _parsingContext.getCurrentName(); } if (name == null) { throw new IllegalStateException("Missing name, in state: "+_currToken); } return name; }
@Test public void testXmlAttributesWithNextTextValue() throws Exception{ final String XML = "<data max=\"7\" offset=\"9\"/>"; FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML)); assertToken(JsonToken.START_OBJECT, xp.nextToken()); assertToken(JsonToken.FIELD_NAME, xp.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.FIELD_NAME, xp.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.END_OBJECT, xp.nextToken()); xp.close(); } public String nextTextValue() throws IOException{ _binaryValue = null; if (_nextToken != null) { JsonToken t = _nextToken; _currToken = t; _nextToken = null; if (t == JsonToken.VALUE_STRING) { return _currText; } _updateState(t); return null; } int token = _xmlTokens.next(); while (token == XmlTokenStream.XML_START_ELEMENT) { if (_mayBeLeaf) { _nextToken = JsonToken.FIELD_NAME; _parsingContext = _parsingContext.createChildObjectContext(-1, -1); _currToken = JsonToken.START_OBJECT; return null; } if (_parsingContext.inArray()) { token = _xmlTokens.next(); _mayBeLeaf = true; continue; } String name = _xmlTokens.getLocalName(); _parsingContext.setCurrentName(name); if (_namesToWrap != null && _namesToWrap.contains(name)) { _xmlTokens.repeatStartElement(); } _mayBeLeaf = true; _currToken = JsonToken.FIELD_NAME; return null; } switch (token) { case XmlTokenStream.XML_END_ELEMENT: if (_mayBeLeaf) { _mayBeLeaf = false; _currToken = JsonToken.VALUE_STRING; return (_currText = ""); } _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT; _parsingContext = _parsingContext.getParent(); _namesToWrap = _parsingContext.getNamesToWrap(); break; case XmlTokenStream.XML_ATTRIBUTE_NAME: if (_mayBeLeaf) { _mayBeLeaf = false; _nextToken = JsonToken.FIELD_NAME; _currText = _xmlTokens.getText(); _parsingContext = _parsingContext.createChildObjectContext(-1, -1); _currToken = JsonToken.START_OBJECT; } else { _parsingContext.setCurrentName(_xmlTokens.getLocalName()); _currToken = JsonToken.FIELD_NAME; } break; case XmlTokenStream.XML_ATTRIBUTE_VALUE: _currText = _xmlTokens.getText(); _currToken = JsonToken.VALUE_STRING; break; case XmlTokenStream.XML_TEXT: _currText = _xmlTokens.getText(); if (_mayBeLeaf) { _mayBeLeaf = false; _xmlTokens.skipEndElement(); _currToken = JsonToken.VALUE_STRING; return _currText; } _parsingContext.setCurrentName(_cfgNameForTextElement); _nextToken = JsonToken.VALUE_STRING; _currToken = JsonToken.FIELD_NAME; break; case XmlTokenStream.XML_END: _currToken = null; } return null; }
@Test public void testXmlAttributesWithNextTextValue() throws Exception{ final String XML = "<data max=\"7\" offset=\"9\"/>"; FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML)); assertToken(JsonToken.START_OBJECT, xp.nextToken()); assertToken(JsonToken.FIELD_NAME, xp.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.FIELD_NAME, xp.nextToken()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; assertToken(JsonToken.END_OBJECT, xp.nextToken()); xp.close(); } public String getText() throws IOException{ if (_currToken == null) { return null; } switch (_currToken) { case FIELD_NAME: return getCurrentName(); case VALUE_STRING: return _currText; default: return _currToken.asString(); } }
@Test public void testBadFactoryImplementation(){ try { context.createPath("foo/bar"); fail("should fail with JXPathException caused by JXPathAbstractFactoryException"); } catch (JXPathException e) { "<AssertPlaceHolder>"; } } public NodePointer createPath(JXPathContext context, Object value){ if (index != WHOLE_COLLECTION && index >= getLength()) { createPath(context); } setValue(value); return this; }
@Test public void testMath1021(){ final int N = 43130568; final int m = 42976365; final int n = 50; final HypergeometricDistribution dist = new HypergeometricDistribution(N, m, n); for (int i = 0; i < 100; i++) { final int sample = dist.sample(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } } public int sample(){ return innerDistribution.sample(); }
@Test public void testReciprocalZero(){ "<AssertPlaceHolder>"; } public Complex reciprocal(){ if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { return NaN; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }
@Test public void testTrivial(){ LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 }); NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE, new SimpleValueChecker(1e-6, 1e-6)); PointValuePair optimum = optimizer.optimize(new MaxEval(100), problem.getObjectiveFunction(), problem.getObjectiveFunctionGradient(), GoalType.MINIMIZE, new InitialGuess(new double[] { 0 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getIterations(){ return iterations.getCount(); }
@Test public void testMaximize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3.0, 0.0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return evaluations.getCount(); }
@Test public void testMaximize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3.0, 0.0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getIterations(){ return iterations.getCount(); }
@Test public void testMaximize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3.0, 0.0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public PointValuePair getPoint(int index){ if (index < 0 || index >= simplex.length) { throw new OutOfRangeException(index, 0, simplex.length - 1); } return simplex[index]; }
@Test public void testMaximize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3.0, 0.0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return getEntry(getIndex()); }
@Test public void testMaximize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3.0, 0.0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return v.getEntry(getIndex()); }
@Test public void testMaximize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30)); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return evaluations.getCount(); }
@Test public void testMaximize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30)); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getIterations(){ return iterations.getCount(); }
@Test public void testMaximize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30)); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public PointValuePair getPoint(int index){ if (index < 0 || index >= simplex.length) { throw new OutOfRangeException(index, 0, simplex.length - 1); } return simplex[index]; }
@Test public void testMaximize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30)); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return getEntry(getIndex()); }
@Test public void testMaximize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30)); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return v.getEntry(getIndex()); }
@Test public void testMinimize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return evaluations.getCount(); }
@Test public void testMinimize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getIterations(){ return iterations.getCount(); }
@Test public void testMinimize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public PointValuePair getPoint(int index){ if (index < 0 || index >= simplex.length) { throw new OutOfRangeException(index, 0, simplex.length - 1); } return simplex[index]; }
@Test public void testMinimize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return getEntry(getIndex()); }
@Test public void testMinimize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return v.getEntry(getIndex()); }
@Test public void testMinimize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return evaluations.getCount(); }
@Test public void testMinimize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getIterations(){ return iterations.getCount(); }
@Test public void testMinimize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public PointValuePair getPoint(int index){ if (index < 0 || index >= simplex.length) { throw new OutOfRangeException(index, 0, simplex.length - 1); } return simplex[index]; }
@Test public void testMinimize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return getEntry(getIndex()); }
@Test public void testMinimize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-11, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(200), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new MultiDirectionalSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return v.getEntry(getIndex()); }
@Test public void testMaximize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return evaluations.getCount(); }
@Test public void testMaximize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getIterations(){ return iterations.getCount(); }
@Test public void testMaximize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public PointValuePair getPoint(int index){ if (index < 0 || index >= simplex.length) { throw new OutOfRangeException(index, 0, simplex.length - 1); } return simplex[index]; }
@Test public void testMaximize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return getEntry(getIndex()); }
@Test public void testMaximize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return v.getEntry(getIndex()); }
@Test public void testMaximize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return evaluations.getCount(); }
@Test public void testMaximize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getIterations(){ return iterations.getCount(); }
@Test public void testMaximize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public PointValuePair getPoint(int index){ if (index < 0 || index >= simplex.length) { throw new OutOfRangeException(index, 0, simplex.length - 1); } return simplex[index]; }
@Test public void testMaximize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return getEntry(getIndex()); }
@Test public void testMaximize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MAXIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return v.getEntry(getIndex()); }
@Test public void testMinimize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return evaluations.getCount(); }
@Test public void testMinimize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getIterations(){ return iterations.getCount(); }
@Test public void testMinimize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public PointValuePair getPoint(int index){ if (index < 0 || index >= simplex.length) { throw new OutOfRangeException(index, 0, simplex.length - 1); } return simplex[index]; }
@Test public void testMinimize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return getEntry(getIndex()); }
@Test public void testMinimize1(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { -3, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return v.getEntry(getIndex()); }
@Test public void testMinimize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return evaluations.getCount(); }
@Test public void testMinimize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getIterations(){ return iterations.getCount(); }
@Test public void testMinimize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public PointValuePair getPoint(int index){ if (index < 0 || index >= simplex.length) { throw new OutOfRangeException(index, 0, simplex.length - 1); } return simplex[index]; }
@Test public void testMinimize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return getEntry(getIndex()); }
@Test public void testMinimize2(){ SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30); final FourExtrema fourExtrema = new FourExtrema(); final PointValuePair optimum = optimizer.optimize(new MaxEval(100), new ObjectiveFunction(fourExtrema), GoalType.MINIMIZE, new InitialGuess(new double[] { 1, 0 }), new NelderMeadSimplex(new double[] { 0.2, 0.2 })); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return v.getEntry(getIndex()); }
@Test public void testRevert(){ Line line = new Line(new Vector3D(1653345.6696423641, 6170370.041579291, 90000), new Vector3D(1650757.5050732433, 6160710.879908984, 0.9)); Vector3D expected = line.getDirection().negate(); Line reverted = line.revert(); "<AssertPlaceHolder>"; } public Rotation revert(){ return new Rotation(-q0, q1, q2, q3, false); }
@Test public void testAtan2SpecialCases(){ DerivativeStructure pp = DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0), new DerivativeStructure(2, 2, 1, +0.0)); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; DerivativeStructure pn = DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0), new DerivativeStructure(2, 2, 1, -0.0)); "<AssertPlaceHolder>"; DerivativeStructure np = DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0), new DerivativeStructure(2, 2, 1, +0.0)); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; DerivativeStructure nn = DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, -0.0), new DerivativeStructure(2, 2, 1, -0.0)); "<AssertPlaceHolder>"; } public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x) throws DimensionMismatchException{ y.compiler.checkCompatibility(x.compiler); final DerivativeStructure result = new DerivativeStructure(y.compiler); y.compiler.atan2(y.data, 0, x.data, 0, result.data, 0); return result; }
@Test public void testUnivariateDistribution(){ final double[] mu = { -1.5 }; final double[][] sigma = { { 1 } }; final MultivariateNormalDistribution multi = new MultivariateNormalDistribution(mu, sigma); final NormalDistribution uni = new NormalDistribution(mu[0], sigma[0][0]); final Random rng = new Random(); final int numCases = 100; final double tol = Math.ulp(1d); for (int i = 0; i < numCases; i++) { final double v = rng.nextDouble() * 10 - 5; "<AssertPlaceHolder>"; } } public double density(double x){ final double n = degreesOfFreedom; final double nPlus1Over2 = (n + 1) / 2; return FastMath.exp(Gamma.logGamma(nPlus1Over2) - 0.5 * (FastMath.log(FastMath.PI) + FastMath.log(n)) - Gamma.logGamma(n / 2) - nPlus1Over2 * FastMath.log(1 + x * x / n)); }
@Test public void testMath904(){ final double x = -1; final double y = (5 + 1e-15) * 1e15; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static double pow(double d, int e){ if (e == 0) { return 1.0; } else if (e < 0) { e = -e; d = 1.0 / d; } final int splitFactor = 0x8000001; final double cd       = splitFactor * d; final double d1High   = cd - (cd - d); final double d1Low    = d - d1High; double resultHigh = 1; double resultLow  = 0; double d2p     = d; double d2pHigh = d1High; double d2pLow  = d1Low; while (e != 0) { if ((e & 0x1) != 0) { final double tmpHigh = resultHigh * d2p; final double cRH     = splitFactor * resultHigh; final double rHH     = cRH - (cRH - resultHigh); final double rHL     = resultHigh - rHH; final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow); resultHigh = tmpHigh; resultLow  = resultLow * d2p + tmpLow; } final double tmpHigh = d2pHigh * d2p; final double cD2pH   = splitFactor * d2pHigh; final double d2pHH   = cD2pH - (cD2pH - d2pHigh); final double d2pHL   = d2pHigh - d2pHH; final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow); final double cTmpH   = splitFactor * tmpHigh; d2pHigh = cTmpH - (cTmpH - tmpHigh); d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh); d2p     = d2pHigh + d2pLow; e = e >> 1; } return resultHigh + resultLow; }
@Test public void testMath905LargePositive(){ final double start = StrictMath.log(Double.MAX_VALUE); final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); final double end = 2 * StrictMath.log(endT); double maxErr = 0; for (double x = start; x < end; x += 1e-3) { final double tst = FastMath.cosh(x); final double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; for (double x = start; x < end; x += 1e-3) { final double tst = FastMath.sinh(x); final double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; } public static double max(final double a, final double b){ if (a > b) { return a; } if (a < b) { return b; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; } return a; }
@Test public void testMath905LargePositive(){ final double start = StrictMath.log(Double.MAX_VALUE); final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); final double end = 2 * StrictMath.log(endT); double maxErr = 0; for (double x = start; x < end; x += 1e-3) { final double tst = FastMath.cosh(x); final double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; for (double x = start; x < end; x += 1e-3) { final double tst = FastMath.sinh(x); final double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; } public static float ulp(float x){ if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); }
@Test public void testMath905LargePositive(){ final double start = StrictMath.log(Double.MAX_VALUE); final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); final double end = 2 * StrictMath.log(endT); double maxErr = 0; for (double x = start; x < end; x += 1e-3) { final double tst = FastMath.cosh(x); final double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; for (double x = start; x < end; x += 1e-3) { final double tst = FastMath.sinh(x); final double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; } public static double sinh(double x){ boolean negate = false; if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x); } if (x < -20) { return -0.5 * exp(-x); } if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; } double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa; recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5; } else { double hiPrec[] = new double[2]; expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000; double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; rb += -ya * denomb * denomr * denomr; temp = ya + ra; yb += -(temp - ya - ra); ya = temp; temp = ya + rb; yb += -(temp - ya - rb); ya = temp; result = ya + yb; result *= 0.5; } if (negate) { result = -result; } return result; }
@Test public void testMath905LargePositive(){ final double start = StrictMath.log(Double.MAX_VALUE); final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); final double end = 2 * StrictMath.log(endT); double maxErr = 0; for (double x = start; x < end; x += 1e-3) { final double tst = FastMath.cosh(x); final double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; for (double x = start; x < end; x += 1e-3) { final double tst = FastMath.sinh(x); final double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; } public static double cosh(double x){ if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x); } if (x < -20) { return 0.5 * exp(-x); } final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb; result *= 0.5; return result; }
@Test public void testMath905LargeNegative(){ final double start = -StrictMath.log(Double.MAX_VALUE); final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); final double end = -2 * StrictMath.log(endT); double maxErr = 0; for (double x = start; x > end; x -= 1e-3) { final double tst = FastMath.cosh(x); final double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; for (double x = start; x > end; x -= 1e-3) { final double tst = FastMath.sinh(x); final double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; } public static double max(final double a, final double b){ if (a > b) { return a; } if (a < b) { return b; } if (a != b) { return Double.NaN; } long bits = Double.doubleToRawLongBits(a); if (bits == 0x8000000000000000L) { return b; } return a; }
@Test public void testMath905LargeNegative(){ final double start = -StrictMath.log(Double.MAX_VALUE); final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); final double end = -2 * StrictMath.log(endT); double maxErr = 0; for (double x = start; x > end; x -= 1e-3) { final double tst = FastMath.cosh(x); final double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; for (double x = start; x > end; x -= 1e-3) { final double tst = FastMath.sinh(x); final double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; } public static float ulp(float x){ if (Float.isInfinite(x)) { return Float.POSITIVE_INFINITY; } return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1)); }
@Test public void testMath905LargeNegative(){ final double start = -StrictMath.log(Double.MAX_VALUE); final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); final double end = -2 * StrictMath.log(endT); double maxErr = 0; for (double x = start; x > end; x -= 1e-3) { final double tst = FastMath.cosh(x); final double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; for (double x = start; x > end; x -= 1e-3) { final double tst = FastMath.sinh(x); final double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; } public static double sinh(double x){ boolean negate = false; if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x); } if (x < -20) { return -0.5 * exp(-x); } if (x == 0) { return x; } if (x < 0.0) { x = -x; negate = true; } double result; if (x > 0.25) { double hiPrec[] = new double[2]; exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; recipa = -recipa; recipb = -recipb; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; result = ya + yb; result *= 0.5; } else { double hiPrec[] = new double[2]; expm1(x, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double denom = 1.0 + ya; double denomr = 1.0 / denom; double denomb = -(denom - 1.0 - ya) + yb; double ratio = ya * denomr; double temp = ratio * HEX_40000000; double ra = ratio + temp - temp; double rb = ratio - ra; temp = denom * HEX_40000000; double za = denom + temp - temp; double zb = denom - za; rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr; rb += yb*denomr; rb += -ya * denomb * denomr * denomr; temp = ya + ra; yb += -(temp - ya - ra); ya = temp; temp = ya + rb; yb += -(temp - ya - rb); ya = temp; result = ya + yb; result *= 0.5; } if (negate) { result = -result; } return result; }
@Test public void testMath905LargeNegative(){ final double start = -StrictMath.log(Double.MAX_VALUE); final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE); final double end = -2 * StrictMath.log(endT); double maxErr = 0; for (double x = start; x > end; x -= 1e-3) { final double tst = FastMath.cosh(x); final double ref = Math.cosh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; for (double x = start; x > end; x -= 1e-3) { final double tst = FastMath.sinh(x); final double ref = Math.sinh(x); maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref)); } "<AssertPlaceHolder>"; } public static double cosh(double x){ if (x != x) { return x; } if (x > 20) { return 0.5 * exp(x); } if (x < -20) { return 0.5 * exp(-x); } final double hiPrec[] = new double[2]; if (x < 0.0) { x = -x; } exp(x, 0.0, hiPrec); double ya = hiPrec[0] + hiPrec[1]; double yb = -(ya - hiPrec[0] - hiPrec[1]); double temp = ya * HEX_40000000; double yaa = ya + temp - temp; double yab = ya - yaa; double recip = 1.0/ya; temp = recip * HEX_40000000; double recipa = recip + temp - temp; double recipb = recip - recipa; recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip; recipb += -yb * recip * recip; temp = ya + recipa; yb += -(temp - ya - recipa); ya = temp; temp = ya + recipb; yb += -(temp - ya - recipb); ya = temp; double result = ya + yb; result *= 0.5; return result; }
@Test public void testFitAccuracyDependsOnBoundary(){ final CMAESOptimizer optimizer = new CMAESOptimizer(); final MultivariateFunction fitnessFunction = new MultivariateFunction() { public double value(double[] parameters) { final double target = 11.1; final double error = target - parameters[0]; return error * error; } }; final double[] start = { 1 }; PointValuePair result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE, start); final double resNoBound = result.getPoint()[0]; final double[] lower = { -20 }; final double[] upper = { 5e16 }; result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE, start, lower, upper); final double resNearLo = result.getPoint()[0]; lower[0] = -5e16; upper[0] = 20; result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE, start, lower, upper); final double resNearHi = result.getPoint()[0]; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public PointVectorValuePair optimize(int maxEval, FUNC f, double[] t, double[] w, double[] startPoint){ return optimizeInternal(maxEval, f, t, w, startPoint); }
@Test public void testMath864(){ final CMAESOptimizer optimizer = new CMAESOptimizer(); final MultivariateFunction fitnessFunction = new MultivariateFunction() { @Override public double value(double[] parameters) { final double target = 1; final double error = target - parameters[0]; return error * error; } }; final double[] start = { 0 }; final double[] lower = { -1e6 }; final double[] upper = { 0.5 }; final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE, start, lower, upper).getPoint(); "<AssertPlaceHolder>"; } public PointVectorValuePair optimize(int maxEval, FUNC f, double[] t, double[] w, double[] startPoint){ return optimizeInternal(maxEval, f, t, w, startPoint); }
@Test public void testMath789(){ final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.009210099, 0.019107243} }); RealMatrix root1 = new RectangularCholeskyDecomposition(m1, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM1 = root1.multiply(root1.transpose()); "<AssertPlaceHolder>"; final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{ {0.0, 0.0, 0.0, 0.0, 0.0}, {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243} }); RealMatrix root2 = new RectangularCholeskyDecomposition(m2, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM2 = root2.multiply(root2.transpose()); "<AssertPlaceHolder>"; final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709}, {0.0, 0.0, 0.0, 0.0, 0.0}, {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243} }); RealMatrix root3 = new RectangularCholeskyDecomposition(m3, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM3 = root3.multiply(root3.transpose()); "<AssertPlaceHolder>"; } public RealVector subtract(RealVector v) throws DimensionMismatchException{ checkVectorDimensions(v); RealVector result = v.mapMultiply(-1d); Iterator<Entry> it = sparseIterator(); while (it.hasNext()) { final Entry e = it.next(); final int index = e.getIndex(); result.setEntry(index, e.getValue() + result.getEntry(index)); } return result; }
@Test public void testMath789(){ final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.009210099, 0.019107243} }); RealMatrix root1 = new RectangularCholeskyDecomposition(m1, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM1 = root1.multiply(root1.transpose()); "<AssertPlaceHolder>"; final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{ {0.0, 0.0, 0.0, 0.0, 0.0}, {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243} }); RealMatrix root2 = new RectangularCholeskyDecomposition(m2, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM2 = root2.multiply(root2.transpose()); "<AssertPlaceHolder>"; final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709}, {0.0, 0.0, 0.0, 0.0, 0.0}, {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243} }); RealMatrix root3 = new RectangularCholeskyDecomposition(m3, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM3 = root3.multiply(root3.transpose()); "<AssertPlaceHolder>"; } public double getNorm(){ double sum = 0; Iterator<Entry> it = sparseIterator(); while (it.hasNext()) { final Entry e = it.next(); final double value = e.getValue(); sum += value * value; } return FastMath.sqrt(sum); }
@Test public void testMath789(){ final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.009210099, 0.019107243} }); RealMatrix root1 = new RectangularCholeskyDecomposition(m1, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM1 = root1.multiply(root1.transpose()); "<AssertPlaceHolder>"; final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{ {0.0, 0.0, 0.0, 0.0, 0.0}, {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243} }); RealMatrix root2 = new RectangularCholeskyDecomposition(m2, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM2 = root2.multiply(root2.transpose()); "<AssertPlaceHolder>"; final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709}, {0.0, 0.0, 0.0, 0.0, 0.0}, {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243} }); RealMatrix root3 = new RectangularCholeskyDecomposition(m3, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM3 = root3.multiply(root3.transpose()); "<AssertPlaceHolder>"; } public RealMatrix multiply(final RealMatrix m){ MatrixUtils.checkMultiplicationCompatible(this, m); final int nRows = getRowDimension(); final int nCols = m.getColumnDimension(); final int nSum  = getColumnDimension(); final RealMatrix out = createMatrix(nRows, nCols); for (int row = 0; row < nRows; ++row) { for (int col = 0; col < nCols; ++col) { double sum = 0; for (int i = 0; i < nSum; ++i) { sum += getEntry(row, i) * m.getEntry(i, col); } out.setEntry(row, col, sum); } } return out; }
@Test public void testMath789(){ final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.009210099, 0.019107243} }); RealMatrix root1 = new RectangularCholeskyDecomposition(m1, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM1 = root1.multiply(root1.transpose()); "<AssertPlaceHolder>"; final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{ {0.0, 0.0, 0.0, 0.0, 0.0}, {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559}, {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709}, {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099}, {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243} }); RealMatrix root2 = new RectangularCholeskyDecomposition(m2, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM2 = root2.multiply(root2.transpose()); "<AssertPlaceHolder>"; final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{ {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559}, {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709}, {0.0, 0.0, 0.0, 0.0, 0.0}, {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099}, {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243} }); RealMatrix root3 = new RectangularCholeskyDecomposition(m3, 1.0e-10).getRootMatrix(); RealMatrix rebuiltM3 = root3.multiply(root3.transpose()); "<AssertPlaceHolder>"; } public RealMatrix transpose(){ final int nRows = getRowDimension(); final int nCols = getColumnDimension(); final RealMatrix out = createMatrix(nCols, nRows); walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() { @Override public void visit(final int row, final int column, final double value) { out.setEntry(column, row, value); } }); return out; }
@Test public void testFullRank(){ RealMatrix base = MatrixUtils.createRealMatrix(new double[][] { { 0.1159548705,      0.,           0.,           0.      }, { 0.0896442724, 0.1223540781,      0.,           0.      }, { 0.0852155322, 4.558668e-3,  0.1083577299,      0.      }, { 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 } }); RealMatrix m = base.multiply(base.transpose()); RectangularCholeskyDecomposition d = new RectangularCholeskyDecomposition(m, 1.0e-10); RealMatrix root = d.getRootMatrix(); RealMatrix rebuiltM = root.multiply(root.transpose()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public RealVector subtract(RealVector v) throws DimensionMismatchException{ checkVectorDimensions(v); RealVector result = v.mapMultiply(-1d); Iterator<Entry> it = sparseIterator(); while (it.hasNext()) { final Entry e = it.next(); final int index = e.getIndex(); result.setEntry(index, e.getValue() + result.getEntry(index)); } return result; }
@Test public void testFullRank(){ RealMatrix base = MatrixUtils.createRealMatrix(new double[][] { { 0.1159548705,      0.,           0.,           0.      }, { 0.0896442724, 0.1223540781,      0.,           0.      }, { 0.0852155322, 4.558668e-3,  0.1083577299,      0.      }, { 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 } }); RealMatrix m = base.multiply(base.transpose()); RectangularCholeskyDecomposition d = new RectangularCholeskyDecomposition(m, 1.0e-10); RealMatrix root = d.getRootMatrix(); RealMatrix rebuiltM = root.multiply(root.transpose()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getNorm(){ double sum = 0; Iterator<Entry> it = sparseIterator(); while (it.hasNext()) { final Entry e = it.next(); final double value = e.getValue(); sum += value * value; } return FastMath.sqrt(sum); }
@Test public void testFullRank(){ RealMatrix base = MatrixUtils.createRealMatrix(new double[][] { { 0.1159548705,      0.,           0.,           0.      }, { 0.0896442724, 0.1223540781,      0.,           0.      }, { 0.0852155322, 4.558668e-3,  0.1083577299,      0.      }, { 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 } }); RealMatrix m = base.multiply(base.transpose()); RectangularCholeskyDecomposition d = new RectangularCholeskyDecomposition(m, 1.0e-10); RealMatrix root = d.getRootMatrix(); RealMatrix rebuiltM = root.multiply(root.transpose()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public RealMatrix multiply(final RealMatrix m){ MatrixUtils.checkMultiplicationCompatible(this, m); final int nRows = getRowDimension(); final int nCols = m.getColumnDimension(); final int nSum  = getColumnDimension(); final RealMatrix out = createMatrix(nRows, nCols); for (int row = 0; row < nRows; ++row) { for (int col = 0; col < nCols; ++col) { double sum = 0; for (int i = 0; i < nSum; ++i) { sum += getEntry(row, i) * m.getEntry(i, col); } out.setEntry(row, col, sum); } } return out; }
@Test public void testFullRank(){ RealMatrix base = MatrixUtils.createRealMatrix(new double[][] { { 0.1159548705,      0.,           0.,           0.      }, { 0.0896442724, 0.1223540781,      0.,           0.      }, { 0.0852155322, 4.558668e-3,  0.1083577299,      0.      }, { 0.0905486674, 0.0213768077, 0.0128878333, 0.1014155693 } }); RealMatrix m = base.multiply(base.transpose()); RectangularCholeskyDecomposition d = new RectangularCholeskyDecomposition(m, 1.0e-10); RealMatrix root = d.getRootMatrix(); RealMatrix rebuiltM = root.multiply(root.transpose()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public RealMatrix transpose(){ final int nRows = getRowDimension(); final int nCols = getColumnDimension(); final RealMatrix out = createMatrix(nCols, nRows); walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() { @Override public void visit(final int row, final int column, final double value) { out.setEntry(column, row, value); } }); return out; }
@Test public void testKeepInitIfBest(){ final double minSin = 3 * Math.PI / 2; final double offset = 1e-8; final double delta = 1e-7; final UnivariateFunction f1 = new Sin(); final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset}, new double[] { 0, -1, 0 }); final UnivariateFunction f = FunctionUtils.add(f1, f2); final double relTol = 1e-8; final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100); final double init = minSin + 1.5 * offset; final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta, init); final int numEval = optimizer.getEvaluations(); final double sol = result.getPoint(); final double expected = init; "<AssertPlaceHolder>"; } public int getEvaluations(){ return evaluations.getCount(); }
@Test public void testKeepInitIfBest(){ final double minSin = 3 * Math.PI / 2; final double offset = 1e-8; final double delta = 1e-7; final UnivariateFunction f1 = new Sin(); final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset}, new double[] { 0, -1, 0 }); final UnivariateFunction f = FunctionUtils.add(f1, f2); final double relTol = 1e-8; final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100); final double init = minSin + 1.5 * offset; final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta, init); final int numEval = optimizer.getEvaluations(); final double sol = result.getPoint(); final double expected = init; "<AssertPlaceHolder>"; } public double getPoint(){ return point; }
@Test public void testMath855(){ final double minSin = 3 * Math.PI / 2; final double offset = 1e-8; final double delta = 1e-7; final UnivariateFunction f1 = new Sin(); final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset }, new double[] { 0, -1, 0 }); final UnivariateFunction f = FunctionUtils.add(f1, f2); final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100); final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta); final int numEval = optimizer.getEvaluations(); final double sol = result.getPoint(); final double expected = 4.712389027602411; "<AssertPlaceHolder>"; } public int getEvaluations(){ return evaluations.getCount(); }
@Test public void testMath855(){ final double minSin = 3 * Math.PI / 2; final double offset = 1e-8; final double delta = 1e-7; final UnivariateFunction f1 = new Sin(); final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset }, new double[] { 0, -1, 0 }); final UnivariateFunction f = FunctionUtils.add(f1, f2); final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100); final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta); final int numEval = optimizer.getEvaluations(); final double sol = result.getPoint(); final double expected = 4.712389027602411; "<AssertPlaceHolder>"; } public double getPoint(){ return point; }
@Test public void testMath835(){ final int numer = Integer.MAX_VALUE / 99; final int denom = 1; final double percentage = 100 * ((double) numer) / denom; final Fraction frac = new Fraction(numer, denom); "<AssertPlaceHolder>"; } public double percentageValue(){ return multiply(ONE_HUNDRED).doubleValue(); }
@Test public void testBigDataSet() throws Exception{ double[] d1 = new double[1500]; double[] d2 = new double[1500]; for (int i = 0; i < 1500; i++) { d1[i] = 2 * i; d2[i] = 2 * i + 1; } double result = testStatistic.mannWhitneyUTest(d1, d2); "<AssertPlaceHolder>"; } public double mannWhitneyUTest(final double[] x, final double[] y) throws NullArgumentException, NoDataException, ConvergenceException, MaxCountExceededException{ ensureDataConformance(x, y); final double Umax = mannWhitneyU(x, y); final double Umin = x.length * y.length - Umax; return calculateAsymptoticPValue(Umin, x.length, y.length); }
@Test public void testMath781(){ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 6, 7 }, 0); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 2, 1 }, Relationship.LEQ, 2)); constraints.add(new LinearConstraint(new double[] { -1, 1, 1 }, Relationship.LEQ, -1)); constraints.add(new LinearConstraint(new double[] { 2, -3, 1 }, Relationship.LEQ, -1)); double epsilon = 1e-6; SimplexSolver solver = new SimplexSolver(); PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public PointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException{ this.function          = f; this.linearConstraints = constraints; this.goal              = goalType; this.nonNegative       = restrictToNonNegative; iterations  = 0; return doOptimize(); }
@Test public void testFloatValueForLargeNumeratorAndDenominator(){ final BigInteger pow400 = BigInteger.TEN.pow(400); final BigInteger pow401 = BigInteger.TEN.pow(401); final BigInteger two = new BigInteger("2"); final BigFraction large = new BigFraction(pow401.add(BigInteger.ONE), pow400.multiply(two)); "<AssertPlaceHolder>"; } public float floatValue(){ float result = numerator.floatValue() / denominator.floatValue(); return result; }
@Test public void testDoubleValueForLargeNumeratorAndDenominator(){ final BigInteger pow400 = BigInteger.TEN.pow(400); final BigInteger pow401 = BigInteger.TEN.pow(401); final BigInteger two = new BigInteger("2"); final BigFraction large = new BigFraction(pow401.add(BigInteger.ONE), pow400.multiply(two)); "<AssertPlaceHolder>"; } public double doubleValue(){ double result = numerator.doubleValue() / denominator.doubleValue(); return result; }
@Test public void testTooLargeFirstStep(){ AdaptiveStepsizeIntegrator integ = new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN); final double start = 0.0; final double end   = 0.001; FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() { public int getDimension() { return 1; } public void computeDerivatives(double t, double[] y, double[] yDot) { "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; yDot[0] = -100.0 * y[0]; } }; integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8); integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]); } public static float nextAfter(final float f, final double direction){ if (Double.isNaN(f) || Double.isNaN(direction)) { return Float.NaN; } else if (f == direction) { return (float) direction; } else if (Float.isInfinite(f)) { return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE; } else if (f == 0f) { return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE; } final int bits = Float.floatToIntBits(f); final int sign = bits & 0x80000000; if ((direction < f) ^ (sign == 0)) { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1)); } else { return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1)); } }
@Test public void testMath713NegativeVariable(){ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 1.0}, 0.0d); ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.EQ, 1)); double epsilon = 1e-6; SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public RealPointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws MathIllegalStateException{ this.function          = f; this.linearConstraints = constraints; this.goal              = goalType; this.nonNegative       = restrictToNonNegative; iterations  = 0; return doOptimize(); }
@Test public void testOverrideMeanWithMathClass() throws Exception{ double[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setMeanImpl(new Mean()); for(double i : scores) { stats.addValue(i); } "<AssertPlaceHolder>"; } public double getMean(){ return apply(meanImpl); }
@Test public void testOverrideMeanWithMathClass() throws Exception{ double[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setMeanImpl(new Mean()); for(double i : scores) { stats.addValue(i); } "<AssertPlaceHolder>"; } public synchronized void setMeanImpl(UnivariateStatistic meanImpl){ this.meanImpl = meanImpl; }
@Test public void testOverrideGeoMeanWithMathClass() throws Exception{ double[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setGeoMeanImpl(new GeometricMean()); for(double i : scores) { stats.addValue(i); } "<AssertPlaceHolder>"; } public double getGeometricMean(){ return apply(geometricMeanImpl); }
@Test public void testOverrideGeoMeanWithMathClass() throws Exception{ double[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setGeoMeanImpl(new GeometricMean()); for(double i : scores) { stats.addValue(i); } "<AssertPlaceHolder>"; } public void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl){ setImpl(geoMeanImpl, this.geoMeanImpl); }
@Test public void testOverrideVarianceWithMathClass() throws Exception{ double[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setVarianceImpl(new Variance(false)); for(double i : scores) { stats.addValue(i); } "<AssertPlaceHolder>"; } public synchronized void setVarianceImpl( UnivariateStatistic varianceImpl){ this.varianceImpl = varianceImpl; }
@Test public void testOverrideVarianceWithMathClass() throws Exception{ double[] scores = {1, 2, 3, 4}; SummaryStatistics stats = new SummaryStatistics(); stats.setVarianceImpl(new Variance(false)); for(double i : scores) { stats.addValue(i); } "<AssertPlaceHolder>"; } public double getVariance(){ return apply(varianceImpl); }
@Test public void testIssue695(){ FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() { public int getDimension() { return 1; } public void computeDerivatives(double t, double[] y, double[] yDot) { yDot[0] = 1.0; } }; DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14); integrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000); integrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000); integrator.setInitialStepSize(3.0); double target = 30.0; double[] y = new double[1]; double tEnd = integrator.integrate(equation, 0.0, y, target, y); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathIllegalStateException, MathIllegalArgumentException{ if (y0.length != equations.getDimension()) { throw new DimensionMismatchException(y0.length, equations.getDimension()); } if (y.length != equations.getDimension()) { throw new DimensionMismatchException(y.length, equations.getDimension()); } final ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations); expandableODE.setTime(t0); expandableODE.setPrimaryState(y0); integrate(expandableODE, t); System.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length); return expandableODE.getTime(); }
@Test public void testAtanI(){ "<AssertPlaceHolder>"; } public Complex atan(){ if (isNaN) { return NaN; } return this.add(I).divide(I.subtract(this)).log() .multiply(I.divide(createComplex(2.0, 0.0))); }
@Test public void testDivideZero(){ Complex x = new Complex(3.0, 4.0); Complex z = x.divide(Complex.ZERO); "<AssertPlaceHolder>"; } public Complex divide(double divisor){ if (isNaN || Double.isNaN(divisor)) { return NaN; } if (divisor == 0d) { return isZero ? NaN : INF; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN; } return createComplex(real / divisor, imaginary  / divisor); }
@Test public void testAtanI(){ for (int i = -10; i < 10; i++) { System.out.println(new Complex(0, 1 - 0.1 * i).atan()); } "<AssertPlaceHolder>"; } public Complex atan(){ if (isNaN) { return NaN; } return this.add(I).divide(I.subtract(this)).log() .multiply(I.divide(createComplex(2.0, 0.0))); }
@Test public void testDivideZero(){ Complex x = new Complex(3.0, 4.0); Complex z = x.divide(Complex.ZERO); "<AssertPlaceHolder>"; } public Complex divide(double divisor){ if (isNaN || Double.isNaN(divisor)) { return NaN; } if (divisor == 0d) { return NaN; } if (Double.isInfinite(divisor)) { return !isInfinite() ? ZERO : NaN; } return createComplex(real / divisor, imaginary  / divisor); }
@Test public void testIssue639(){ Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0, -5774608829631843.0 /  268435456.0, -3822921525525679.0 / 4294967296.0); Vector3D u2 =new Vector3D( -5712344449280879.0 /    2097152.0, -2275058564560979.0 /    1048576.0, 4423475992255071.0 /      65536.0); Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getQ0(){ return q0; }
@Test public void testIssue639(){ Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0, -5774608829631843.0 /  268435456.0, -3822921525525679.0 / 4294967296.0); Vector3D u2 =new Vector3D( -5712344449280879.0 /    2097152.0, -2275058564560979.0 /    1048576.0, 4423475992255071.0 /      65536.0); Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getQ1(){ return q1; }
@Test public void testIssue639(){ Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0, -5774608829631843.0 /  268435456.0, -3822921525525679.0 / 4294967296.0); Vector3D u2 =new Vector3D( -5712344449280879.0 /    2097152.0, -2275058564560979.0 /    1048576.0, 4423475992255071.0 /      65536.0); Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getQ2(){ return q2; }
@Test public void testIssue639(){ Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0, -5774608829631843.0 /  268435456.0, -3822921525525679.0 / 4294967296.0); Vector3D u2 =new Vector3D( -5712344449280879.0 /    2097152.0, -2275058564560979.0 /    1048576.0, 4423475992255071.0 /      65536.0); Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getQ3(){ return q3; }
@Test public void testAddNaN(){ Complex x = new Complex(3.0, 4.0); Complex z = x.add(Complex.NaN); "<AssertPlaceHolder>"; z = new Complex(1, nan); Complex w = x.add(z); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Complex add(Complex rhs) throws NullArgumentException{ MathUtils.checkNotNull(rhs); return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }
@Test public void testIssue567(){ DfpField field = new DfpField(100); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Dfp getZero(){ return field.getZero(); }
@Test public void testIssue567(){ DfpField field = new DfpField(100); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Dfp newDfp(final byte sign, final byte nans){ return new Dfp(this, sign, nans); }
@Test public void testIssue567(){ DfpField field = new DfpField(100); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static float copySign(float magnitude, float sign){ int m = Float.floatToIntBits(magnitude); int s = Float.floatToIntBits(sign); if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { return magnitude; } return -magnitude; }
@Test public void testIterationConsistency(){ final MultidimensionalCounter c = new MultidimensionalCounter(2, 3, 4); final int[][] expected = new int[][] { { 0, 0, 0 }, { 0, 0, 1 }, { 0, 0, 2 }, { 0, 0, 3 }, { 0, 1, 0 }, { 0, 1, 1 }, { 0, 1, 2 }, { 0, 1, 3 }, { 0, 2, 0 }, { 0, 2, 1 }, { 0, 2, 2 }, { 0, 2, 3 }, { 1, 0, 0 }, { 1, 0, 1 }, { 1, 0, 2 }, { 1, 0, 3 }, { 1, 1, 0 }, { 1, 1, 1 }, { 1, 1, 2 }, { 1, 1, 3 }, { 1, 2, 0 }, { 1, 2, 1 }, { 1, 2, 2 }, { 1, 2, 3 } }; final int totalSize = c.getSize(); final int nDim = c.getDimension(); final MultidimensionalCounter.Iterator iter = c.iterator(); for (int i = 0; i < totalSize; i++) { if (!iter.hasNext()) { Assert.fail("Too short"); } final int uniDimIndex = iter.next(); "<AssertPlaceHolder>"; for (int dimIndex = 0; dimIndex < nDim; dimIndex++) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; final int[] indices = c.getCounts(uniDimIndex); for (int dimIndex = 0; dimIndex < nDim; dimIndex++) { "<AssertPlaceHolder>"; } } if (iter.hasNext()) { Assert.fail("Too long"); } } public int getCount(int ... c) throws OutOfRangeException{ if (c.length != dimension) { throw new DimensionMismatchException(c.length, dimension); } int count = 0; for (int i = 0; i < dimension; i++) { final int index = c[i]; if (index < 0 || index >= size[i]) { throw new OutOfRangeException(index, 0, size[i] - 1); } count += uniCounterOffset[i] * c[i]; } return count + c[last]; }
@Test public void testSmallDistances(){ int[] repeatedArray = { 0 }; int[] uniqueArray = { 1 }; CloseIntegerPoint repeatedPoint = new CloseIntegerPoint(new EuclideanIntegerPoint(repeatedArray)); CloseIntegerPoint uniquePoint = new CloseIntegerPoint(new EuclideanIntegerPoint(uniqueArray)); Collection<CloseIntegerPoint> points = new ArrayList<CloseIntegerPoint>(); final int NUM_REPEATED_POINTS = 10 * 1000; for (int i = 0; i < NUM_REPEATED_POINTS; ++i) { points.add(repeatedPoint); } points.add(uniquePoint); final long RANDOM_SEED = 0; final int NUM_CLUSTERS = 2; final int NUM_ITERATIONS = 0; KMeansPlusPlusClusterer<CloseIntegerPoint> clusterer = new KMeansPlusPlusClusterer<CloseIntegerPoint>(new Random(RANDOM_SEED)); List<Cluster<CloseIntegerPoint>> clusters = clusterer.cluster(points, NUM_CLUSTERS, NUM_ITERATIONS); boolean uniquePointIsCenter = false; for (Cluster<CloseIntegerPoint> cluster : clusters) { if (cluster.getCenter().equals(uniquePoint)) { uniquePointIsCenter = true; } } "<AssertPlaceHolder>"; } public T getCenter(){ return center; }
@Test public void testMinMaxFloat(){ float[][] pairs = { { -50.0f, 50.0f }, {  Float.POSITIVE_INFINITY, 1.0f }, {  Float.NEGATIVE_INFINITY, 1.0f }, {  Float.NaN, 1.0f }, {  Float.POSITIVE_INFINITY, 0.0f }, {  Float.NEGATIVE_INFINITY, 0.0f }, {  Float.NaN, 0.0f }, {  Float.NaN, Float.NEGATIVE_INFINITY }, {  Float.NaN, Float.POSITIVE_INFINITY } }; for (float[] pair : pairs) { "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } } public static double min(final double a, final double b){ return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b); }
@Test public void testMinMaxFloat(){ float[][] pairs = { { -50.0f, 50.0f }, {  Float.POSITIVE_INFINITY, 1.0f }, {  Float.NEGATIVE_INFINITY, 1.0f }, {  Float.NaN, 1.0f }, {  Float.POSITIVE_INFINITY, 0.0f }, {  Float.NEGATIVE_INFINITY, 0.0f }, {  Float.NaN, 0.0f }, {  Float.NaN, Float.NEGATIVE_INFINITY }, {  Float.NaN, Float.POSITIVE_INFINITY } }; for (float[] pair : pairs) { "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } } public static double max(final double a, final double b){ return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a); }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14); underlying.setMaxEvaluations(300); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); MultiStartUnivariateRealOptimizer optimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); UnivariateRealPointValuePair optimum = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; UnivariateRealPointValuePair[] optima = optimizer.getOptima(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return totalEvaluations; }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14); underlying.setMaxEvaluations(300); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); MultiStartUnivariateRealOptimizer optimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); UnivariateRealPointValuePair optimum = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; UnivariateRealPointValuePair[] optima = optimizer.getOptima(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getPoint(){ return point; }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14); underlying.setMaxEvaluations(300); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); MultiStartUnivariateRealOptimizer optimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); UnivariateRealPointValuePair optimum = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; UnivariateRealPointValuePair[] optima = optimizer.getOptima(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return value; }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14); underlying.setMaxEvaluations(300); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); MultiStartUnivariateRealOptimizer optimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); UnivariateRealPointValuePair optimum = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; UnivariateRealPointValuePair[] optima = optimizer.getOptima(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal, final double min, final double max, final double startValue) throws FunctionEvaluationException{ optima = new UnivariateRealPointValuePair[starts]; totalEvaluations = 0; for (int i = 0; i < starts; ++i) { try { final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min); final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min); optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2)); } catch (FunctionEvaluationException fee) { optima[i] = null; } catch (ConvergenceException ce) { optima[i] = null; } final int usedEvaluations = optimizer.getEvaluations(); optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations); totalEvaluations += usedEvaluations; } sortPairs(goal); if (optima[0] == null) { throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT, starts); } return optima[0]; }
@Test public void testArrayEquals(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static double nextAfter(double d, double direction){ if (Double.isNaN(d) || Double.isInfinite(d)) { return d; } else if (d == 0) { return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE; } long bits     = Double.doubleToLongBits(d); long sign     = bits & 0x8000000000000000L; long exponent = bits & 0x7ff0000000000000L; long mantissa = bits & 0x000fffffffffffffL; if (d * (direction - d) >= 0) { if (mantissa == 0x000fffffffffffffL) { return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L)); } else { return Double.longBitsToDouble(sign | exponent | (mantissa + 1)); } } else { if (mantissa == 0L) { return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL); } else { return Double.longBitsToDouble(sign | exponent | (mantissa - 1)); } } }
@Test public void testCircleFitting() throws FunctionEvaluationException, OptimizationException{ Circle circle = new Circle(); circle.addPoint( 30.0,  68.0); circle.addPoint( 50.0,  -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0,  15.0); circle.addPoint( 45.0,  97.0); LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); VectorialPointValuePair optimum = optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double rms = optimizer.getRMS(); "<AssertPlaceHolder>"; Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[][] cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double  r = circle.getRadius(center); for (double d= 0; d < 2 * Math.PI; d += 0.01) { circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d)); } double[] target = new double[circle.getN()]; Arrays.fill(target, 0.0); double[] weights = new double[circle.getN()]; Arrays.fill(weights, 2.0); optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 }); cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public void addPoint(final T point){ points.add(point); }
@Test public void testCircleFitting() throws FunctionEvaluationException, OptimizationException{ Circle circle = new Circle(); circle.addPoint( 30.0,  68.0); circle.addPoint( 50.0,  -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0,  15.0); circle.addPoint( 45.0,  97.0); LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); VectorialPointValuePair optimum = optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double rms = optimizer.getRMS(); "<AssertPlaceHolder>"; Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[][] cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double  r = circle.getRadius(center); for (double d= 0; d < 2 * Math.PI; d += 0.01) { circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d)); } double[] target = new double[circle.getN()]; Arrays.fill(target, 0.0); double[] weights = new double[circle.getN()]; Arrays.fill(weights, 2.0); optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 }); cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws FunctionEvaluationException, OptimizationException, IllegalArgumentException{ if (target.length != weights.length) { throw new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length); } iterations           = 0; objectiveEvaluations = 0; jacobianEvaluations  = 0; function         = f; jF               = f.jacobian(); targetValues     = target.clone(); residualsWeights = weights.clone(); this.point       = startPoint.clone(); this.residuals   = new double[target.length]; rows      = target.length; cols      = point.length; jacobian  = new double[rows][cols]; cost = Double.POSITIVE_INFINITY; return doOptimize(); }
@Test public void testCircleFitting() throws FunctionEvaluationException, OptimizationException{ Circle circle = new Circle(); circle.addPoint( 30.0,  68.0); circle.addPoint( 50.0,  -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0,  15.0); circle.addPoint( 45.0,  97.0); LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); VectorialPointValuePair optimum = optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double rms = optimizer.getRMS(); "<AssertPlaceHolder>"; Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[][] cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double  r = circle.getRadius(center); for (double d= 0; d < 2 * Math.PI; d += 0.01) { circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d)); } double[] target = new double[circle.getN()]; Arrays.fill(target, 0.0); double[] weights = new double[circle.getN()]; Arrays.fill(weights, 2.0); optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 }); cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return objectiveEvaluations; }
@Test public void testCircleFitting() throws FunctionEvaluationException, OptimizationException{ Circle circle = new Circle(); circle.addPoint( 30.0,  68.0); circle.addPoint( 50.0,  -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0,  15.0); circle.addPoint( 45.0,  97.0); LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); VectorialPointValuePair optimum = optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double rms = optimizer.getRMS(); "<AssertPlaceHolder>"; Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[][] cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double  r = circle.getRadius(center); for (double d= 0; d < 2 * Math.PI; d += 0.01) { circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d)); } double[] target = new double[circle.getN()]; Arrays.fill(target, 0.0); double[] weights = new double[circle.getN()]; Arrays.fill(weights, 2.0); optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 }); cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getJacobianEvaluations(){ return jacobianEvaluations; }
@Test public void testCircleFitting() throws FunctionEvaluationException, OptimizationException{ Circle circle = new Circle(); circle.addPoint( 30.0,  68.0); circle.addPoint( 50.0,  -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0,  15.0); circle.addPoint( 45.0,  97.0); LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); VectorialPointValuePair optimum = optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double rms = optimizer.getRMS(); "<AssertPlaceHolder>"; Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[][] cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double  r = circle.getRadius(center); for (double d= 0; d < 2 * Math.PI; d += 0.01) { circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d)); } double[] target = new double[circle.getN()]; Arrays.fill(target, 0.0); double[] weights = new double[circle.getN()]; Arrays.fill(weights, 2.0); optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 }); cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getRMS(){ double criterion = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; criterion += residual * residual * residualsWeights[i]; } return Math.sqrt(criterion / rows); }
@Test public void testCircleFitting() throws FunctionEvaluationException, OptimizationException{ Circle circle = new Circle(); circle.addPoint( 30.0,  68.0); circle.addPoint( 50.0,  -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0,  15.0); circle.addPoint( 45.0,  97.0); LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); VectorialPointValuePair optimum = optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double rms = optimizer.getRMS(); "<AssertPlaceHolder>"; Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[][] cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double  r = circle.getRadius(center); for (double d= 0; d < 2 * Math.PI; d += 0.01) { circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d)); } double[] target = new double[circle.getN()]; Arrays.fill(target, 0.0); double[] weights = new double[circle.getN()]; Arrays.fill(weights, 2.0); optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 }); cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getN(){ return n; }
@Test public void testCircleFitting() throws FunctionEvaluationException, OptimizationException{ Circle circle = new Circle(); circle.addPoint( 30.0,  68.0); circle.addPoint( 50.0,  -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0,  15.0); circle.addPoint( 45.0,  97.0); LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); VectorialPointValuePair optimum = optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double rms = optimizer.getRMS(); "<AssertPlaceHolder>"; Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[][] cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double  r = circle.getRadius(center); for (double d= 0; d < 2 * Math.PI; d += 0.01) { circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d)); } double[] target = new double[circle.getN()]; Arrays.fill(target, 0.0); double[] weights = new double[circle.getN()]; Arrays.fill(weights, 2.0); optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 }); cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double[][] getCovariances() throws FunctionEvaluationException, OptimizationException{ updateJacobian(); double[][] jTj = new double[cols][cols]; for (int i = 0; i < cols; ++i) { for (int j = i; j < cols; ++j) { double sum = 0; for (int k = 0; k < rows; ++k) { sum += jacobian[k][i] * jacobian[k][j]; } jTj[i][j] = sum; jTj[j][i] = sum; } } try { RealMatrix inverse = new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse(); return inverse.getData(); } catch (InvalidMatrixException ime) { throw new OptimizationException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM); } }
@Test public void testCircleFitting() throws FunctionEvaluationException, OptimizationException{ Circle circle = new Circle(); circle.addPoint( 30.0,  68.0); circle.addPoint( 50.0,  -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0,  15.0); circle.addPoint( 45.0,  97.0); LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer(); VectorialPointValuePair optimum = optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 }, new double[] { 98.680, 47.345 }); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double rms = optimizer.getRMS(); "<AssertPlaceHolder>"; Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[][] cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double  r = circle.getRadius(center); for (double d= 0; d < 2 * Math.PI; d += 0.01) { circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d)); } double[] target = new double[circle.getN()]; Arrays.fill(target, 0.0); double[] weights = new double[circle.getN()]; Arrays.fill(weights, 2.0); optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 }); cov = optimizer.getCovariances(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; errors = optimizer.guessParametersErrors(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double[] guessParametersErrors() throws FunctionEvaluationException, OptimizationException{ if (rows <= cols) { throw new OptimizationException( LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols); } double[] errors = new double[cols]; final double c = Math.sqrt(getChiSquare() / (rows - cols)); double[][] covar = getCovariances(); for (int i = 0; i < errors.length; ++i) { errors[i] = Math.sqrt(covar[i][i]) * c; } return errors; }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); underlying.setRelativeAccuracy(1e-15); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy()); minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy()); try { minimizer.getOptima(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } try { minimizer.getOptimaValues(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } double result = minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws ConvergenceException, FunctionEvaluationException{ return optimize(f, goalType, min, max); }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); underlying.setRelativeAccuracy(1e-15); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy()); minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy()); try { minimizer.getOptima(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } try { minimizer.getOptimaValues(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } double result = minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double[] getOptima() throws IllegalStateException{ if (optima == null) { throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET); } return optima.clone(); }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); underlying.setRelativeAccuracy(1e-15); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053L); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy()); minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy()); try { minimizer.getOptima(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } try { minimizer.getOptimaValues(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } double result = minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double[] getOptimaValues() throws IllegalStateException{ if (optimaValues == null) { throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET); } return optimaValues.clone(); }
@Test public void testSinMin() throws MathException{ UnivariateRealFunction f = new SinFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(44428400075l); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 10, g); minimizer.optimize(f, GoalType.MINIMIZE, -100.0, 100.0); double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 1; i < optima.length; ++i) { double d = (optima[i] - optima[i-1]) / (2 * Math.PI); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double[] getOptimaValues() throws IllegalStateException{ if (optimaValues == null) { throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET); } return optimaValues.clone(); }
@Test public void testSinMin() throws MathException{ UnivariateRealFunction f = new SinFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(44428400075l); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 10, g); minimizer.optimize(f, GoalType.MINIMIZE, -100.0, 100.0); double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 1; i < optima.length; ++i) { double d = (optima[i] - optima[i-1]) / (2 * Math.PI); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double[] getOptima() throws IllegalStateException{ if (optima == null) { throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET); } return optima.clone(); }
@Test public void testSinMin() throws MathException{ UnivariateRealFunction f = new SinFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(44428400075l); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 10, g); minimizer.optimize(f, GoalType.MINIMIZE, -100.0, 100.0); double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 1; i < optima.length; ++i) { double d = (optima[i] - optima[i-1]) / (2 * Math.PI); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws ConvergenceException, FunctionEvaluationException{ return optimize(f, goalType, min, max); }
@Test public void testQuinticMinStatistics() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer minimizer = new BrentOptimizer(); minimizer.setRelativeAccuracy(1e-10); minimizer.setAbsoluteAccuracy(1e-11); final DescriptiveStatistics[] stat = new DescriptiveStatistics[3]; for (int i = 0; i < stat.length; i++) { stat[i] = new DescriptiveStatistics(); } final double min = -0.75; final double max = 0.25; final int nSamples = 200; final double delta = (max - min) / nSamples; for (int i = 0; i < nSamples; i++) { final double start = min + i * delta; stat[0].addValue(minimizer.optimize(f, GoalType.MINIMIZE, min, max, start)); stat[1].addValue(minimizer.getIterationCount()); stat[2].addValue(minimizer.getEvaluations()); } final double meanOptValue = stat[0].getMean(); final double medianIter = stat[1].getPercentile(50); final double medianEval = stat[2].getPercentile(50); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getMean(){ return apply(meanImpl); }
@Test public void testQuinticMinStatistics() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer minimizer = new BrentOptimizer(); minimizer.setRelativeAccuracy(1e-10); minimizer.setAbsoluteAccuracy(1e-11); final DescriptiveStatistics[] stat = new DescriptiveStatistics[3]; for (int i = 0; i < stat.length; i++) { stat[i] = new DescriptiveStatistics(); } final double min = -0.75; final double max = 0.25; final int nSamples = 200; final double delta = (max - min) / nSamples; for (int i = 0; i < nSamples; i++) { final double start = min + i * delta; stat[0].addValue(minimizer.optimize(f, GoalType.MINIMIZE, min, max, start)); stat[1].addValue(minimizer.getIterationCount()); stat[2].addValue(minimizer.getEvaluations()); } final double meanOptValue = stat[0].getMean(); final double medianIter = stat[1].getPercentile(50); final double medianEval = stat[2].getPercentile(50); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getPercentile(double p){ if (percentileImpl instanceof Percentile) { ((Percentile) percentileImpl).setQuantile(p); } else { try { percentileImpl.getClass().getMethod(SET_QUANTILE_METHOD_NAME, new Class[] {Double.TYPE}).invoke(percentileImpl, new Object[] {Double.valueOf(p)}); } catch (NoSuchMethodException e1) { throw MathRuntimeException.createIllegalArgumentException( LocalizedFormats.PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD, percentileImpl.getClass().getName(), SET_QUANTILE_METHOD_NAME); } catch (IllegalAccessException e2) { throw MathRuntimeException.createIllegalArgumentException( LocalizedFormats.PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD, SET_QUANTILE_METHOD_NAME, percentileImpl.getClass().getName()); } catch (InvocationTargetException e3) { throw MathRuntimeException.createIllegalArgumentException(e3.getCause()); } } return apply(percentileImpl); }
@Test public void testQuinticMinStatistics() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer minimizer = new BrentOptimizer(); minimizer.setRelativeAccuracy(1e-10); minimizer.setAbsoluteAccuracy(1e-11); final DescriptiveStatistics[] stat = new DescriptiveStatistics[3]; for (int i = 0; i < stat.length; i++) { stat[i] = new DescriptiveStatistics(); } final double min = -0.75; final double max = 0.25; final int nSamples = 200; final double delta = (max - min) / nSamples; for (int i = 0; i < nSamples; i++) { final double start = min + i * delta; stat[0].addValue(minimizer.optimize(f, GoalType.MINIMIZE, min, max, start)); stat[1].addValue(minimizer.getIterationCount()); stat[2].addValue(minimizer.getEvaluations()); } final double meanOptValue = stat[0].getMean(); final double medianIter = stat[1].getPercentile(50); final double medianEval = stat[2].getPercentile(50); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double optimize(UnivariateRealFunction f, GoalType goal, double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException{ return optimize(f, goal, min, max, min + 0.5 * (max - min)); }
@Test public void testSinMin() throws MathException{ UnivariateRealFunction f = new SinFunction(); UnivariateRealOptimizer minimizer = new BrentOptimizer(); minimizer.setMaxEvaluations(200); "<AssertPlaceHolder>"; try { minimizer.getResult(); fail("an exception should have been thrown"); } catch (NoDataException ise) { } catch (Exception e) { fail("wrong exception caught"); } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; minimizer.setMaxEvaluations(10); try { minimizer.optimize(f, GoalType.MINIMIZE, 4, 5); fail("an exception should have been thrown"); } catch (FunctionEvaluationException fee) { } catch (Exception e) { fail("wrong exception caught"); } } public double optimize(UnivariateRealFunction f, GoalType goal, double min, double max) throws MaxIterationsExceededException, FunctionEvaluationException{ return optimize(f, goal, min, max, min + 0.5 * (max - min)); }
@Test public void testSinMin() throws MathException{ UnivariateRealFunction f = new SinFunction(); UnivariateRealOptimizer minimizer = new BrentOptimizer(); minimizer.setMaxEvaluations(200); "<AssertPlaceHolder>"; try { minimizer.getResult(); fail("an exception should have been thrown"); } catch (NoDataException ise) { } catch (Exception e) { fail("wrong exception caught"); } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; minimizer.setMaxEvaluations(10); try { minimizer.optimize(f, GoalType.MINIMIZE, 4, 5); fail("an exception should have been thrown"); } catch (FunctionEvaluationException fee) { } catch (Exception e) { fail("wrong exception caught"); } } public int getIterationCount(){ return iterationCount; }
@Test public void testSinMin() throws MathException{ UnivariateRealFunction f = new SinFunction(); UnivariateRealOptimizer minimizer = new BrentOptimizer(); minimizer.setMaxEvaluations(200); "<AssertPlaceHolder>"; try { minimizer.getResult(); fail("an exception should have been thrown"); } catch (NoDataException ise) { } catch (Exception e) { fail("wrong exception caught"); } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; minimizer.setMaxEvaluations(10); try { minimizer.optimize(f, GoalType.MINIMIZE, 4, 5); fail("an exception should have been thrown"); } catch (FunctionEvaluationException fee) { } catch (Exception e) { fail("wrong exception caught"); } } public int getEvaluations(){ return evaluations; }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053l); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy()); minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy()); try { minimizer.getOptima(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } try { minimizer.getOptimaValues(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws ConvergenceException, FunctionEvaluationException{ return optimize(f, goalType, min, max); }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053l); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy()); minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy()); try { minimizer.getOptima(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } try { minimizer.getOptimaValues(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getResult(){ return optimizer.getResult(); }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053l); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy()); minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy()); try { minimizer.getOptima(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } try { minimizer.getOptimaValues(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getFunctionValue(){ return optimizer.getFunctionValue(); }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053l); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy()); minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy()); try { minimizer.getOptima(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } try { minimizer.getOptimaValues(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double value(final double[] point) throws FunctionEvaluationException{ final double[] residuals = function.value(point); if (residuals.length != observations.length) { throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, residuals.length, observations.length); } for (int i = 0; i < residuals.length; ++i) { residuals[i] -= observations[i]; } double sumSquares = 0; if (weights != null) { for (int i = 0; i < residuals.length; ++i) { final double ri = residuals[i]; sumSquares +=  weights[i] * ri * ri; } } else if (scale != null) { for (final double yi : scale.operate(residuals)) { sumSquares += yi * yi; } } else { for (final double ri : residuals) { sumSquares += ri * ri; } } return sumSquares; }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053l); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy()); minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy()); try { minimizer.getOptima(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } try { minimizer.getOptimaValues(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getEvaluations(){ return totalEvaluations; }
@Test public void testQuinticMin() throws MathException{ UnivariateRealFunction f = new QuinticFunction(); UnivariateRealOptimizer underlying = new BrentOptimizer(); JDKRandomGenerator g = new JDKRandomGenerator(); g.setSeed(4312000053l); MultiStartUnivariateRealOptimizer minimizer = new MultiStartUnivariateRealOptimizer(underlying, 5, g); minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy()); minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy()); try { minimizer.getOptima(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } try { minimizer.getOptimaValues(); fail("an exception should have been thrown"); } catch (IllegalStateException ise) { } catch (Exception e) { fail("wrong exception caught"); } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; double[] optima = minimizer.getOptima(); double[] optimaValues = minimizer.getOptimaValues(); for (int i = 0; i < optima.length; ++i) { "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getIterationCount(){ return totalIterations; }
@Test public void testPValueNearZero() throws Exception{ int dimension = 120; double[][] data = new double[dimension][2]; for (int i = 0; i < dimension; i++) { data[i][0] = i; data[i][1] = i + 1/((double)i + 1); } PearsonsCorrelation corrInstance = new PearsonsCorrelation(data); "<AssertPlaceHolder>"; } public RealMatrix getCorrelationPValues() throws MathException{ TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); } } } return new BlockRealMatrix(out); }
@Test public void testPValueNearZero() throws Exception{ int dimension = 120; double[][] data = new double[dimension][2]; for (int i = 0; i < dimension; i++) { data[i][0] = i; data[i][1] = i + 1/((double)i + 1); } PearsonsCorrelation corrInstance = new PearsonsCorrelation(data); "<AssertPlaceHolder>"; } public double getEntry(final int row, final int column) throws MatrixIndexException{ try { return data[row][column]; } catch (ArrayIndexOutOfBoundsException e) { throw new MatrixIndexException( "no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension()); } }
@Test public void testRootEndpoints() throws Exception{ UnivariateRealFunction f = new SinFunction(); UnivariateRealSolver solver = new BrentSolver(); double result = solver.solve(f, Math.PI, 4); "<AssertPlaceHolder>"; result = solver.solve(f, 3, Math.PI); "<AssertPlaceHolder>"; result = solver.solve(f, Math.PI, 4, 3.5); "<AssertPlaceHolder>"; result = solver.solve(f, 3, Math.PI, 3.07); "<AssertPlaceHolder>"; } public static double solve(UnivariateRealFunction f, double x0, double x1, double absoluteAccuracy) throws ConvergenceException, FunctionEvaluationException{ setup(f); UnivariateRealSolver solver = LazyHolder.FACTORY.newDefaultSolver(); solver.setAbsoluteAccuracy(absoluteAccuracy); return solver.solve(f, x0, x1); }
@Test public void testRootEndpoints() throws Exception{ UnivariateRealFunction f = new SinFunction(); UnivariateRealSolver solver = new BrentSolver(); double result = solver.solve(f, Math.PI, 4); "<AssertPlaceHolder>"; result = solver.solve(f, 3, Math.PI); "<AssertPlaceHolder>"; result = solver.solve(f, Math.PI, 4, 3.5); "<AssertPlaceHolder>"; result = solver.solve(f, 3, Math.PI, 3.07); "<AssertPlaceHolder>"; } public double getAbsoluteAccuracy(){ return absoluteAccuracy; }
@Test public void polynomial() throws DerivativeException, IntegratorException{ TestProblem6 pb = new TestProblem6(); double range = Math.abs(pb.getFinalTime() - pb.getInitialTime()); for (int nSteps = 1; nSteps < 7; ++nSteps) { AdamsMoultonIntegrator integ = new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (nSteps < 4) { "<AssertPlaceHolder>"; } else { "<AssertPlaceHolder>"; } } } public int getEvaluations(){ return evaluations; }
@Test public void testPcts(){ f.addValue(oneL); f.addValue(twoL); f.addValue(oneI); f.addValue(twoI); f.addValue(threeL); f.addValue(threeL); f.addValue(3); f.addValue(threeI); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getPct(char v){ return getPct(Character.valueOf(v)); }
@Test public void testMath320A(){ RealMatrix rm = new Array2DRowRealMatrix(new double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 } }); double s439  = Math.sqrt(439.0); double[] reference = new double[] { Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439)) }; SingularValueDecomposition svd = new SingularValueDecompositionImpl(rm); double[] singularValues = svd.getSingularValues(); "<AssertPlaceHolder>"; for (int i = 0; i < reference.length; ++i) { "<AssertPlaceHolder>"; } RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT()); "<AssertPlaceHolder>"; double[] b = new double[] { 5.0, 6.0, 7.0 }; double[] resSVD = svd.getSolver().solve(b); "<AssertPlaceHolder>"; double svdMinResidual = residual(rm, resSVD, b); double epsilon = 2 * Math.ulp(svdMinResidual); double h = 0.1; int    k = 3; for (double d0 = -k * h; d0 <= k * h; d0 += h) { for (double d1 = -k * h ; d1 <= k * h; d1 += h) { for (double d2 = -k * h; d2 <= k * h; d2 += h) { double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 }; "<AssertPlaceHolder>"; } } } } public double[] getSingularValues() throws InvalidMatrixException{ return singularValues.clone(); }
@Test public void testMath320A(){ RealMatrix rm = new Array2DRowRealMatrix(new double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 } }); double s439  = Math.sqrt(439.0); double[] reference = new double[] { Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439)) }; SingularValueDecomposition svd = new SingularValueDecompositionImpl(rm); double[] singularValues = svd.getSingularValues(); "<AssertPlaceHolder>"; for (int i = 0; i < reference.length; ++i) { "<AssertPlaceHolder>"; } RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT()); "<AssertPlaceHolder>"; double[] b = new double[] { 5.0, 6.0, 7.0 }; double[] resSVD = svd.getSolver().solve(b); "<AssertPlaceHolder>"; double svdMinResidual = residual(rm, resSVD, b); double epsilon = 2 * Math.ulp(svdMinResidual); double h = 0.1; int    k = 3; for (double d0 = -k * h; d0 <= k * h; d0 += h) { for (double d1 = -k * h ; d1 <= k * h; d1 += h) { for (double d2 = -k * h; d2 <= k * h; d2 += h) { double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 }; "<AssertPlaceHolder>"; } } } } public RealMatrixImpl multiply(final RealMatrixImpl m) throws IllegalArgumentException{ MatrixUtils.checkMultiplicationCompatible(this, m); final int nRows = this.getRowDimension(); final int nCols = m.getColumnDimension(); final int nSum = this.getColumnDimension(); final double[][] outData = new double[nRows][nCols]; for (int row = 0; row < nRows; row++) { final double[] dataRow    = data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < nCols; col++) { double sum = 0; for (int i = 0; i < nSum; i++) { sum += dataRow[i] * m.data[i][col]; } outDataRow[col] = sum; } } return new RealMatrixImpl(outData, false); }
@Test public void testMath320A(){ RealMatrix rm = new Array2DRowRealMatrix(new double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 } }); double s439  = Math.sqrt(439.0); double[] reference = new double[] { Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439)) }; SingularValueDecomposition svd = new SingularValueDecompositionImpl(rm); double[] singularValues = svd.getSingularValues(); "<AssertPlaceHolder>"; for (int i = 0; i < reference.length; ++i) { "<AssertPlaceHolder>"; } RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT()); "<AssertPlaceHolder>"; double[] b = new double[] { 5.0, 6.0, 7.0 }; double[] resSVD = svd.getSolver().solve(b); "<AssertPlaceHolder>"; double svdMinResidual = residual(rm, resSVD, b); double epsilon = 2 * Math.ulp(svdMinResidual); double h = 0.1; int    k = 3; for (double d0 = -k * h; d0 <= k * h; d0 += h) { for (double d1 = -k * h ; d1 <= k * h; d1 += h) { for (double d2 = -k * h; d2 <= k * h; d2 += h) { double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 }; "<AssertPlaceHolder>"; } } } } public RealMatrixImpl subtract(final RealMatrixImpl m) throws IllegalArgumentException{ MatrixUtils.checkSubtractionCompatible(this, m); final int rowCount    = getRowDimension(); final int columnCount = getColumnDimension(); final double[][] outData = new double[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final double[] dataRow    = data[row]; final double[] mRow       = m.data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col] - mRow[col]; } } return new RealMatrixImpl(outData, false); }
@Test public void testMath320A(){ RealMatrix rm = new Array2DRowRealMatrix(new double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 } }); double s439  = Math.sqrt(439.0); double[] reference = new double[] { Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439)) }; SingularValueDecomposition svd = new SingularValueDecompositionImpl(rm); double[] singularValues = svd.getSingularValues(); "<AssertPlaceHolder>"; for (int i = 0; i < reference.length; ++i) { "<AssertPlaceHolder>"; } RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT()); "<AssertPlaceHolder>"; double[] b = new double[] { 5.0, 6.0, 7.0 }; double[] resSVD = svd.getSolver().solve(b); "<AssertPlaceHolder>"; double svdMinResidual = residual(rm, resSVD, b); double epsilon = 2 * Math.ulp(svdMinResidual); double h = 0.1; int    k = 3; for (double d0 = -k * h; d0 <= k * h; d0 += h) { for (double d1 = -k * h ; d1 <= k * h; d1 += h) { for (double d2 = -k * h; d2 <= k * h; d2 += h) { double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 }; "<AssertPlaceHolder>"; } } } } public int getColumnDimension(){ return ((data == null) || (data[0] == null)) ? 0 : data[0].length; }
@Test public void testMath320B(){ RealMatrix rm = new Array2DRowRealMatrix(new double[][] { { 1.0, 2.0 }, { 1.0, 2.0 } }); SingularValueDecomposition svd = new SingularValueDecompositionImpl(rm); RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT()); "<AssertPlaceHolder>"; } public RealMatrixImpl subtract(final RealMatrixImpl m) throws IllegalArgumentException{ MatrixUtils.checkSubtractionCompatible(this, m); final int rowCount    = getRowDimension(); final int columnCount = getColumnDimension(); final double[][] outData = new double[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final double[] dataRow    = data[row]; final double[] mRow       = m.data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col] - mRow[col]; } } return new RealMatrixImpl(outData, false); }
@Test public void testMath320B(){ RealMatrix rm = new Array2DRowRealMatrix(new double[][] { { 1.0, 2.0 }, { 1.0, 2.0 } }); SingularValueDecomposition svd = new SingularValueDecompositionImpl(rm); RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT()); "<AssertPlaceHolder>"; } public double getNorm(){ return walkInColumnOrder(new RealMatrixPreservingVisitor() { private double endRow; private double columnSum; private double maxColSum; public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) { this.endRow = endRow; columnSum   = 0; maxColSum   = 0; } public void visit(final int row, final int column, final double value) { columnSum += Math.abs(value); if (row == endRow) { maxColSum = Math.max(maxColSum, columnSum); columnSum = 0; } } public double end() { return maxColSum; } }); }
@Test public void testMath320B(){ RealMatrix rm = new Array2DRowRealMatrix(new double[][] { { 1.0, 2.0 }, { 1.0, 2.0 } }); SingularValueDecomposition svd = new SingularValueDecompositionImpl(rm); RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT()); "<AssertPlaceHolder>"; } public RealMatrixImpl multiply(final RealMatrixImpl m) throws IllegalArgumentException{ MatrixUtils.checkMultiplicationCompatible(this, m); final int nRows = this.getRowDimension(); final int nCols = m.getColumnDimension(); final int nSum = this.getColumnDimension(); final double[][] outData = new double[nRows][nCols]; for (int row = 0; row < nRows; row++) { final double[] dataRow    = data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < nCols; col++) { double sum = 0; for (int i = 0; i < nSum; i++) { sum += dataRow[i] * m.data[i][col]; } outDataRow[col] = sum; } } return new RealMatrixImpl(outData, false); }
@Test public void testMath288() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true); "<AssertPlaceHolder>"; } public RealPointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws OptimizationException{ this.f                     = f; this.constraints           = constraints; this.goalType              = goalType; this.restrictToNonNegative = restrictToNonNegative; iterations  = 0; return doOptimize(); }
@Test public void testMath288() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true); "<AssertPlaceHolder>"; } public RealMatrixImpl add(final RealMatrixImpl m) throws IllegalArgumentException{ MatrixUtils.checkAdditionCompatible(this, m); final int rowCount    = getRowDimension(); final int columnCount = getColumnDimension(); final double[][] outData = new double[rowCount][columnCount]; for (int row = 0; row < rowCount; row++) { final double[] dataRow    = data[row]; final double[] mRow       = m.data[row]; final double[] outDataRow = outData[row]; for (int col = 0; col < columnCount; col++) { outDataRow[col] = dataRow[col] + mRow[col]; } } return new RealMatrixImpl(outData, false); }
@Test public void testMath288() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0)); constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true); "<AssertPlaceHolder>"; } public double getValue(){ return value; }
@Test public void testMath286() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.2, 0.3 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 23.0)); RealPointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MAXIMIZE, true); "<AssertPlaceHolder>"; } public double getValue(){ return value; }
@Test public void testMath286() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.2, 0.3 }, 0 ); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 23.0)); RealPointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MAXIMIZE, true); "<AssertPlaceHolder>"; } public RealPointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws OptimizationException{ this.f                     = f; this.constraints           = constraints; this.goalType              = goalType; this.restrictToNonNegative = restrictToNonNegative; iterations  = 0; return doOptimize(); }
@Test public void testSingleVariableAndConstraint() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public RealPointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws OptimizationException{ this.f                     = f; this.constraints           = constraints; this.goalType              = goalType; this.restrictToNonNegative = restrictToNonNegative; iterations = 0; return doOptimize(); }
@Test public void testSingleVariableAndConstraint() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int[] getPoint(){ return point; }
@Test public void testSingleVariableAndConstraint() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return value; }
@Test public void testMath272() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1)); constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public RealPointValuePair optimize(final LinearObjectiveFunction f, final Collection<LinearConstraint> constraints, final GoalType goalType, final boolean restrictToNonNegative) throws OptimizationException{ this.f                     = f; this.constraints           = constraints; this.goalType              = goalType; this.restrictToNonNegative = restrictToNonNegative; iterations = 0; return doOptimize(); }
@Test public void testMath272() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1)); constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int[] getPoint(){ return point; }
@Test public void testMath272() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1)); constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double getValue(){ return value; }
@Test public void testMath272() throws OptimizationException{ LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0); Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>(); constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1)); constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1)); constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1)); SimplexSolver solver = new SimplexSolver(); RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public DenseFieldMatrix<T> add(final DenseFieldMatrix<T> m) throws IllegalArgumentException{ checkAdditionCompatible(m); final DenseFieldMatrix<T> out = new DenseFieldMatrix<T>(getField(), rows, columns); for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) { final T[] outBlock = out.blocks[blockIndex]; final T[] tBlock   = blocks[blockIndex]; final T[] mBlock   = m.blocks[blockIndex]; for (int k = 0; k < outBlock.length; ++k) { outBlock[k] = tBlock[k].add(mBlock[k]); } } return out; }
@Test public void testCompareTo(){ Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); Fraction third = new Fraction(1, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Fraction pi1 = new Fraction(1068966896, 340262731); Fraction pi2 = new Fraction( 411557987, 131002976); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int compareTo(final BigFraction object){ BigInteger nOd = numerator.multiply(object.denominator); BigInteger dOn = denominator.multiply(object.numerator); return nOd.compareTo(dOn); }
@Test public void testCompareTo(){ Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); Fraction third = new Fraction(1, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Fraction pi1 = new Fraction(1068966896, 340262731); Fraction pi2 = new Fraction( 411557987, 131002976); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public double doubleValue(){ return numerator.doubleValue() / denominator.doubleValue(); }
@Test public void testBinomialCoefficientLarge() throws Exception{ for (int n = 0; n <= 200; n++) { for (int k = 0; k <= n; k++) { long ourResult = -1; long exactResult = -1; boolean shouldThrow = false; boolean didThrow = false; try { ourResult = MathUtils.binomialCoefficient(n, k); } catch (ArithmeticException ex) { didThrow = true; } try { exactResult = binomialCoefficient(n, k); } catch (ArithmeticException ex) { shouldThrow = true; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } } long ourResult = MathUtils.binomialCoefficient(300, 3); long exactResult = binomialCoefficient(300, 3); "<AssertPlaceHolder>"; ourResult = MathUtils.binomialCoefficient(700, 697); exactResult = binomialCoefficient(700, 697); "<AssertPlaceHolder>"; try { MathUtils.binomialCoefficient(700, 300); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { } for (int i = 2000; i <= 10000; i += 2000) { ourResult = MathUtils.binomialCoefficient(i, 3); exactResult = binomialCoefficient(i, 3); "<AssertPlaceHolder>"; } } public static long binomialCoefficient(final int n, final int k){ if (n < k) { throw new IllegalArgumentException( "must have n >= k for binomial coefficient (n,k)"); } if (n < 0) { throw new IllegalArgumentException( "must have n >= 0 for binomial coefficient (n,k)"); } if ((n == k) || (k == 0)) { return 1; } if ((k == 1) || (k == n - 1)) { return n; } long result = Math.round(binomialCoefficientDouble(n, k)); if (result == Long.MAX_VALUE) { throw new ArithmeticException( "result too large to represent in a long integer"); } return result; }
@Test public void testFactorial(){ for (int i = 1; i < 21; i++) { "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static long factorial(final int n){ long result = Math.round(factorialDouble(n)); if (result == Long.MAX_VALUE) { throw new ArithmeticException( "factorial value is too large to fit in a long"); } return factorials[n]; }
@Test public void testFactorial(){ for (int i = 1; i < 21; i++) { "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static double factorialDouble(final int n){ if (n < 0) { throw new IllegalArgumentException("must have n >= 0 for n!"); } return Math.floor(Math.exp(factorialLog(n)) + 0.5); }
@Test public void testFactorial(){ for (int i = 1; i < 21; i++) { "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static double factorialLog(final int n){ if (n < 0) { throw new IllegalArgumentException("must have n > 0 for n!"); } double logSum = 0; for (int i = 2; i <= n; i++) { logSum += Math.log((double)i); } return logSum; }
@Test public void testGcd(){ int a = 30; int b = 50; int c = 77; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static int gcd(int u, int v){ if (u * v == 0) { return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException("overflow: gcd is 2^31"); } int t = ((u & 1) == 1) ? v : -(u / 2) ; do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t != 0); return -u * (1 << k); }
@Test public void testMath221(){ "<AssertPlaceHolder>"; } public Complex multiply(Complex rhs){ if (isNaN() || rhs.isNaN()) { return NaN; } if (Double.isInfinite(real) || Double.isInfinite(imaginary) || Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) { return INF; } return createComplex(real * rhs.real - imaginary * rhs.imaginary, real * rhs.imaginary + imaginary * rhs.real); }
@Test public void testChiSquareLargeTestStatistic() throws Exception{ double[] exp = new double[] { 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 232921.0, 437665.75 }; long[] obs = new long[] { 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899 }; org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); double cst = csti.chiSquareTest(exp, obs); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static double chiSquare(long[][] counts) throws IllegalArgumentException{ return chiSquareTest.chiSquare(counts); }
@Test public void testChiSquareLargeTestStatistic() throws Exception{ double[] exp = new double[] { 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 232921.0, 437665.75 }; long[] obs = new long[] { 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899 }; org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); double cst = csti.chiSquareTest(exp, obs); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static double chiSquareTest(long[][] counts) throws IllegalArgumentException, MathException{ return chiSquareTest. chiSquareTest(counts); }
@Test public void testChiSquare() throws Exception{ long[] observed = {10, 9, 11}; double[] expected = {10, 10, 10}; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; long[] observed1 = { 500, 623, 72, 70, 31 }; double[] expected1 = { 485, 541, 82, 61, 37 }; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; try { testStatistic.chiSquareTest(expected1, observed1, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } long[] tooShortObs = { 0 }; double[] tooShortEx = { 1 }; try { testStatistic.chiSquare(tooShortEx, tooShortObs); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } long[] unMatchedObs = { 0, 1, 2, 3 }; double[] unMatchedEx = { 1, 1, 2 }; try { testStatistic.chiSquare(unMatchedEx, unMatchedObs); fail("arrays have different lengths, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } expected[0] = 0; try { testStatistic.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } expected[0] = 1; observed[0] = -1; try { testStatistic.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } } public static double chiSquare(long[][] counts) throws IllegalArgumentException{ return chiSquareTest.chiSquare(counts); }
@Test public void testChiSquare() throws Exception{ long[] observed = {10, 9, 11}; double[] expected = {10, 10, 10}; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; long[] observed1 = { 500, 623, 72, 70, 31 }; double[] expected1 = { 485, 541, 82, 61, 37 }; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; try { testStatistic.chiSquareTest(expected1, observed1, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } long[] tooShortObs = { 0 }; double[] tooShortEx = { 1 }; try { testStatistic.chiSquare(tooShortEx, tooShortObs); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } long[] unMatchedObs = { 0, 1, 2, 3 }; double[] unMatchedEx = { 1, 1, 2 }; try { testStatistic.chiSquare(unMatchedEx, unMatchedObs); fail("arrays have different lengths, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } expected[0] = 0; try { testStatistic.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } expected[0] = 1; observed[0] = -1; try { testStatistic.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } } public static double chiSquareTest(long[][] counts) throws IllegalArgumentException, MathException{ return chiSquareTest. chiSquareTest(counts); }
@Test public void testChiSquareLargeTestStatistic() throws Exception{ double[] exp = new double[] { 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 232921.0, 437665.75 }; long[] obs = new long[] { 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899 }; org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); double cst = csti.chiSquareTest(exp, obs); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static double chiSquare(long[][] counts) throws IllegalArgumentException{ return chiSquareTest.chiSquare(counts); }
@Test public void testChiSquareLargeTestStatistic() throws Exception{ double[] exp = new double[] { 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 232921.0, 437665.75 }; long[] obs = new long[] { 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899 }; org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); double cst = csti.chiSquareTest(exp, obs); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static double chiSquareTest(long[][] counts) throws IllegalArgumentException, MathException{ return chiSquareTest. chiSquareTest(counts); }
@Test public void testChiSquare() throws Exception{ long[] observed = {10, 9, 11}; double[] expected = {10, 10, 10}; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; long[] observed1 = { 500, 623, 72, 70, 31 }; double[] expected1 = { 485, 541, 82, 61, 37 }; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; try { TestUtils.chiSquareTest(expected1, observed1, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } long[] tooShortObs = { 0 }; double[] tooShortEx = { 1 }; try { TestUtils.chiSquare(tooShortEx, tooShortObs); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } long[] unMatchedObs = { 0, 1, 2, 3 }; double[] unMatchedEx = { 1, 1, 2 }; try { TestUtils.chiSquare(unMatchedEx, unMatchedObs); fail("arrays have different lengths, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } expected[0] = 0; try { TestUtils.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } expected[0] = 1; observed[0] = -1; try { TestUtils.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } } public static double chiSquare(long[][] counts) throws IllegalArgumentException{ return chiSquareTest.chiSquare(counts); }
@Test public void testChiSquare() throws Exception{ long[] observed = {10, 9, 11}; double[] expected = {10, 10, 10}; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; long[] observed1 = { 500, 623, 72, 70, 31 }; double[] expected1 = { 485, 541, 82, 61, 37 }; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; try { TestUtils.chiSquareTest(expected1, observed1, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } long[] tooShortObs = { 0 }; double[] tooShortEx = { 1 }; try { TestUtils.chiSquare(tooShortEx, tooShortObs); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } long[] unMatchedObs = { 0, 1, 2, 3 }; double[] unMatchedEx = { 1, 1, 2 }; try { TestUtils.chiSquare(unMatchedEx, unMatchedObs); fail("arrays have different lengths, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } expected[0] = 0; try { TestUtils.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } expected[0] = 1; observed[0] = -1; try { TestUtils.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { } } public static double chiSquareTest(long[][] counts) throws IllegalArgumentException, MathException{ return chiSquareTest. chiSquareTest(counts); }
@Test public void testSSENonNegative(){ double[] y = { 8915.102, 8919.302, 8923.502 }; double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 }; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++) { reg.addData(x[i], y[i]); } "<AssertPlaceHolder>"; } public double getSumSquaredErrors(){ return sumYY - sumXY * sumXY / sumXX; }
@Test public void testAddYears_int_dstOverlapWinter_addZero(){ MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); "<AssertPlaceHolder>"; test.addYears(0); "<AssertPlaceHolder>"; } public void addHours(int hours){ super.addField(DurationFieldType.hours(), hours); }
@Test public void testAddYears_int_dstOverlapWinter_addZero(){ MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); "<AssertPlaceHolder>"; test.addYears(0); "<AssertPlaceHolder>"; } public void addYears(int years){ super.addField(DurationFieldType.years(), years); }
@Test public void testAddDays_int_dstOverlapWinter_addZero(){ MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); "<AssertPlaceHolder>"; test.addDays(0); "<AssertPlaceHolder>"; } public void addHours(int hours){ super.addField(DurationFieldType.hours(), hours); }
@Test public void testAddDays_int_dstOverlapWinter_addZero(){ MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); "<AssertPlaceHolder>"; test.addDays(0); "<AssertPlaceHolder>"; } public void addDays(int days){ super.addField(DurationFieldType.days(), days); }
@Test public void testAddWeeks_int_dstOverlapWinter_addZero(){ MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); "<AssertPlaceHolder>"; test.addWeeks(0); "<AssertPlaceHolder>"; } public void addHours(int hours){ super.addField(DurationFieldType.hours(), hours); }
@Test public void testAddWeeks_int_dstOverlapWinter_addZero(){ MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); "<AssertPlaceHolder>"; test.addWeeks(0); "<AssertPlaceHolder>"; } public void addWeeks(int weeks){ super.addField(DurationFieldType.weeks(), weeks); }
@Test public void testAdd_DurationFieldType_int_dstOverlapWinter_addZero(){ MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); "<AssertPlaceHolder>"; test.add(DurationFieldType.years(), 0); "<AssertPlaceHolder>"; } public void addHours(int hours){ super.addField(DurationFieldType.hours(), hours); }
@Test public void testAdd_DurationFieldType_int_dstOverlapWinter_addZero(){ MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); "<AssertPlaceHolder>"; test.add(DurationFieldType.years(), 0); "<AssertPlaceHolder>"; } public void add(long duration, Chronology chrono){ add(new Period(duration, getPeriodType(), chrono)); }
@Test public void testAddMonths_int_dstOverlapWinter_addZero(){ MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); "<AssertPlaceHolder>"; test.addMonths(0); "<AssertPlaceHolder>"; } public void addHours(int hours){ super.addField(DurationFieldType.hours(), hours); }
@Test public void testAddMonths_int_dstOverlapWinter_addZero(){ MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin")); test.addHours(1); "<AssertPlaceHolder>"; test.addMonths(0); "<AssertPlaceHolder>"; } public void addMonths(int months){ super.addField(DurationFieldType.months(), months); }
@Test public void test_plusWeekyears_positiveToNegative_crossCutover(){ LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek()); "<AssertPlaceHolder>"; } public DateMidnight addToCopy(int value){ return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); }
@Test public void test_plusYears_positiveToNegative_crossCutover(){ LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY); LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY); "<AssertPlaceHolder>"; } public DateMidnight plusYears(int years){ if (years == 0) { return this; } long instant = getChronology().years().add(getMillis(), years); return withMillis(instant); }
@Test public void testDateTimeZoneBuilder() throws Exception{ getTestDataTimeZoneBuilder().toDateTimeZone("TestDTZ1", true); final DateTimeZone[] zone = new DateTimeZone[1]; Thread t = new Thread(new Runnable() { public void run() { zone[0] = getTestDataTimeZoneBuilder().toDateTimeZone("TestDTZ2", true); } }); t.start(); t.join(); "<AssertPlaceHolder>"; } public DateTimeZone toDateTimeZone(String id, boolean outputID){ if (id == null) { throw new IllegalArgumentException(); } ArrayList<Transition> transitions = new ArrayList<Transition>(); DSTZone tailZone = null; long millis = Long.MIN_VALUE; int saveMillis = 0; int ruleSetCount = iRuleSets.size(); for (int i=0; i<ruleSetCount; i++) { RuleSet rs = iRuleSets.get(i); Transition next = rs.firstTransition(millis); if (next == null) { continue; } addTransition(transitions, next); millis = next.getMillis(); saveMillis = next.getSaveMillis(); rs = new RuleSet(rs); while ((next = rs.nextTransition(millis, saveMillis)) != null) { if (addTransition(transitions, next)) { if (tailZone != null) { break; } } millis = next.getMillis(); saveMillis = next.getSaveMillis(); if (tailZone == null && i == ruleSetCount - 1) { tailZone = rs.buildTailZone(id); } } millis = rs.getUpperLimit(saveMillis); } if (transitions.size() == 0) { if (tailZone != null) { return tailZone; } return buildFixedZone(id, "UTC", 0, 0); } if (transitions.size() == 1 && tailZone == null) { Transition tr = transitions.get(0); return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); } PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); if (zone.isCachable()) { return CachedDateTimeZone.forZone(zone); } return zone; }
@Test public void testFactory_fromDateFields_beforeYearZero1() throws Exception{ GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7); "<AssertPlaceHolder>"; } public static TimeOfDay fromDateFields(Date date){ if (date == null) { throw new IllegalArgumentException("The date must not be null"); } return new TimeOfDay( date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 ); }
@Test public void testFactory_fromDateFields_beforeYearZero3() throws Exception{ GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7); "<AssertPlaceHolder>"; } public static TimeOfDay fromDateFields(Date date){ if (date == null) { throw new IllegalArgumentException("The date must not be null"); } return new TimeOfDay( date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 ); }
@Test public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception{ GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7); "<AssertPlaceHolder>"; } public static TimeOfDay fromCalendarFields(Calendar calendar){ if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } return new TimeOfDay( calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND) ); }
@Test public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception{ GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7); "<AssertPlaceHolder>"; } public static TimeOfDay fromCalendarFields(Calendar calendar){ if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } return new TimeOfDay( calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND) ); }
@Test public void testFactory_fromDateFields_beforeYearZero1() throws Exception{ GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(0, 2, 3); "<AssertPlaceHolder>"; } public static TimeOfDay fromDateFields(Date date){ if (date == null) { throw new IllegalArgumentException("The date must not be null"); } return new TimeOfDay( date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 ); }
@Test public void testFactory_fromDateFields_beforeYearZero3() throws Exception{ GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(-2, 2, 3); "<AssertPlaceHolder>"; } public static TimeOfDay fromDateFields(Date date){ if (date == null) { throw new IllegalArgumentException("The date must not be null"); } return new TimeOfDay( date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000 ); }
@Test public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception{ GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(0, 2, 3); "<AssertPlaceHolder>"; } public static TimeOfDay fromCalendarFields(Calendar calendar){ if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } return new TimeOfDay( calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND) ); }
@Test public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception{ GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6); cal.set(Calendar.ERA, GregorianCalendar.BC); cal.set(Calendar.MILLISECOND, 7); LocalDate expected = new LocalDate(-2, 2, 3); "<AssertPlaceHolder>"; } public static TimeOfDay fromCalendarFields(Calendar calendar){ if (calendar == null) { throw new IllegalArgumentException("The calendar must not be null"); } return new TimeOfDay( calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND) ); }
@Test public void testFormatStandard_negative(){ Period p = new Period(-1, -2, -3, -4, -5, -6, -7, -8); "<AssertPlaceHolder>"; p = Period.years(-54); "<AssertPlaceHolder>"; p = Period.seconds(4).withMillis(-8); "<AssertPlaceHolder>"; p = Period.seconds(-4).withMillis(8); "<AssertPlaceHolder>"; p = Period.seconds(-23); "<AssertPlaceHolder>"; p = Period.millis(-8); "<AssertPlaceHolder>"; } public static PeriodFormatter standard(){ if (cStandard == null) { cStandard = new PeriodFormatterBuilder() .appendLiteral("P") .appendYears() .appendSuffix("Y") .appendMonths() .appendSuffix("M") .appendWeeks() .appendSuffix("W") .appendDays() .appendSuffix("D") .appendSeparatorIfFieldsAfter("T") .appendHours() .appendSuffix("H") .appendMinutes() .appendSuffix("M") .appendSecondsWithOptionalMillis() .appendSuffix("S") .toFormatter(); } return cStandard; }
@Test public void testPlusMonths_int_negativeEndOfMonthAdjust(){ MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC()); MonthDay result = test.plusMonths(-1); MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance()); "<AssertPlaceHolder>"; } public DateMidnight plusMonths(int months){ if (months == 0) { return this; } long instant = getChronology().months().add(getMillis(), months); return withMillis(instant); }
@Test public void testMinusMonths_int_endOfMonthAdjust(){ MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC()); MonthDay result = test.minusMonths(1); MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance()); "<AssertPlaceHolder>"; } public DateMidnight minusMonths(int months){ if (months == 0) { return this; } long instant = getChronology().months().subtract(getMillis(), months); return withMillis(instant); }
@Test public void testParseInto_monthOnly_baseStartYear(){ DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int parseInto(DateTimeParserBucket bucket, String text, int position){ DateTimeParser p = getFormatter(bucket.getLocale()).getParser(); return p.parseInto(bucket, text, position); }
@Test public void testParseInto_monthOnly_parseStartYear(){ DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 2, 1, 12, 20, 30, 0, TOKYO); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int parseInto(DateTimeParserBucket bucket, String text, int position){ DateTimeParser p = getFormatter(bucket.getLocale()).getParser(); return p.parseInto(bucket, text, position); }
@Test public void testParseInto_monthOnly_baseEndYear(){ DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int parseInto(DateTimeParserBucket bucket, String text, int position){ DateTimeParser p = getFormatter(bucket.getLocale()).getParser(); return p.parseInto(bucket, text, position); }
@Test public void testParseInto_monthOnly(){ DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int parseInto(DateTimeParserBucket bucket, String text, int position){ DateTimeParser p = getFormatter(bucket.getLocale()).getParser(); return p.parseInto(bucket, text, position); }
@Test public void testParseInto_monthDay_withDefaultYear_feb29(){ DateTimeFormatter f = DateTimeFormat.forPattern("M d").withDefaultYear(2012); MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int parseInto(DateTimeParserBucket bucket, String text, int position){ DateTimeParser p = getFormatter(bucket.getLocale()).getParser(); return p.parseInto(bucket, text, position); }
@Test public void testParseInto_monthDay_feb29(){ DateTimeFormatter f = DateTimeFormat.forPattern("M d").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int parseInto(DateTimeParserBucket bucket, String text, int position){ DateTimeParser p = getFormatter(bucket.getLocale()).getParser(); return p.parseInto(bucket, text, position); }
@Test public void testParseInto_monthOnly_parseEndYear(){ DateTimeFormatter f = DateTimeFormat.forPattern("M").withLocale(Locale.UK); MutableDateTime result = new MutableDateTime(2004, 1, 31, 12, 20, 30, 0,TOKYO); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int parseInto(DateTimeParserBucket bucket, String text, int position){ DateTimeParser p = getFormatter(bucket.getLocale()).getParser(); return p.parseInto(bucket, text, position); }
@Test public void testBug3476684_adjustOffset(){ final DateTimeZone zone = DateTimeZone.forID("America/Sao_Paulo"); DateTime base = new DateTime(2012, 2, 25, 22, 15, zone); DateTime baseBefore = base.plusHours(1); DateTime baseAfter = base.plusHours(2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public DateTime withEarlierOffsetAtOverlap(){ long newMillis = getZone().adjustOffset(getMillis(), false); return withMillis(newMillis); }
@Test public void testBug3476684_adjustOffset(){ final DateTimeZone zone = DateTimeZone.forID("America/Sao_Paulo"); DateTime base = new DateTime(2012, 2, 25, 22, 15, zone); DateTime baseBefore = base.plusHours(1); DateTime baseAfter = base.plusHours(2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public DateTime withLaterOffsetAtOverlap(){ long newMillis = getZone().adjustOffset(getMillis(), true); return withMillis(newMillis); }
@Test public void testDateTimeCreation_london(){ DateTimeZone zone = DateTimeZone.forID("Europe/London"); DateTime base = new DateTime(2011, 10, 30, 1, 15, zone); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public TimeOfDay plusHours(int hours){ return withFieldAdded(DurationFieldType.hours(), hours); }
@Test public void testToPeriod_fixedZone() throws Throwable{ DateTimeZone zone = DateTimeZone.getDefault(); try { DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2)); long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Duration dur = new Duration(length); Period test = dur.toPeriod(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } finally { DateTimeZone.setDefault(zone); } } public Period toPeriod(){ return this; }
@Test public void testConstructor_long_fixedZone() throws Throwable{ DateTimeZone zone = DateTimeZone.getDefault(); try { DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2)); long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L; Period test = new Period(length); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } finally { DateTimeZone.setDefault(zone); } } public static void setDefault(DateTimeZone zone) throws SecurityException{ SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new JodaTimePermission("DateTimeZone.setDefault")); } if (zone == null) { throw new IllegalArgumentException("The datetime zone must not be null"); } synchronized(DateTimeZone.class) { cDefault = zone; } }
@Test public void testParseLocalDate_weekyear_month_week_2010(){ Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono); "<AssertPlaceHolder>"; } public LocalDate parseLocalDate(String text){ return parseLocalDateTime(text).toLocalDate(); }
@Test public void testParseLocalDate_weekyear_month_week_2011(){ Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono); "<AssertPlaceHolder>"; } public LocalDate parseLocalDate(String text){ return parseLocalDateTime(text).toLocalDate(); }
@Test public void testParseLocalDate_weekyear_month_week_2012(){ Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("xxxx-MM-ww").withChronology(chrono); "<AssertPlaceHolder>"; } public LocalDate parseLocalDate(String text){ return parseLocalDateTime(text).toLocalDate(); }
@Test public void testParseLocalDate_year_month_week_2010(){ Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); "<AssertPlaceHolder>"; } public LocalDate parseLocalDate(String text){ return parseLocalDateTime(text).toLocalDate(); }
@Test public void testParseLocalDate_year_month_week_2011(){ Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); "<AssertPlaceHolder>"; } public LocalDate parseLocalDate(String text){ return parseLocalDateTime(text).toLocalDate(); }
@Test public void testParseLocalDate_year_month_week_2012(){ Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); "<AssertPlaceHolder>"; } public LocalDate parseLocalDate(String text){ return parseLocalDateTime(text).toLocalDate(); }
@Test public void testParseLocalDate_year_month_week_2016(){ Chronology chrono = GJChronology.getInstanceUTC(); DateTimeFormatter f = DateTimeFormat.forPattern("yyyy-MM-ww").withChronology(chrono); "<AssertPlaceHolder>"; } public LocalDate parseLocalDate(String text){ return parseLocalDateTime(text).toLocalDate(); }
@Test public void testWithSecondOfMinuteInDstChange(){ DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); "<AssertPlaceHolder>"; DateTime test = dateTime.withSecondOfMinute(0); "<AssertPlaceHolder>"; } public TimeOfDay withSecondOfMinute(int second){ int[] newValues = getValues(); newValues = getChronology().secondOfMinute().set(this, SECOND_OF_MINUTE, newValues, second); return new TimeOfDay(this, newValues); }
@Test public void testWithMinuteOfHourInDstChange(){ DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); "<AssertPlaceHolder>"; DateTime test = dateTime.withMinuteOfHour(0); "<AssertPlaceHolder>"; } public TimeOfDay withMinuteOfHour(int minute){ int[] newValues = getValues(); newValues = getChronology().minuteOfHour().set(this, MINUTE_OF_HOUR, newValues, minute); return new TimeOfDay(this, newValues); }
@Test public void testWithMinuteOfHourInDstChange_mockZone(){ DateTime cutover = new DateTime(2010, 10, 31, 1, 15, DateTimeZone.forOffsetHoursMinutes(0, 30)); "<AssertPlaceHolder>"; DateTimeZone halfHourZone = new MockZone(cutover.getMillis(), 3600000, -1800); DateTime pre = new DateTime(2010, 10, 31, 1, 0, halfHourZone); "<AssertPlaceHolder>"; DateTime post = new DateTime(2010, 10, 31, 1, 59, halfHourZone); "<AssertPlaceHolder>"; DateTime testPre1 = pre.withMinuteOfHour(30); "<AssertPlaceHolder>"; DateTime testPre2 = pre.withMinuteOfHour(50); "<AssertPlaceHolder>"; DateTime testPost1 = post.withMinuteOfHour(30); "<AssertPlaceHolder>"; DateTime testPost2 = post.withMinuteOfHour(10); "<AssertPlaceHolder>"; } public TimeOfDay withMinuteOfHour(int minute){ int[] newValues = getValues(); newValues = getChronology().minuteOfHour().set(this, MINUTE_OF_HOUR, newValues, minute); return new TimeOfDay(this, newValues); }
@Test public void testBug2182444_usCentral(){ Chronology chronUSCentral = GregorianChronology.getInstance(DateTimeZone.forID("US/Central")); Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC); DateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0, 0, chronUTC); DateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0, 0, chronUTC); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; DateTime usCentralStandardInUSCentral = usCentralStandardInUTC.toDateTime(chronUSCentral); DateTime usCentralDaylightInUSCentral = usCentralDaylightInUTC.toDateTime(chronUSCentral); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isStandardOffset(long instant){ return getOffset(instant) == getStandardOffset(instant); }
@Test public void testBug2182444_usCentral(){ Chronology chronUSCentral = GregorianChronology.getInstance(DateTimeZone.forID("US/Central")); Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC); DateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0, 0, chronUTC); DateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0, 0, chronUTC); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; DateTime usCentralStandardInUSCentral = usCentralStandardInUTC.toDateTime(chronUSCentral); DateTime usCentralDaylightInUSCentral = usCentralDaylightInUTC.toDateTime(chronUSCentral); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public DateTime toDateTime(Chronology chronology){ chronology = DateTimeUtils.getChronology(chronology); if (getChronology() == chronology) { return this; } return super.toDateTime(chronology); }
@Test public void testWithMillisOfSecondInDstChange_Paris_summer(){ DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); "<AssertPlaceHolder>"; DateTime test = dateTime.withMillisOfSecond(0); "<AssertPlaceHolder>"; } public TimeOfDay withMillisOfSecond(int millis){ int[] newValues = getValues(); newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis); return new TimeOfDay(this, newValues); }
@Test public void testWithHourOfDayInDstChange(){ DateTime dateTime = new DateTime("2010-10-31T02:30:10.123+02:00", ZONE_PARIS); "<AssertPlaceHolder>"; DateTime test = dateTime.withHourOfDay(2); "<AssertPlaceHolder>"; } public TimeOfDay withHourOfDay(int hour){ int[] newValues = getValues(); newValues = getChronology().hourOfDay().set(this, HOUR_OF_DAY, newValues, hour); return new TimeOfDay(this, newValues); }
@Test public void testWithMillisOfSecondInDstChange_NewYork_winter(){ DateTime dateTime = new DateTime("2007-11-04T01:30:00.123-05:00", ZONE_NEW_YORK); "<AssertPlaceHolder>"; DateTime test = dateTime.withMillisOfSecond(0); "<AssertPlaceHolder>"; } public TimeOfDay withMillisOfSecond(int millis){ int[] newValues = getValues(); newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis); return new TimeOfDay(this, newValues); }
@Test public void testBug2182444_ausNSW(){ Chronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID("Australia/NSW")); Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC); DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC); DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW); DateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public DateTime toDateTime(Chronology chronology){ chronology = DateTimeUtils.getChronology(chronology); if (getChronology() == chronology) { return this; } return super.toDateTime(chronology); }
@Test public void testBug2182444_ausNSW(){ Chronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID("Australia/NSW")); Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC); DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC); DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW); DateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isStandardOffset(long instant){ return getOffset(instant) == getStandardOffset(instant); }
@Test public void testCLI13() throws ParseException{ final String debugOpt = "debug"; Option debug = OptionBuilder .withArgName( debugOpt ) .withDescription( "turn on debugging" ) .withLongOpt( debugOpt ) .hasArg() .create( 'd' ); Options options = new Options(); options.addOption( debug ); CommandLine commandLine = new PosixParser().parse( options, new String[]{"-d", "true"} ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException{ this.options = options; requiredOptions = options.getRequiredOptions(); cmd = new CommandLine(); boolean eatTheRest = false; if (arguments == null) { arguments = new String[0]; } List tokenList = Arrays.asList(flatten(this.options, arguments, stopAtNonOption)); ListIterator iterator = tokenList.listIterator(); while (iterator.hasNext()) { String t = (String) iterator.next(); if ("--".equals(t)) { eatTheRest = true; } else if ("-".equals(t)) { if (stopAtNonOption) { eatTheRest = true; } else { cmd.addArg(t); } } else if (t.startsWith("-")) { if (stopAtNonOption && !options.hasOption(t)) { eatTheRest = true; cmd.addArg(t); } else { processOption(t, iterator); } } else { cmd.addArg(t); if (stopAtNonOption) { eatTheRest = true; } } if (eatTheRest) { while (iterator.hasNext()) { String str = (String) iterator.next(); if (!"--".equals(str)) { cmd.addArg(str); } } } } processProperties(properties); checkRequiredOptions(); return cmd; }
@Test public void testCLI13() throws ParseException{ final String debugOpt = "debug"; Option debug = OptionBuilder .withArgName( debugOpt ) .withDescription( "turn on debugging" ) .withLongOpt( debugOpt ) .hasArg() .create( 'd' ); Options options = new Options(); options.addOption( debug ); CommandLine commandLine = new PosixParser().parse( options, new String[]{"-d", "true"} ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String getOptionValue(char opt, String defaultValue){ return getOptionValue(String.valueOf(opt), defaultValue); }
@Test public void testCLI13() throws ParseException{ final String debugOpt = "debug"; Option debug = OptionBuilder .withArgName( debugOpt ) .withDescription( "turn on debugging" ) .withLongOpt( debugOpt ) .hasArg() .create( 'd' ); Options options = new Options(); options.addOption( debug ); CommandLine commandLine = new PosixParser().parse( options, new String[]{"-d", "true"} ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean hasOption(String opt){ opt = Util.stripLeadingHyphens(opt); return shortOpts.containsKey(opt) || longOpts.containsKey(opt); }
@Test public void testSimplePattern(){ try { Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/"); String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" }; CommandLineParser parser = new PosixParser(); CommandLine line = parser.parse(options,args); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } catch( ParseException exp ) { fail( exp.getMessage() ); } catch( java.net.MalformedURLException exp ) { fail( exp.getMessage() ); } } public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException{ this.options = options; for (Iterator it = options.helpOptions().iterator(); it.hasNext();) { Option opt = (Option) it.next(); opt.clearValues(); } requiredOptions = options.getRequiredOptions(); cmd = new CommandLine(); boolean eatTheRest = false; if (arguments == null) { arguments = new String[0]; } List tokenList = Arrays.asList(flatten(this.options, arguments, stopAtNonOption)); ListIterator iterator = tokenList.listIterator(); while (iterator.hasNext()) { String t = (String) iterator.next(); if ("--".equals(t)) { eatTheRest = true; } else if ("-".equals(t)) { if (stopAtNonOption) { eatTheRest = true; } else { cmd.addArg(t); } } else if (t.startsWith("-")) { if (stopAtNonOption && !options.hasOption(t)) { eatTheRest = true; cmd.addArg(t); } else { processOption(t, iterator); } } else { cmd.addArg(t); if (stopAtNonOption) { eatTheRest = true; } } if (eatTheRest) { while (iterator.hasNext()) { String str = (String) iterator.next(); if (!"--".equals(str)) { cmd.addArg(str); } } } } processProperties(properties); checkRequiredOptions(); return cmd; }
@Test public void testSimplePattern(){ try { Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/"); String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" }; CommandLineParser parser = new PosixParser(); CommandLine line = parser.parse(options,args); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } catch( ParseException exp ) { fail( exp.getMessage() ); } catch( java.net.MalformedURLException exp ) { fail( exp.getMessage() ); } } public String getOptionValue(char opt, String defaultValue){ return getOptionValue(String.valueOf(opt), defaultValue); }
@Test public void testSimplePattern(){ try { Options options = PatternOptionBuilder.parsePattern("a:b@cde>f+n%t/"); String[] args = new String[] { "-c", "-a", "foo", "-b", "java.util.Vector", "-e", "build.xml", "-f", "java.util.Calendar", "-n", "4.5", "-t", "http://jakarta.apache.org/" }; CommandLineParser parser = new PosixParser(); CommandLine line = parser.parse(options,args); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } catch( ParseException exp ) { fail( exp.getMessage() ); } catch( java.net.MalformedURLException exp ) { fail( exp.getMessage() ); } } public boolean hasOption(String opt){ opt = Util.stripLeadingHyphens(opt); return shortOpts.containsKey(opt) || longOpts.containsKey(opt); }
@Test public void testRequiredOptions(){ PatternBuilder builder = new PatternBuilder(); builder.withPattern("hc!<"); Option option = builder.create(); "<AssertPlaceHolder>"; GroupImpl group = (GroupImpl)option; Iterator i = group.getOptions().iterator(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public final Argument create(){ final Argument argument = new ArgumentImpl( name, description, minimum, maximum, initialSeparator, subsequentSeparator, validator, consumeRemaining, defaultValues, id); reset(); return argument; }
@Test public void testRequiredOptions(){ PatternBuilder builder = new PatternBuilder(); builder.withPattern("hc!<"); Option option = builder.create(); "<AssertPlaceHolder>"; GroupImpl group = (GroupImpl)option; Iterator i = group.getOptions().iterator(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public List getOptions(){ return options; }
@Test public void testPrintWrapped() throws Exception{ StringBuffer sb = new StringBuffer(); HelpFormatter hf = new HelpFormatter(); String text = "This is a test."; String expected; expected = "This is a" + hf.getNewLine() + "test."; hf.renderWrappedText(sb, 12, 0, text); "<AssertPlaceHolder>"; sb.setLength(0); expected = "This is a" + hf.getNewLine() + "    test."; hf.renderWrappedText(sb, 12, 4, text); "<AssertPlaceHolder>"; text = "  -p,--period <PERIOD>  PERIOD is time duration of form " + "DATE[-DATE] where DATE has form YYYY[MM[DD]]"; sb.setLength(0); expected = "  -p,--period <PERIOD>  PERIOD is time duration of" + hf.getNewLine() + "                        form DATE[-DATE] where DATE" + hf.getNewLine() + "                        has form YYYY[MM[DD]]"; hf.renderWrappedText(sb, 53, 24, text); "<AssertPlaceHolder>"; text = "aaaa aaaa aaaa" + hf.getNewLine() + "aaaaaa" + hf.getNewLine() + "aaaaa"; expected = text; sb.setLength(0); hf.renderWrappedText(sb, 16, 0, text); "<AssertPlaceHolder>"; expected = "aaaa aaaa aaaa" + hf.getNewLine() + "    aaaaaa" + hf.getNewLine() + "    aaaaa"; sb.setLength(0); hf.renderWrappedText(sb, 16, 4, text); "<AssertPlaceHolder>"; } protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text){ int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, nextLineTabStop); if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }
@Test public void testPrintOptionWithEmptyArgNameUsage(){ Option option = new Option("f", true, null); option.setArgName(""); option.setRequired(true); Options options = new Options(); options.addOption(option); StringWriter out = new StringWriter(); HelpFormatter formatter = new HelpFormatter(); formatter.printUsage(new PrintWriter(out), 80, "app", options); "<AssertPlaceHolder>"; } public void printUsage(PrintWriter pw, int width, String cmdLineSyntax){ int argPos = cmdLineSyntax.indexOf(' ') + 1; printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax); }
@Test public void testShortWithEqual() throws Exception{ String[] args = new String[] { "-f=bar" }; Options options = new Options(); options.addOption(OptionBuilder.withLongOpt("foo").hasArg().create('f')); Parser parser = new GnuParser(); CommandLine cl = parser.parse(options, args); "<AssertPlaceHolder>"; } public String getOptionValue(char opt, String defaultValue){ return getOptionValue(String.valueOf(opt), defaultValue); }
@Test public void testLongWithEqualSingleDash() throws Exception{ String[] args = new String[] { "-foo=bar" }; Options options = new Options(); options.addOption(OptionBuilder.withLongOpt("foo").hasArg().create('f')); Parser parser = new GnuParser(); CommandLine cl = parser.parse(options, args); "<AssertPlaceHolder>"; } public String getOptionValue(char opt, String defaultValue){ return getOptionValue(String.valueOf(opt), defaultValue); }
@Test public void testStopBursting() throws Exception{ String[] args = new String[] { "-azc" }; CommandLine cl = parser.parse(options, args, true); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException{ for (Iterator it = options.helpOptions().iterator(); it.hasNext();) { Option opt = (Option) it.next(); opt.clearValues(); } setOptions(options); cmd = new CommandLine(); boolean eatTheRest = false; if (arguments == null) { arguments = new String[0]; } List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption)); ListIterator iterator = tokenList.listIterator(); while (iterator.hasNext()) { String t = (String) iterator.next(); if ("--".equals(t)) { eatTheRest = true; } else if ("-".equals(t)) { if (stopAtNonOption) { eatTheRest = true; } else { cmd.addArg(t); } } else if (t.startsWith("-")) { if (stopAtNonOption && !getOptions().hasOption(t)) { eatTheRest = true; cmd.addArg(t); } else { processOption(t, iterator); } } else { cmd.addArg(t); if (stopAtNonOption) { eatTheRest = true; } } if (eatTheRest) { while (iterator.hasNext()) { String str = (String) iterator.next(); if (!"--".equals(str)) { cmd.addArg(str); } } } } processProperties(properties); checkRequiredOptions(); return cmd; }
@Test public void testStop2() throws Exception{ String[] args = new String[]{"-z", "-a", "-btoast"}; CommandLine cl = parser.parse(options, args, true); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException{ for (Iterator it = options.helpOptions().iterator(); it.hasNext();) { Option opt = (Option) it.next(); opt.clearValues(); } setOptions(options); cmd = new CommandLine(); boolean eatTheRest = false; if (arguments == null) { arguments = new String[0]; } List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption)); ListIterator iterator = tokenList.listIterator(); while (iterator.hasNext()) { String t = (String) iterator.next(); if ("--".equals(t)) { eatTheRest = true; } else if ("-".equals(t)) { if (stopAtNonOption) { eatTheRest = true; } else { cmd.addArg(t); } } else if (t.startsWith("-")) { if (stopAtNonOption && !getOptions().hasOption(t)) { eatTheRest = true; cmd.addArg(t); } else { processOption(t, iterator); } } else { cmd.addArg(t); if (stopAtNonOption) { eatTheRest = true; } } if (eatTheRest) { while (iterator.hasNext()) { String str = (String) iterator.next(); if (!"--".equals(str)) { cmd.addArg(str); } } } } processProperties(properties); checkRequiredOptions(); return cmd; }
@Test public void testStop3() throws Exception{ String[] args = new String[]{"--zop==1", "-abtoast", "--b=bar"}; CommandLine cl = parser.parse(options, args, true); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException{ for (Iterator it = options.helpOptions().iterator(); it.hasNext();) { Option opt = (Option) it.next(); opt.clearValues(); } setOptions(options); cmd = new CommandLine(); boolean eatTheRest = false; if (arguments == null) { arguments = new String[0]; } List tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption)); ListIterator iterator = tokenList.listIterator(); while (iterator.hasNext()) { String t = (String) iterator.next(); if ("--".equals(t)) { eatTheRest = true; } else if ("-".equals(t)) { if (stopAtNonOption) { eatTheRest = true; } else { cmd.addArg(t); } } else if (t.startsWith("-")) { if (stopAtNonOption && !getOptions().hasOption(t)) { eatTheRest = true; cmd.addArg(t); } else { processOption(t, iterator); } } else { cmd.addArg(t); if (stopAtNonOption) { eatTheRest = true; } } if (eatTheRest) { while (iterator.hasNext()) { String str = (String) iterator.next(); if (!"--".equals(str)) { cmd.addArg(str); } } } } processProperties(properties); checkRequiredOptions(); return cmd; }
@Test public void testPropertyOptionFlags() throws Exception{ Properties properties = new Properties(); properties.setProperty( "a", "true" ); properties.setProperty( "c", "yes" ); properties.setProperty( "e", "1" ); Parser parser = new PosixParser(); CommandLine cmd = parser.parse(opts, null, properties); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; properties = new Properties(); properties.setProperty( "a", "false" ); properties.setProperty( "c", "no" ); properties.setProperty( "e", "0" ); cmd = parser.parse(opts, null, properties); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; properties = new Properties(); properties.setProperty( "a", "TRUE" ); properties.setProperty( "c", "nO" ); properties.setProperty( "e", "TrUe" ); cmd = parser.parse(opts, null, properties); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; properties = new Properties(); properties.setProperty( "a", "just a string" ); properties.setProperty( "e", "" ); cmd = parser.parse(opts, null, properties); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean hasOption(String opt){ opt = Util.stripLeadingHyphens(opt); return shortOpts.containsKey(opt) || longOpts.containsKey(opt); }
@Test public void testStripLeadingAndTrailingQuotes(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } static String stripLeadingAndTrailingQuotes(String str){ if (str.startsWith("\"")) { str = str.substring(1, str.length()); } int length = str.length(); if (str.endsWith("\"")) { str = str.substring(0, length - 1); } return str; }
@Test public void testDefaultArgName(){ Option option = OptionBuilder.hasArg().isRequired().create("f"); Options options = new Options(); options.addOption(option); StringWriter out = new StringWriter(); HelpFormatter formatter = new HelpFormatter(); formatter.setArgName("argument"); formatter.printUsage(new PrintWriter(out), 80, "app", options); "<AssertPlaceHolder>"; } public void setArgName(String argName){ this.argName = argName; }
@Test public void testFindWrapPos() throws Exception{ HelpFormatter hf = new HelpFormatter(); String text = "This is a test."; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; text = "aaaa aa"; "<AssertPlaceHolder>"; text = "aaaaaa aaaaaa"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } protected int findWrapPos(String text, int width, int startPos){ int pos; if (((pos = text.indexOf('\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\t', startPos)) != -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) { ++pos; } return pos == text.length() ? -1 : pos; }
@Test public void testIndentedHeaderAndFooter(){ Options options = new Options(); HelpFormatter formatter = new HelpFormatter(); String header = "  Header1\n  Header2"; String footer = "  Footer1\n  Footer2"; StringWriter out = new StringWriter(); formatter.printHelp(new PrintWriter(out), 80, "foobar", header, options, 2, 2, footer, true); "<AssertPlaceHolder>"; } public void printHelp(PrintWriter pw, int width, String cmdLineSyntax, String header, Options options, int leftPad, int descPad, String footer, boolean autoUsage){ if ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0)) { throw new IllegalArgumentException("cmdLineSyntax not provided"); } if (autoUsage) { printUsage(pw, width, cmdLineSyntax, options); } else { printUsage(pw, width, cmdLineSyntax); } if ((header != null) && (header.trim().length() > 0)) { printWrapped(pw, width, header); } printOptions(pw, width, options, leftPad, descPad); if ((footer != null) && (footer.trim().length() > 0)) { printWrapped(pw, width, footer); } }
@Test public void testGetParsedOptionValue() throws Exception{ Options options = new Options(); options.addOption(OptionBuilder.hasArg().withType(Number.class).create("i")); options.addOption(OptionBuilder.hasArg().create("f")); CommandLineParser parser = new DefaultParser(); CommandLine cmd = parser.parse(options, new String[] { "-i", "123", "-f", "foo" }); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Object getParsedOptionValue(String opt) throws ParseException{ String res = getOptionValue(opt); Option option = resolveOption(opt); if (option == null || res == null) { return null; } return TypeHandler.createValue(res, option.getType()); }
@Test public void testTwoCompleteOptions( ){ Option simple = OptionBuilder.withLongOpt( "simple option") .hasArg( ) .isRequired( ) .hasArgs( ) .withType( Float.class ) .withDescription( "this is a simple option" ) .create( 's' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; simple = OptionBuilder.withLongOpt( "dimple option") .hasArg( ) .withDescription( "this is a dimple option" ) .create( 'd' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static OptionBuilder withLongOpt(String newLongopt){ OptionBuilder.longopt = newLongopt; return instance; }
@Test public void testTwoCompleteOptions( ){ Option simple = OptionBuilder.withLongOpt( "simple option") .hasArg( ) .isRequired( ) .hasArgs( ) .withType( Float.class ) .withDescription( "this is a simple option" ) .create( 's' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; simple = OptionBuilder.withLongOpt( "dimple option") .hasArg( ) .withDescription( "this is a dimple option" ) .create( 'd' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean hasArg(){ return numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES; }
@Test public void testTwoCompleteOptions( ){ Option simple = OptionBuilder.withLongOpt( "simple option") .hasArg( ) .isRequired( ) .hasArgs( ) .withType( Float.class ) .withDescription( "this is a simple option" ) .create( 's' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; simple = OptionBuilder.withLongOpt( "dimple option") .hasArg( ) .withDescription( "this is a dimple option" ) .create( 'd' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isRequired(){ return required; }
@Test public void testTwoCompleteOptions( ){ Option simple = OptionBuilder.withLongOpt( "simple option") .hasArg( ) .isRequired( ) .hasArgs( ) .withType( Float.class ) .withDescription( "this is a simple option" ) .create( 's' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; simple = OptionBuilder.withLongOpt( "dimple option") .hasArg( ) .withDescription( "this is a dimple option" ) .create( 'd' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean hasArgs(){ return numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES; }
@Test public void testTwoCompleteOptions( ){ Option simple = OptionBuilder.withLongOpt( "simple option") .hasArg( ) .isRequired( ) .hasArgs( ) .withType( Float.class ) .withDescription( "this is a simple option" ) .create( 's' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; simple = OptionBuilder.withLongOpt( "dimple option") .hasArg( ) .withDescription( "this is a dimple option" ) .create( 'd' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static OptionBuilder withType(Class newType){ OptionBuilder.type = newType; return instance; }
@Test public void testTwoCompleteOptions( ){ Option simple = OptionBuilder.withLongOpt( "simple option") .hasArg( ) .isRequired( ) .hasArgs( ) .withType( Float.class ) .withDescription( "this is a simple option" ) .create( 's' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; simple = OptionBuilder.withLongOpt( "dimple option") .hasArg( ) .withDescription( "this is a dimple option" ) .create( 'd' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static OptionBuilder withDescription(String newDescription){ OptionBuilder.description = newDescription; return instance; }
@Test public void testTwoCompleteOptions( ){ Option simple = OptionBuilder.withLongOpt( "simple option") .hasArg( ) .isRequired( ) .hasArgs( ) .withType( Float.class ) .withDescription( "this is a simple option" ) .create( 's' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; simple = OptionBuilder.withLongOpt( "dimple option") .hasArg( ) .withDescription( "this is a dimple option" ) .create( 'd' ); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static Option create(String opt) throws IllegalArgumentException{ Option option = null; try { option = new Option(opt, description); option.setLongOpt(longopt); option.setRequired(required); option.setOptionalArg(optionalArg); option.setArgs(numberOfArgs); option.setType(type); option.setValueSeparator(valuesep); option.setArgName(argName); } finally { OptionBuilder.reset(); } return option; }
@Test public void shouldParseShortOptionWithoutValue() throws Exception{ String[] twoShortOptions = new String[]{"-t1", "-last"}; final CommandLine commandLine = parser.parse(options, twoShortOptions); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException{ this.options = options; this.stopAtNonOption = stopAtNonOption; skipParsing = false; currentOption = null; expectedOpts = new ArrayList(options.getRequiredOptions()); for (OptionGroup group : options.getOptionGroups()) { group.setSelected(null); } cmd = new CommandLine(); if (arguments != null) { for (String argument : arguments) { handleToken(argument); } } checkRequiredArgs(); handleProperties(properties); checkRequiredOptions(); return cmd; }
@Test public void shouldParseConcatenatedShortOptions() throws Exception{ String[] concatenatedShortOptions = new String[] { "-t1", "-ab" }; final CommandLine commandLine = parser.parse(options, concatenatedShortOptions); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException{ this.options = options; this.stopAtNonOption = stopAtNonOption; skipParsing = false; currentOption = null; expectedOpts = new ArrayList(options.getRequiredOptions()); for (OptionGroup group : options.getOptionGroups()) { group.setSelected(null); } cmd = new CommandLine(); if (arguments != null) { for (String argument : arguments) { handleToken(argument); } } checkRequiredArgs(); handleProperties(properties); checkRequiredOptions(); return cmd; }
@Test public void testExistingFilePattern() throws Exception{ final Options options = PatternOptionBuilder.parsePattern("g<"); final CommandLineParser parser = new PosixParser(); final CommandLine line = parser.parse(options, new String[] { "-g", "src/test/resources/existing-readable.file" }); final Object parsedReadableFileStream = line.getOptionObject("g"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Object getOptionObject(final char opt){ return getOptionObject(String.valueOf(opt)); }
@Test public void testExistingFilePatternFileNotExist() throws Exception{ final Options options = PatternOptionBuilder.parsePattern("f<"); final CommandLineParser parser = new PosixParser(); final CommandLine line = parser.parse(options, new String[] { "-f", "non-existing.file" }); "<AssertPlaceHolder>"; } public Object getOptionObject(final char opt){ return getOptionObject(String.valueOf(opt)); }
@Test public void testDoubleMetaphoneAlternate(){ String value = null; for (int i = 0; i < TEST_DATA.length; i++) { value = TEST_DATA[i][0]; "<AssertPlaceHolder>"; } } public String doubleMetaphone(String value, boolean alternate){ value = cleanInput(value); if (value == null) { return null; } boolean slavoGermanic = isSlavoGermanic(value); int index = isSilentStart(value) ? 1 : 0; DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen()); while (!result.isComplete() && index <= value.length() - 1) { switch (value.charAt(index)) { case 'A': case 'E': case 'I': case 'O': case 'U': case 'Y': index = handleAEIOUY(value, result, index); break; case 'B': result.append('P'); index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1; break; case '\u00C7': result.append('S'); index++; break; case 'C': index = handleC(value, result, index); break; case 'D': index = handleD(value, result, index); break; case 'F': result.append('F'); index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1; break; case 'G': index = handleG(value, result, index, slavoGermanic); break; case 'H': index = handleH(value, result, index); break; case 'J': index = handleJ(value, result, index, slavoGermanic); break; case 'K': result.append('K'); index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1; break; case 'L': index = handleL(value, result, index); break; case 'M': result.append('M'); index = conditionM0(value, index) ? index + 2 : index + 1; break; case 'N': result.append('N'); index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1; break; case '\u00D1': result.append('N'); index++; break; case 'P': index = handleP(value, result, index); break; case 'Q': result.append('K'); index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1; break; case 'R': index = handleR(value, result, index, slavoGermanic); break; case 'S': index = handleS(value, result, index, slavoGermanic); break; case 'T': index = handleT(value, result, index); break; case 'V': result.append('F'); index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1; break; case 'W': index = handleW(value, result, index); break; case 'X': index = handleX(value, result, index); break; case 'Z': index = handleZ(value, result, index, slavoGermanic); break; default: index++; break; } } return alternate ? result.getAlternate() : result.getPrimary(); }
@Test public void testEncoder() throws EncoderException{ Encoder enc = new Base64(); for (int i = 0; i < STRINGS.length; i++) { if (STRINGS[i] != null) { byte[] base64 = utf8(STRINGS[i]); byte[] binary = BYTES[i]; boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary)); "<AssertPlaceHolder>"; } } } public Object encode(Object object) throws EncoderException{ try { byte[] byteArray = object instanceof String ? ((String) object).getBytes(getCharsetName()) : (byte[]) object; return encodeHex(byteArray); } catch (ClassCastException e) { throw new EncoderException(e.getMessage(), e); } catch (UnsupportedEncodingException e) { throw new EncoderException(e.getMessage(), e); } }
@Test public void testBinaryEncoder() throws EncoderException{ BinaryEncoder enc = new Base64(); for (int i = 0; i < STRINGS.length; i++) { if (STRINGS[i] != null) { byte[] base64 = utf8(STRINGS[i]); byte[] binary = BYTES[i]; boolean b = Arrays.equals(base64, enc.encode(binary)); "<AssertPlaceHolder>"; } } } public Object encode(Object object) throws EncoderException{ try { byte[] byteArray = object instanceof String ? ((String) object).getBytes(getCharsetName()) : (byte[]) object; return encodeHex(byteArray); } catch (ClassCastException e) { throw new EncoderException(e.getMessage(), e); } catch (UnsupportedEncodingException e) { throw new EncoderException(e.getMessage(), e); } }
@Test public void testSoftLineBreakEncode() throws Exception{ String qpdata = "If you believe that truth=3Dbeauty, then surely mathematics is the most " + "b=\r\neautiful branch of philosophy."; String expected = "If you believe that truth=beauty, then surely mathematics is the most " + "beautiful branch of philosophy."; QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(); "<AssertPlaceHolder>"; String decoded = qpcodec.decode(qpdata); "<AssertPlaceHolder>"; } public String encode(String pString, String charset) throws UnsupportedEncodingException{ if (pString == null) { return null; } return StringUtils.newStringUsAscii(encode(pString.getBytes(charset))); }
@Test public void testUltimateSoftBreak() throws Exception{ final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(); String plain ="This is a example of a quoted-printable text file. There is no end to it\t"; String expected = "This is a example of a quoted-printable text file. There is no end to i=\r\nt=09"; "<AssertPlaceHolder>"; plain ="This is a example of a quoted-printable text file. There is no end to it "; expected = "This is a example of a quoted-printable text file. There is no end to i=\r\nt=20"; "<AssertPlaceHolder>"; plain ="This is a example of a quoted-printable text file. There is no end to   "; expected = "This is a example of a quoted-printable text file. There is no end to=20=\r\n =20"; "<AssertPlaceHolder>"; plain ="This is a example of a quoted-printable text file. There is no end to=  "; expected = "This is a example of a quoted-printable text file. There is no end to=3D=\r\n =20"; "<AssertPlaceHolder>"; } public String encode(String pString, String charset) throws UnsupportedEncodingException{ if (pString == null) { return null; } return StringUtils.newStringUsAscii(encode(pString.getBytes(charset))); }
@Test public void testTrailingSpecial() throws Exception{ final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(); String plain ="This is a example of a quoted-printable text file. This might contain sp=cial chars."; String expected = "This is a example of a quoted-printable text file. This might contain sp=3D=\r\ncial chars."; "<AssertPlaceHolder>"; plain ="This is a example of a quoted-printable text file. This might contain ta\tbs as well."; expected = "This is a example of a quoted-printable text file. This might contain ta=09=\r\nbs as well."; "<AssertPlaceHolder>"; } public String encode(String pString, String charset) throws UnsupportedEncodingException{ if (pString == null) { return null; } return StringUtils.newStringUsAscii(encode(pString.getBytes(charset))); }
@Test public void testAvailable() throws Throwable{ InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO)); Base32InputStream b32stream = new Base32InputStream(ins); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } int available(){ return buffer != null ? pos - readPos : 0; }
@Test public void testAvailable() throws Throwable{ InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64)); Base64InputStream b64stream = new Base64InputStream(ins); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } int available(){ return buffer != null ? pos - readPos : 0; }
@Test public void testCompatibilityWithOriginalVersion(){ Map<String, String> args = new TreeMap<String, String>(); args.put("nameType", "GENERIC"); args.put("ruleType", "APPROX"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; args.put("nameType", "ASHKENAZI"); args.put("ruleType", "APPROX"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String encode(final String source) throws EncoderException{ if (source == null) { return null; } return this.engine.encode(source); }
@Test public void testNotEquals(){ ZipArchiveEntry entry1 = new ZipArchiveEntry("foo"); ZipArchiveEntry entry2 = new ZipArchiveEntry("bar"); "<AssertPlaceHolder>"; } public boolean equals(Object o){ if (o == null || !(o instanceof ZipLong)) { return false; } return value == ((ZipLong) o).getValue(); }
@Test public void winzipBackSlashWorkaround() throws Exception{ URL zip = getClass().getResource("/test-winzip.zip"); ZipArchiveInputStream in = null; try { in = new ZipArchiveInputStream(new FileInputStream(new File(new URI(zip.toString())))); ZipArchiveEntry zae = in.getNextZipEntry(); zae = in.getNextZipEntry(); zae = in.getNextZipEntry(); "<AssertPlaceHolder>"; } finally { if (in != null) { in.close(); } } } public ZipArchiveEntry getNextZipEntry() throws IOException{ if (closed || hitCentralDirectory) { return null; } if (current != null) { closeEntry(); } byte[] lfh = new byte[LFH_LEN]; try { readFully(lfh); } catch (EOFException e) { return null; } ZipLong sig = new ZipLong(lfh); if (sig.equals(ZipLong.CFH_SIG)) { hitCentralDirectory = true; return null; } if (!sig.equals(ZipLong.LFH_SIG)) { return null; } int off = WORD; current = new CurrentEntry(); int versionMadeBy = ZipShort.getValue(lfh, off); off += SHORT; current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK); final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfh, off); final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames(); final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; current.hasDataDescriptor = gpFlag.usesDataDescriptor(); current.entry.setGeneralPurposeBit(gpFlag); off += SHORT; current.entry.setMethod(ZipShort.getValue(lfh, off)); off += SHORT; long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off)); current.entry.setTime(time); off += WORD; ZipLong size = null, cSize = null; if (!current.hasDataDescriptor) { current.entry.setCrc(ZipLong.getValue(lfh, off)); off += WORD; cSize = new ZipLong(lfh, off); off += WORD; size = new ZipLong(lfh, off); off += WORD; } else { off += 3 * WORD; } int fileNameLen = ZipShort.getValue(lfh, off); off += SHORT; int extraLen = ZipShort.getValue(lfh, off); off += SHORT; byte[] fileName = new byte[fileNameLen]; readFully(fileName); current.entry.setName(entryEncoding.decode(fileName), fileName); byte[] extraData = new byte[extraLen]; readFully(extraData); current.entry.setExtra(extraData); if (!hasUTF8Flag && useUnicodeExtraFields) { ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null); } processZip64Extra(size, cSize); return current.entry; }
@Test public void testWinzipBackSlashWorkaround() throws Exception{ URL zip = getClass().getResource("/test-winzip.zip"); File archive = new File(new URI(zip.toString())); zf = new ZipFile(archive); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public ZipArchiveEntry getEntry(){ return entry; }
@Test public void testNullCommentEqualsEmptyComment(){ ZipArchiveEntry entry1 = new ZipArchiveEntry("foo"); ZipArchiveEntry entry2 = new ZipArchiveEntry("foo"); ZipArchiveEntry entry3 = new ZipArchiveEntry("foo"); entry1.setComment(null); entry2.setComment(""); entry3.setComment("bar"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public void setComment(String comment){ this.comment = comment; }
@Test public void readOfLength0ShouldReturn0() throws Exception{ byte[] rawData = new byte[1048576]; for (int i=0; i < rawData.length; ++i) { rawData[i] = (byte) Math.floor(Math.random()*256); } ByteArrayOutputStream baos = new ByteArrayOutputStream(); BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos); bzipOut.write(rawData); bzipOut.flush(); bzipOut.close(); baos.flush(); baos.close(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais); byte[] buffer = new byte[1024]; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; bzipIn.close(); } public int read(final byte[] dest, final int offs, final int len) throws IOException{ if (offs < 0) { throw new IndexOutOfBoundsException("offs(" + offs + ") < 0."); } if (len < 0) { throw new IndexOutOfBoundsException("len(" + len + ") < 0."); } if (offs + len > dest.length) { throw new IndexOutOfBoundsException("offs(" + offs + ") + len(" + len + ") > dest.length(" + dest.length + ")."); } if (this.in == null) { throw new IOException("stream closed"); } final int hi = offs + len; int destOffs = offs; int b; while (destOffs < hi && ((b = read0()) >= 0)) { dest[destOffs++] = (byte) b; count(1); } int c = (destOffs == offs) ? -1 : (destOffs - offs); return c; }
@Test public void sanitizeShortensString(){ String input = "012345678901234567890123456789012345678901234567890123456789" + "012345678901234567890123456789012345678901234567890123456789" + "012345678901234567890123456789012345678901234567890123456789" + "012345678901234567890123456789012345678901234567890123456789" + "012345678901234567890123456789012345678901234567890123456789"; String expected = "012345678901234567890123456789012345678901234567890123456789" + "012345678901234567890123456789012345678901234567890123456789" + "012345678901234567890123456789012345678901234567890123456789" + "012345678901234567890123456789012345678901234567890123456789" + "012345678901..."; "<AssertPlaceHolder>"; } public static String sanitize(String s){ final char[] chars = s.toCharArray(); final int len = chars.length; final StringBuilder sb = new StringBuilder(); for (int i = 0; i < len; i++) { final char c = chars[i]; if (!Character.isISOControl(c)) { Character.UnicodeBlock block = Character.UnicodeBlock.of(c); if (block != null && block != Character.UnicodeBlock.SPECIALS) { sb.append(c); continue; } } sb.append('?'); } return sb.toString(); }
@Test public void littleEndianWithOverflow() throws Exception{ ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 87, 45, 66, 15, 90, 29, 88, 61, 33, 74 }); BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public long readBits(final int count) throws IOException{ if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; return bitsOut; }
@Test public void bigEndianWithOverflow() throws Exception{ ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 87, 45, 66, 15, 90, 29, 88, 61, 33, 74 }); BitInputStream bin = new BitInputStream(in, ByteOrder.BIG_ENDIAN); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public long readBits(final int count) throws IOException{ if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } final long bitsOut; if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; return bitsOut; }
@Test public void isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet() throws Exception{ try (ZipFile zf = new ZipFile(getFile("COMPRESS-379.jar"))) { ZipArchiveEntry ze = zf.getEntry("META-INF/maven/"); "<AssertPlaceHolder>"; } } public boolean isUnixSymlink(){ return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG; }
@Test public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException{ ByteArrayOutputStream init = new ByteArrayOutputStream(); try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) { zos.putArchiveEntry(new ZipArchiveEntry("test1.txt")); zos.write("foo".getBytes("UTF-8")); zos.closeArchiveEntry(); } File f = new File(dir, "test.zip"); try (FileOutputStream fos = new FileOutputStream(f)) { fos.write(init.toByteArray()); } ByteArrayOutputStream o = new ByteArrayOutputStream(); ZipArchiveEntry zae; try (ZipFile zf = new ZipFile(f); ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) { zae = zf.getEntry("test1.txt"); zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae)); } byte[] data = o.toByteArray(); byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6); "<AssertPlaceHolder>"; byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8); "<AssertPlaceHolder>"; int cdhStart = findCentralDirectory(data); byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8); "<AssertPlaceHolder>"; byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10); "<AssertPlaceHolder>"; int ddStart = cdhStart - 16; "<AssertPlaceHolder>"; long crcFromLFH = ZipLong.getValue(data, 14); long cSizeFromLFH = ZipLong.getValue(data, 18); long sizeFromLFH = ZipLong.getValue(data, 22); "<AssertPlaceHolder>"; long crcFromCDH = ZipLong.getValue(data, cdhStart + 16); "<AssertPlaceHolder>"; long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20); "<AssertPlaceHolder>"; long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24); "<AssertPlaceHolder>"; } public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream) throws IOException{ final ZipArchiveEntry ae = new ZipArchiveEntry(entry); if (hasZip64Extra(ae)) { ae.removeExtraField(Zip64ExtendedInformationExtraField.HEADER_ID); } final boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN && ae.getSize() != ArchiveEntry.SIZE_UNKNOWN && ae.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN; putArchiveEntry(ae, is2PhaseSource); copyFromZipInputStream(rawStream); closeCopiedEntry(is2PhaseSource); }
@Test public void properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown() throws Exception{ try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new ByteArrayInputStream(new byte[0]))) { ZipArchiveEntry e = new ZipArchiveEntry("test"); e.setMethod(ZipMethod.DEFLATED.getCode()); "<AssertPlaceHolder>"; e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode()); "<AssertPlaceHolder>"; e.setMethod(ZipMethod.BZIP2.getCode()); "<AssertPlaceHolder>"; } } public boolean canReadEntryData(final ArchiveEntry ae){ if (ae instanceof ZipArchiveEntry) { final ZipArchiveEntry ze = (ZipArchiveEntry) ae; return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze); } return false; }
@Test public void testNegativeZero() throws Exception{ JsonReader reader = new JsonReader(reader("[-0]")); reader.setLenient(false); reader.beginArray(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public JsonWriter beginArray() throws IOException{ writeDeferredName(); return open(EMPTY_ARRAY, "["); }
@Test public void testNegativeZero() throws Exception{ JsonReader reader = new JsonReader(reader("[-0]")); reader.setLenient(false); reader.beginArray(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } private int peek(){ if (stackSize == 0) { throw new IllegalStateException("JsonWriter is closed."); } return stack[stackSize - 1]; }
@Test public void testNegativeZero() throws Exception{ JsonReader reader = new JsonReader(reader("[-0]")); reader.setLenient(false); reader.beginArray(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String nextString() throws IOException{ int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('"'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException("Expected a string but was " + peek() + locationString()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }
@Test public void testDoubleSupertype(){ "<AssertPlaceHolder>"; } public static WildcardType supertypeOf(Type bound){ Type[] lowerBounds; lowerBounds = new Type[] { bound }; return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); }
@Test public void testSubSupertype(){ "<AssertPlaceHolder>"; } public static WildcardType subtypeOf(Type bound){ Type[] upperBounds; upperBounds = new Type[] { bound }; return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); }
@Test public void testSubSupertype(){ "<AssertPlaceHolder>"; } public static WildcardType supertypeOf(Type bound){ Type[] lowerBounds; lowerBounds = new Type[] { bound }; return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); }
@Test public void testDoubleSubtype(){ "<AssertPlaceHolder>"; } public static WildcardType subtypeOf(Type bound){ Type[] upperBounds; upperBounds = new Type[] { bound }; return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); }
@Test public void testSuperSubtype(){ "<AssertPlaceHolder>"; } public static WildcardType subtypeOf(Type bound){ Type[] upperBounds; upperBounds = new Type[] { bound }; return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); }
@Test public void testSuperSubtype(){ "<AssertPlaceHolder>"; } public static WildcardType supertypeOf(Type bound){ Type[] lowerBounds; lowerBounds = new Type[] { bound }; return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); }
@Test public void testNullColumn() throws Exception{ "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler()); try { _configAndWriteValue(_jsonFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testConversionOfPojos() throws Exception{ final Issue467Bean input = new Issue467Bean(13); final String EXP = "{\"x\":13}"; String json = MAPPER.writeValueAsString(input); "<AssertPlaceHolder>"; JsonNode tree = MAPPER.valueToTree(input); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testArrayIndexForExceptions() throws Exception{ final String OBJECTS_JSON = "[ \"KEY2\", false ]"; try { MAPPER.readValue(OBJECTS_JSON, Key[].class); fail("Should not pass"); } catch (JsonMappingException e) { verifyException(e, "Can not deserialize"); List<JsonMappingException.Reference> refs = e.getPath(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } try { MAPPER.readValue("[ \"xyz\", { } ]", String[].class); fail("Should not pass"); } catch (JsonMappingException e) { verifyException(e, "Can not deserialize"); List<JsonMappingException.Reference> refs = e.getPath(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } try { MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class); fail("Should not pass"); } catch (JsonMappingException e) { verifyException(e, "Can not deserialize"); List<JsonMappingException.Reference> refs = e.getPath(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } } public Integer getIndex(){ return _index; }
@Test public void testArrayIndexForExceptions() throws Exception{ final String OBJECTS_JSON = "[ \"KEY2\", false ]"; try { MAPPER.readValue(OBJECTS_JSON, Key[].class); fail("Should not pass"); } catch (JsonMappingException e) { verifyException(e, "Can not deserialize"); List<JsonMappingException.Reference> refs = e.getPath(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } try { MAPPER.readValue("[ \"xyz\", { } ]", String[].class); fail("Should not pass"); } catch (JsonMappingException e) { verifyException(e, "Can not deserialize"); List<JsonMappingException.Reference> refs = e.getPath(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } try { MAPPER.readValue("{\"keys\":"+OBJECTS_JSON+"}", KeyListBean.class); fail("Should not pass"); } catch (JsonMappingException e) { verifyException(e, "Can not deserialize"); List<JsonMappingException.Reference> refs = e.getPath(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } } public String getFieldName(){ return _fieldName; }
@Test public void testIssue705() throws Exception{ Issue705Bean input = new Issue705Bean("key", "value"); String json = MAPPER.writeValueAsString(input); "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testLocalType728() throws Exception{ TypeFactory tf = TypeFactory.defaultInstance(); Method m = Issue728.class.getMethod("method", CharSequence.class); "<AssertPlaceHolder>"; JavaType t = tf.constructType(m.getReturnType()); "<AssertPlaceHolder>"; t = tf.constructType(m.getGenericReturnType()); "<AssertPlaceHolder>"; t = tf.constructType(m.getParameterTypes()[0]); "<AssertPlaceHolder>"; t = tf.constructType(m.getGenericParameterTypes()[0]); "<AssertPlaceHolder>"; } public Type getGenericReturnType(){ return _method.getGenericReturnType(); }
@Test public void testLocalType728() throws Exception{ TypeFactory tf = TypeFactory.defaultInstance(); Method m = Issue728.class.getMethod("method", CharSequence.class); "<AssertPlaceHolder>"; JavaType t = tf.constructType(m.getReturnType()); "<AssertPlaceHolder>"; t = tf.constructType(m.getGenericReturnType()); "<AssertPlaceHolder>"; t = tf.constructType(m.getParameterTypes()[0]); "<AssertPlaceHolder>"; t = tf.constructType(m.getGenericParameterTypes()[0]); "<AssertPlaceHolder>"; } public Type[] getGenericParameterTypes(){ return _method.getGenericParameterTypes(); }
@Test public void testMixinWithBundles() throws Exception{ ObjectMapper mapper = new ObjectMapper().addMixIn(Foo.class, FooMixin.class); String result = mapper.writeValueAsString(new Foo("result")); "<AssertPlaceHolder>"; } public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource){ _mixInAnnotations.put(new ClassKey(target), mixinSource); return this; }
@Test public void testMapToProperties() throws Exception{ Bean bean = new Bean(); bean.A = 129; bean.B = "13"; Properties props = MAPPER.convertValue(bean, Properties.class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public BeanProperty getProperty(){ return _property; }
@Test public void testMapToProperties() throws Exception{ Bean bean = new Bean(); bean.A = 129; bean.B = "13"; Properties props = MAPPER.convertValue(bean, Properties.class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException{ if (fromValue == null) return null; return (T) _convert(fromValue, toValueType); }
@Test public void testReadProperties() throws Exception{ Properties props = MAPPER.readValue(aposToQuotes("{'a':'foo', 'b':123, 'c':true}"), Properties.class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException{ return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType); }
@Test public void testProperties(){ TypeFactory tf = TypeFactory.defaultInstance(); JavaType t = tf.constructType(Properties.class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public JavaType constructType(Type type, Class<?> context){ TypeBindings b = (context == null) ? null : new TypeBindings(this, context); return _constructType(type, b); }
@Test public void testEnumWithJsonPropertyRename() throws Exception{ String json = MAPPER.writeValueAsString(new EnumWithPropertyAnno[] { EnumWithPropertyAnno.B, EnumWithPropertyAnno.A }); "<AssertPlaceHolder>"; EnumWithPropertyAnno[] result = MAPPER.readValue(json, EnumWithPropertyAnno[].class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testEnumWithJsonPropertyRename() throws Exception{ String json = MAPPER.writeValueAsString(new EnumWithPropertyAnno[] { EnumWithPropertyAnno.B, EnumWithPropertyAnno.A }); "<AssertPlaceHolder>"; EnumWithPropertyAnno[] result = MAPPER.readValue(json, EnumWithPropertyAnno[].class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException{ return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType); }
@Test public void testEmptyInclusionScalars() throws IOException{ ObjectMapper defMapper = MAPPER; ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY); StringWrapper str = new StringWrapper(""); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; IntWrapper zero = new IntWrapper(0); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testDateFormatConfig() throws Exception{ ObjectMapper mapper = new ObjectMapper(); TimeZone tz1 = TimeZone.getTimeZone("America/Los_Angeles"); TimeZone tz2 = TimeZone.getTimeZone("Central Standard Time"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; if (tz1.equals(tz2)) { fail(); } mapper.setTimeZone(tz1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); f.setTimeZone(tz2); mapper.setDateFormat(f); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public TimeZone getTimeZone(){ return _config.getTimeZone(); }
@Test public void testExplicitMapType() throws Exception{ JavaType key = SimpleType.construct(String.class); JavaType elem = SimpleType.construct(Point.class); JavaType t = MapType.construct(Map.class, key, elem); final String json = aposToQuotes("{'x':{'x':3,'y':5}}"); Map<String,Point> m = MAPPER.readValue(json, t); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Object ob = m.values().iterator().next(); "<AssertPlaceHolder>"; Point p = (Point) ob; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static PropertyMetadata construct(boolean req, String desc, Integer index, String defaultValue){ if (desc != null || index != null || defaultValue != null) { return new PropertyMetadata(req, desc, index, defaultValue); } return req ? STD_REQUIRED : STD_OPTIONAL; }
@Test public void testExplicitCollectionType() throws Exception{ JavaType elem = SimpleType.construct(Point.class); JavaType t = CollectionType.construct(List.class, elem); final String json = aposToQuotes("[ {'x':1,'y':2}, {'x':3,'y':6 }]"); List<Point> l = MAPPER.readValue(json, t); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Object ob = l.get(0); "<AssertPlaceHolder>"; Point p = (Point) ob; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static PropertyMetadata construct(boolean req, String desc, Integer index, String defaultValue){ if (desc != null || index != null || defaultValue != null) { return new PropertyMetadata(req, desc, index, defaultValue); } return req ? STD_REQUIRED : STD_OPTIONAL; }
@Test public void testExternalTypeId() throws Exception{ TypeReference<?> type = new TypeReference<Message<FooPayload>>() { }; Message<?> msg = MAPPER.readValue(aposToQuotes("{ 'type':'foo', 'payload': {} }"), type); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; msg = MAPPER.readValue(aposToQuotes("{'payload': {}, 'type':'foo' }"), type); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException{ return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); }
@Test public void testEnumsWithJsonPropertyAsKey() throws Exception{ EnumMap<EnumWithJsonProperty,String> input = new EnumMap<EnumWithJsonProperty,String>(EnumWithJsonProperty.class); input.put(EnumWithJsonProperty.A, "b"); "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testIssue1351() throws Exception{ ObjectMapper mapper = new ObjectMapper(); mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testEnumPropertyAsNumber() throws Exception{ "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testWithUnwrappedAndCreatorSingleParameterAtBeginning() throws Exception{ final String json = aposToQuotes("{'person_id':1234,'first_name':'John','last_name':'Doe','years_old':30,'living':true}"); final ObjectMapper mapper = new ObjectMapper(); Person person = mapper.readValue(json, Person.class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException{ return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); }
@Test public void testWithUnwrappedAndCreatorMultipleParametersAtBeginning() throws Exception{ final String json = aposToQuotes("{'animal_id':1234,'living':true,'first_name':'John','last_name':'Doe','years_old':30}"); final ObjectMapper mapper = new ObjectMapper(); Animal animal = mapper.readValue(json, Animal.class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException{ return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); }
@Test public void testWithUnwrappedAndCreatorSingleParameterInMiddle() throws Exception{ final String json = aposToQuotes("{'first_name':'John','last_name':'Doe','person_id':1234,'years_old':30,'living':true}"); final ObjectMapper mapper = new ObjectMapper(); Person person = mapper.readValue(json, Person.class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException{ return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); }
@Test public void testWithUnwrappedAndCreatorMultipleParametersInMiddle() throws Exception{ final String json = aposToQuotes("{'first_name':'John','animal_id':1234,'last_name':'Doe','living':true,'years_old':30}"); final ObjectMapper mapper = new ObjectMapper(); Animal animal = mapper.readValue(json, Animal.class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException{ return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); }
@Test public void testIssue1607() throws Exception{ String json = MAPPER.writeValueAsString(new ReallyAlwaysContainer()); "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testIgnoreGetterNotSetter1595() throws Exception{ ObjectMapper mapper = new ObjectMapper(); Simple1595 config = new Simple1595(); config.setId(123); config.setName("jack"); String json = mapper.writeValueAsString(config); "<AssertPlaceHolder>"; Simple1595 des = mapper.readValue(aposToQuotes("{'id':123,'name':'jack'}"), Simple1595.class); "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testBasePropertiesIncludedWhenSerializingSubWhenSubTypeLoadedAfterBaseType() throws IOException{ TypeFactory tf = TypeFactory.defaultInstance(); tf.constructType(Base.class); tf.constructType(Sub.class); Sub sub = new Sub(); String serialized = objectMapper().writeValueAsString(sub); "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testBasePropertiesIncludedWhenSerializingSubWhenSubTypeLoadedAfterBaseType() throws IOException{ TypeFactory tf = TypeFactory.defaultInstance(); tf.constructType(Base.class); tf.constructType(Sub.class); Sub sub = new Sub(); String serialized = objectMapper().writeValueAsString(sub); "<AssertPlaceHolder>"; } public JavaType constructType(Type type, JavaType contextType){ TypeBindings bindings; if (contextType == null) { bindings = TypeBindings.emptyBindings(); } else { bindings = contextType.getBindings(); if (type.getClass() != Class.class) { while (bindings.isEmpty()) { contextType = contextType.getSuperClass(); if (contextType == null) { break; } bindings = contextType.getBindings(); } } } return _fromAny(null, type, bindings); }
@Test public void testFormatWithoutPattern() throws Exception{ ObjectMapper mapper = new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss")); String json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L)); "<AssertPlaceHolder>"; } public ObjectMapper setDateFormat(DateFormat dateFormat){ _deserializationConfig = _deserializationConfig.with(dateFormat); _serializationConfig = _serializationConfig.with(dateFormat); return this; }
@Test public void testFormatWithoutPattern() throws Exception{ ObjectMapper mapper = new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss")); String json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L)); "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testSuperClassWithReferencedJavaType(){ TypeFactory tf = objectMapper().getTypeFactory(); tf.constructType(Base.class); JavaType subType = tf.constructType(Sub.class); JavaType baseTypeFromSub = subType.getSuperClass(); "<AssertPlaceHolder>"; } public JavaType getSuperClass(){ return _superClass; }
@Test public void testSuperClassWithReferencedJavaType(){ TypeFactory tf = objectMapper().getTypeFactory(); tf.constructType(Base.class); JavaType subType = tf.constructType(Sub.class); JavaType baseTypeFromSub = subType.getSuperClass(); "<AssertPlaceHolder>"; } public JavaType constructType(Type type, JavaType contextType){ TypeBindings bindings; if (contextType == null) { bindings = TypeBindings.emptyBindings(); } else { bindings = contextType.getBindings(); if (type.getClass() != Class.class) { while (bindings.isEmpty()) { contextType = contextType.getSuperClass(); if (contextType == null) { break; } bindings = contextType.getBindings(); } } } return _fromAny(null, type, bindings); }
@Test public void testBasePropertiesIncludedWhenSerializingSubWhenSubTypeLoadedAfterBaseType() throws IOException{ TypeFactory tf = TypeFactory.defaultInstance(); tf.constructType(Base.class); tf.constructType(Sub.class); Sub sub = new Sub(); String serialized = objectMapper().writeValueAsString(sub); "<AssertPlaceHolder>"; } public String writeValueAsString(Object value) throws JsonProcessingException{ SegmentedStringWriter sw = new SegmentedStringWriter(_generatorFactory._getBufferRecycler()); try { _configAndWriteValue(_generatorFactory.createGenerator(sw), value); } catch (JsonProcessingException e) { throw e; } catch (IOException e) { throw JsonMappingException.fromUnexpectedIOE(e); } return sw.getAndClear(); }
@Test public void testBasePropertiesIncludedWhenSerializingSubWhenSubTypeLoadedAfterBaseType() throws IOException{ TypeFactory tf = TypeFactory.defaultInstance(); tf.constructType(Base.class); tf.constructType(Sub.class); Sub sub = new Sub(); String serialized = objectMapper().writeValueAsString(sub); "<AssertPlaceHolder>"; } public JavaType constructType(Type type, JavaType contextType){ TypeBindings bindings; if (contextType == null) { bindings = TypeBindings.emptyBindings(); } else { bindings = contextType.getBindings(); if (type.getClass() != Class.class) { while (bindings.isEmpty()) { contextType = contextType.getSuperClass(); if (contextType == null) { break; } bindings = contextType.getBindings(); } } } return _fromAny(null, type, bindings); }
@Test public void testDateUtilISO8601NoTimezoneNonDefault() throws Exception{ ObjectReader r = MAPPER.readerFor(Date.class); TimeZone tz = TimeZone.getTimeZone("GMT-2"); Date date1 = r.with(tz) .readValue(quote("1970-01-01T00:00:00.000")); Date date2 = r.with(TimeZone.getTimeZone("GMT+5")) .readValue(quote("1970-01-01T00:00:00.000-02:00")); "<AssertPlaceHolder>"; Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT")); c.setTime(date1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public TimeZone getTimeZone(){ return _config.getTimeZone(); }
@Test public void testCanonicalNames(){ TypeFactory tf = TypeFactory.defaultInstance(); JavaType t = tf.constructType(java.util.Calendar.class); String can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; t = tf.constructType(java.util.ArrayList.class); can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; t = tf.constructType(java.util.TreeMap.class); can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; t = tf.constructType(new TypeReference<AtomicReference<Long>>() { }); can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; t = tf.constructFromCanonical("java.util.List"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String toCanonical(){ String str = _canonicalName; if (str == null) { str = buildCanonicalName(); } return str; }
@Test public void testCanonicalNames(){ TypeFactory tf = TypeFactory.defaultInstance(); JavaType t = tf.constructType(java.util.Calendar.class); String can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; t = tf.constructType(java.util.ArrayList.class); can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; t = tf.constructType(java.util.TreeMap.class); can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; t = tf.constructType(new TypeReference<AtomicReference<Long>>() { }); can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; t = tf.constructFromCanonical("java.util.List"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; can = t.toCanonical(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException{ return _parser.parse(canonical); }
@Test public void testIssue2088UnwrappedFieldsAfterLastCreatorProp() throws Exception{ Issue2088Bean bean = MAPPER.readValue("{\"x\":1,\"a\":2,\"y\":3,\"b\":4}", Issue2088Bean.class); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public <T> T readValue(File src, JavaType valueType) throws IOException, JsonParseException, JsonMappingException{ return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType); }
@Test public void testSqlDateConfigOverride() throws Exception{ ObjectMapper mapper = newObjectMapper(); mapper.configOverride(java.sql.Date.class) .setFormat(JsonFormat.Value.forPattern("yyyy+MM+dd")); "<AssertPlaceHolder>"; } public MutableConfigOverride configOverride(Class<?> type){ return _configOverrides.findOrCreateOverride(type); }
@Test @Test public void createsStructureFromBodySnippet(){ String html = "foo <b>bar</b> baz"; Document doc = Jsoup.parse(html); "<AssertPlaceHolder>"; } private Document parse(){ while (!tq.isEmpty()) { if (tq.matches("<!--")) { parseComment(); } else if (tq.matches("<![CDATA[")) { parseCdata(); } else if (tq.matches("<?") || tq.matches("<!")) { parseXmlDecl(); } else if (tq.matches("</")) { parseEndTag(); } else if (tq.matches("<")) { parseStartTag(); } else { parseTextNode(); } } return doc.normalise(); }
@Test @Test public void handlesTextAfterData(){ String h = "<html><body>pre <script>inner</script> aft</body></html>"; Document doc = Jsoup.parse(h); "<AssertPlaceHolder>"; } private Document parse(){ while (!tq.isEmpty()) { if (tq.matches("<!--")) { parseComment(); } else if (tq.matches("<![CDATA[")) { parseCdata(); } else if (tq.matches("<?") || tq.matches("<!")) { parseXmlDecl(); } else if (tq.matches("</")) { parseEndTag(); } else if (tq.matches("<")) { parseStartTag(); } else { parseTextNode(); } } return doc.normalise(); }
@Test @Test public void testAppendRowToTable(){ Document doc = Jsoup.parse("<table><tr><td>1</td></tr></table>"); Element table = doc.select("table").first(); table.append("<tr><td>2</td></tr>"); "<AssertPlaceHolder>"; } public Element append(String html){ Validate.notNull(html); Element fragment = Parser.parseBodyFragment(html, baseUri).body(); for (Node node : fragment.childNodes()) { node.parentNode = null; appendChild(node); } return this; }
@Test @Test public void testPrependRowToTable(){ Document doc = Jsoup.parse("<table><tr><td>1</td></tr></table>"); Element table = doc.select("table").first(); table.prepend("<tr><td>2</td></tr>"); "<AssertPlaceHolder>"; } public Element prepend(String html){ Validate.notNull(html); Element fragment = Parser.parseBodyFragment(html, baseUri).body(); List<Node> nodes = fragment.childNodes(); for (int i = nodes.size() - 1; i >= 0; i--) { Node node = nodes.get(i); node.parentNode = null; prependChild(node); } return this; }
@Test @Test public void handlesNestedImplicitTable(){ Document doc = Jsoup.parse("<table><td>1</td></tr> <td>2</td></tr> <td> <table><td>3</td> <td>4</td></table> <tr><td>5</table>"); "<AssertPlaceHolder>"; } private Document parse(){ while (!tq.isEmpty()) { if (tq.matches("<!--")) { parseComment(); } else if (tq.matches("<![CDATA[")) { parseCdata(); } else if (tq.matches("<?") || tq.matches("<!")) { parseXmlDecl(); } else if (tq.matches("</")) { parseEndTag(); } else if (tq.matches("<")) { parseStartTag(); } else { parseTextNode(); } } return doc.normalise(); }
@Test @Test public void absHandlesRelativeQuery(){ Document doc = Jsoup.parse("<a href='?foo'>One</a> <a href='bar.html?foo'>Two</a>", "http://jsoup.org/path/file?bar"); Element a1 = doc.select("a").first(); "<AssertPlaceHolder>"; Element a2 = doc.select("a").get(1); "<AssertPlaceHolder>"; } public static Document parse(URL url, int timeoutMillis) throws IOException{ Connection con = HttpConnection.connect(url); con.timeout(timeoutMillis); return con.get(); }
@Test @Test public void absHandlesRelativeQuery(){ Document doc = Jsoup.parse("<a href='?foo'>One</a> <a href='bar.html?foo'>Two</a>", "http://jsoup.org/path/file?bar"); Element a1 = doc.select("a").first(); "<AssertPlaceHolder>"; Element a2 = doc.select("a").get(1); "<AssertPlaceHolder>"; } public Elements select(String query){ return Selector.select(query, this); }
@Test @Test public void absHandlesRelativeQuery(){ Document doc = Jsoup.parse("<a href='?foo'>One</a> <a href='bar.html?foo'>Two</a>", "http://jsoup.org/path/file?bar"); Element a1 = doc.select("a").first(); "<AssertPlaceHolder>"; Element a2 = doc.select("a").get(1); "<AssertPlaceHolder>"; } public Element first(){ return contents.isEmpty() ? null : contents.get(0); }
@Test @Test public void testPseudoHas(){ Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>"); Elements divs1 = doc.select("div:has(span)"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Elements divs2 = doc.select("div:has([class]"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Elements divs3 = doc.select("div:has(span, p)"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Elements els1 = doc.body().select(":has(p)"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static Document parse(URL url, int timeoutMillis) throws IOException{ Connection con = HttpConnection.connect(url); con.timeout(timeoutMillis); return con.get(); }
@Test @Test public void testPseudoHas(){ Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>"); Elements divs1 = doc.select("div:has(span)"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Elements divs2 = doc.select("div:has([class]"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Elements divs3 = doc.select("div:has(span, p)"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Elements els1 = doc.body().select(":has(p)"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Elements select(String query){ return Selector.select(query, this); }
@Test @Test public void testPseudoHas(){ Document doc = Jsoup.parse("<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>"); Elements divs1 = doc.select("div:has(span)"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Elements divs2 = doc.select("div:has([class]"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Elements divs3 = doc.select("div:has(span, p)"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Elements els1 = doc.body().select(":has(p)"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element first(){ return contents.isEmpty() ? null : contents.get(0); }
@Test @Test public void handlesAbsPrefixOnHasAttr(){ Document doc = Jsoup.parse("<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org/'>Two</a>"); Element one = doc.select("#1").first(); Element two = doc.select("#2").first(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static Document parse(URL url, int timeoutMillis) throws IOException{ Connection con = HttpConnection.connect(url); con.timeout(timeoutMillis); return con.get(); }
@Test @Test public void handlesAbsPrefixOnHasAttr(){ Document doc = Jsoup.parse("<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org/'>Two</a>"); Element one = doc.select("#1").first(); Element two = doc.select("#2").first(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Elements select(String query){ return Selector.select(query, this); }
@Test @Test public void handlesAbsPrefixOnHasAttr(){ Document doc = Jsoup.parse("<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org/'>Two</a>"); Element one = doc.select("#1").first(); Element two = doc.select("#2").first(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element first(){ return contents.isEmpty() ? null : contents.get(0); }
@Test @Test public void handlesAbsPrefix(){ Document doc = Jsoup.parse("<a href=/foo>Hello</a>", "http://jsoup.org/"); Element a = doc.select("a").first(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static Document parse(URL url, int timeoutMillis) throws IOException{ Connection con = HttpConnection.connect(url); con.timeout(timeoutMillis); return con.get(); }
@Test @Test public void handlesAbsPrefix(){ Document doc = Jsoup.parse("<a href=/foo>Hello</a>", "http://jsoup.org/"); Element a = doc.select("a").first(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Elements select(String query){ return Selector.select(query, this); }
@Test @Test public void handlesAbsPrefix(){ Document doc = Jsoup.parse("<a href=/foo>Hello</a>", "http://jsoup.org/"); Element a = doc.select("a").first(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element first(){ return contents.isEmpty() ? null : contents.get(0); }
@Test @Test public void absAttr(){ Document doc = Jsoup.parse("<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org'>Two</a>"); Elements one = doc.select("#1"); Elements two = doc.select("#2"); Elements both = doc.select("a"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Elements attr(String attributeKey, String attributeValue){ for (Element element : contents) { element.attr(attributeKey, attributeValue); } return this; }
@Test @Test public void hasAbsAttr(){ Document doc = Jsoup.parse("<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org'>Two</a>"); Elements one = doc.select("#1"); Elements two = doc.select("#2"); Elements both = doc.select("a"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean hasAttr(String attributeKey){ for (Element element : contents) { if (element.hasAttr(attributeKey)) return true; } return false; }
@Test @Test public void parsesUnterminatedTextarea(){ Document doc = Jsoup.parse("<body><p><textarea>one<p>two"); Element t = doc.select("textarea").first(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } Document parse(String input, String baseUri){ state = TreeBuilderState.Initial; initialiseParse(input, baseUri); runParser(); return doc; }
@Test @Test public void parsesUnterminatedTextarea(){ Document doc = Jsoup.parse("<body><p><textarea>one<p>two"); Element t = doc.select("textarea").first(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Elements select(String query){ return Selector.select(query, this); }
@Test @Test public void handlesUnclosedTitle(){ Document one = Jsoup.parse("<title>One <b>Two <b>Three</TITLE><p>Test</p>"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Document two = Jsoup.parse("<title>One<b>Two <p>Test</p>"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } Document parse(String input, String baseUri){ state = TreeBuilderState.Initial; initialiseParse(input, baseUri); runParser(); return doc; }
@Test @Test public void handlesUnclosedTitle(){ Document one = Jsoup.parse("<title>One <b>Two <b>Three</TITLE><p>Test</p>"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Document two = Jsoup.parse("<title>One<b>Two <p>Test</p>"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Elements select(String query){ return Selector.select(query, this); }
@Test @Test public void outerHtmlGeneration(){ DocumentType html5 = new DocumentType("html", "", "", ""); "<AssertPlaceHolder>"; DocumentType publicDocType = new DocumentType("html", "-//IETF//DTD HTML//", "", ""); "<AssertPlaceHolder>"; DocumentType systemDocType = new DocumentType("html", "", "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", ""); "<AssertPlaceHolder>"; DocumentType combo = new DocumentType("notHtml", "--public", "--system", ""); "<AssertPlaceHolder>"; } public String outerHtml(){ return super.html(); }
@Test @Test public void handles0CharacterAsText(){ Document doc = Jsoup.parse("0<p>0</p>"); "<AssertPlaceHolder>"; } Document parse(String input, String baseUri){ state = TreeBuilderState.Initial; initialiseParse(input, baseUri); runParser(); return doc; }
@Test @Test public void handleCarriageReturnAsLineFeed(){ String in = "one \r two \r\n three"; CharacterReader r = new CharacterReader(in); String first = r.consumeTo('\n'); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } String consumeTo(String seq){ int offset = input.indexOf(seq, pos); if (offset != -1) { String consumed = input.substring(pos, offset); pos += consumed.length(); return consumed; } else { return consumeToEnd(); } }
@Test @Test public void handleCarriageReturnAsLineFeed(){ String in = "one \r two \r\n three"; CharacterReader r = new CharacterReader(in); String first = r.consumeTo('\n'); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } String consumeToEnd(){ String data = input.substring(pos, input.length() - 1); pos = input.length(); return data; }
@Test @Test public void consumeToEnd(){ String in = "one two three"; CharacterReader r = new CharacterReader(in); String toEnd = r.consumeToEnd(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } String consumeToEnd(){ String data = input.substring(pos, input.length() - 1); pos = input.length(); return data; }
@Test @Test public void handlesNewlinesAndWhitespaceInTag(){ Document doc = Jsoup.parse("<a \n href=\"one\" \r\n id=\"two\" \f >"); "<AssertPlaceHolder>"; } Document parse(String input, String baseUri){ state = TreeBuilderState.Initial; initialiseParse(input, baseUri); runParser(); return doc; }
@Test @Test public void handlesCustomProtocols(){ String html = "<img src='cid:12345' /> <img src='data:gzzt' />"; String dropped = Jsoup.clean(html, Whitelist.basicWithImages()); "<AssertPlaceHolder>"; String preserved = Jsoup.clean(html, Whitelist.basicWithImages().addProtocols("img", "src", "cid", "data")); "<AssertPlaceHolder>"; } public Whitelist addProtocols(String tag, String key, String... protocols){ Validate.notEmpty(tag); Validate.notEmpty(key); Validate.notNull(protocols); TagName tagName = TagName.valueOf(tag); AttributeKey attrKey = AttributeKey.valueOf(key); Map<AttributeKey, Set<Protocol>> attrMap; Set<Protocol> protSet; if (this.protocols.containsKey(tagName)) { attrMap = this.protocols.get(tagName); } else { attrMap = new HashMap<AttributeKey, Set<Protocol>>(); this.protocols.put(tagName, attrMap); } if (attrMap.containsKey(attrKey)) { protSet = attrMap.get(attrKey); } else { protSet = new HashSet<Protocol>(); attrMap.put(attrKey, protSet); } for (String protocol : protocols) { Validate.notEmpty(protocol); Protocol prot = Protocol.valueOf(protocol); protSet.add(prot); } return this; }
@Test @Test public void elementIsNotASiblingOfItself(){ Document doc = Jsoup.parse("<div><p>One<p>Two<p>Three</div>"); Element p2 = doc.select("p").get(1); "<AssertPlaceHolder>"; Elements els = p2.siblingElements(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Elements siblingElements(){ return parent().children(); }
@Test @Test public void nodeIsNotASiblingOfItself(){ Document doc = Jsoup.parse("<div><p>One<p>Two<p>Three</div>"); Element p2 = doc.select("p").get(1); "<AssertPlaceHolder>"; List<Node> nodes = p2.siblingNodes(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public List<Node> siblingNodes(){ return parent().childNodes(); }
@Test @Test public void handlesQuotesInCommentsInScripts(){ String html = "<script>\n" + "  <!--\n" + "    document.write('</scr' + 'ipt>');\n" + "  // -->\n" + "</script>"; Document node = Jsoup.parseBodyFragment(html); "<AssertPlaceHolder>"; } public static Document parseBodyFragment(String bodyHtml, String baseUri){ Document doc = Document.createShell(baseUri); Element body = doc.body(); List<Node> nodeList = parseFragment(bodyHtml, body, baseUri); Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); for (Node node : nodes) { body.appendChild(node); } return doc; }
@Test @Test public void preservesSpaceInTextArea(){ Document doc = Jsoup.parse("<textarea>\n\tOne\n\tTwo\n\tThree\n</textarea>"); String expect = "One\n\tTwo\n\tThree"; Element el = doc.select("textarea").first(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } Document parse(String input, String baseUri, ParseErrorList errors){ initialiseParse(input, baseUri, errors); runParser(); return doc; }
@Test public void testCharset(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } static String getCharsetFromContentType(String contentType){ if (contentType == null) return null; Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); charset = charset.toUpperCase(Locale.ENGLISH); return charset; } return null; }
@Test @Test public void testQuotedCharset(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } static String getCharsetFromContentType(String contentType){ if (contentType == null) return null; Matcher m = charsetPattern.matcher(contentType); if (m.find()) { String charset = m.group(1).trim(); charset = charset.toUpperCase(Locale.ENGLISH); return charset; } return null; }
@Test @Test public void noSpuriousDecodes(){ String string = "http://www.foo.com?a=1&num_rooms=1&children=0&int=VA&b=2"; "<AssertPlaceHolder>"; } static String unescape(String string, boolean strict){ if (!string.contains("&")) return string; Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string); StringBuffer accum = new StringBuffer(string.length()); while (m.find()) { int charval = -1; String num = m.group(3); if (num != null) { try { int base = m.group(2) != null ? 16 : 10; charval = Integer.valueOf(num, base); } catch (NumberFormatException e) { } } else { String name = m.group(1); if (full.containsKey(name)) charval = full.get(name); } if (charval != -1 || charval > 0xFFFF) { String c = Character.toString((char) charval); m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); } } m.appendTail(accum); return accum.toString(); }
@Test @Test public void moreAttributeUnescapes(){ String html = "<a href='&wr_id=123&mid-size=true&ok=&wr'>Check</a>"; Elements els = Jsoup.parse(html).select("a"); "<AssertPlaceHolder>"; } public Element attr(String attributeKey, String attributeValue){ super.attr(attributeKey, attributeValue); return this; }
@Test @Test public void moreAttributeUnescapes(){ String html = "<a href='&wr_id=123&mid-size=true&ok=&wr'>Check</a>"; Elements els = Jsoup.parse(html).select("a"); "<AssertPlaceHolder>"; } public Element first(){ return contents.isEmpty() ? null : contents.get(0); }
@Test @Test public void strictAttributeUnescapes(){ String html = "<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>"; Elements els = Jsoup.parse(html).select("a"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element attr(String attributeKey, String attributeValue){ super.attr(attributeKey, attributeValue); return this; }
@Test @Test public void strictAttributeUnescapes(){ String html = "<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>"; Elements els = Jsoup.parse(html).select("a"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element first(){ return contents.isEmpty() ? null : contents.get(0); }
@Test @Test public void strictAttributeUnescapes(){ String html = "<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>"; Elements els = Jsoup.parse(html).select("a"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element last(){ return contents.isEmpty() ? null : contents.get(contents.size() - 1); }
@Test @Test public void relaxedBaseEntityMatchAndStrictExtendedMatch(){ String html = "&amp &quot &reg &icy &hopf &icy; &hopf;"; Document doc = Jsoup.parse(html); doc.outputSettings().escapeMode(Entities.EscapeMode.extended); "<AssertPlaceHolder>"; } public Document outputSettings(OutputSettings outputSettings){ Validate.notNull(outputSettings); this.outputSettings = outputSettings; return this; }
@Test @Test public void relaxedBaseEntityMatchAndStrictExtendedMatch(){ String html = "&amp &quot &reg &icy &hopf &icy; &hopf;"; Document doc = Jsoup.parse(html); doc.outputSettings().escapeMode(Entities.EscapeMode.extended); "<AssertPlaceHolder>"; } public OutputSettings escapeMode(Entities.EscapeMode escapeMode){ this.escapeMode = escapeMode; return this; }
@Test @Test public void testTitles(){ Document noTitle = Jsoup.parse("<p>Hello</p>"); Document withTitle = Jsoup.parse("<title>First</title><title>Ignore</title><p>Hello</p>"); "<AssertPlaceHolder>"; noTitle.title("Hello"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; withTitle.title("Hello"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Document normaliseTitle = Jsoup.parse("<title>   Hello\nthere   \n   now   \n"); "<AssertPlaceHolder>"; } public void title(String title){ Validate.notNull(title); Element titleEl = getElementsByTag("title").first(); if (titleEl == null) { head().appendElement("title").text(title); } else { titleEl.text(title); } }
@Test @Test public void testIsValid(){ String ok = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; String nok1 = "<p><script></script>Not <b>OK</b></p>"; String nok2 = "<p align=right>Test Not <b>OK</b></p>"; String nok3 = "<!-- comment --><p>Not OK</p>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isValid(Document dirtyDocument){ Validate.notNull(dirtyDocument); Document clean = Document.createShell(dirtyDocument.baseUri()); int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); return numDiscarded == 0; }
@Test @Test public void handlesXmlDeclarationAsDeclaration(){ String html = "<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->"; Document doc = Jsoup.parse(html, "", Parser.xmlParser()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } static String normaliseWhitespace(String text){ text = StringUtil.normaliseWhitespace(text); return text; }
@Test @Test public void handlesXmlDeclarationAsDeclaration(){ String html = "<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->"; Document doc = Jsoup.parse(html, "", Parser.xmlParser()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Node childNode(int index){ return childNodes.get(index); }
@Test @Test public void handlesXmlDeclarationAsDeclaration(){ String html = "<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->"; Document doc = Jsoup.parse(html, "", Parser.xmlParser()); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public String nodeName(){ return tag.getName(); }
@Test @Test public void testClonesClassnames(){ Document doc = Jsoup.parse("<div class='one two'></div>"); Element div = doc.select("div").first(); Set<String> classes = div.classNames(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; Element copy = div.clone(); Set<String> copyClasses = copy.classNames(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; copyClasses.add("three"); copyClasses.remove("one"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element classNames(Set<String> classNames){ Validate.notNull(classNames); attributes.put("class", StringUtil.join(classNames, " ")); return this; }
@Test public void testHashAndEquals(){ String doc1 = "<div id=1><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>" + "<div id=2><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>"; Document doc = Jsoup.parse(doc1); Elements els = doc.select("p"); "<AssertPlaceHolder>"; Element e0 = els.get(0); Element e1 = els.get(1); Element e2 = els.get(2); Element e3 = els.get(3); Element e4 = els.get(4); Element e5 = els.get(5); Element e6 = els.get(6); Element e7 = els.get(7); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Elements select(String cssQuery){ return Selector.select(cssQuery, this); }
@Test @Test public void createsFormData(){ String html = "<form><input name='one' value='two'><select name='three'><option value='not'>" + "<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>" + "<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>" + "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" + "<input name='ten' value='text' disabled>" + "</form>"; Document doc = Jsoup.parse(html); FormElement form = (FormElement) doc.select("form").first(); List<Connection.KeyVal> data = form.formData(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public List<Connection.KeyVal> formData(){ ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>(); for (Element el: elements) { if (!el.tag().isFormSubmittable()) continue; String name = el.attr("name"); if (name.length() == 0) continue; String type = el.attr("type"); if ("select".equals(el.tagName())) { Elements options = el.select("option[selected]"); boolean set = false; for (Element option: options) { data.add(HttpConnection.KeyVal.create(name, option.val())); set = true; } if (!set) { Element option = el.select("option").first(); if (option != null) data.add(HttpConnection.KeyVal.create(name, option.val())); } } else if ("checkbox".equalsIgnoreCase(type) || "radio".equalsIgnoreCase(type)) { if (el.hasAttr("checked")) { final String val = el.val(); data.add(HttpConnection.KeyVal.create(name, val)); } } else { data.add(HttpConnection.KeyVal.create(name, el.val())); } } return data; }
@Test @Test public void usesOnForCheckboxValueIfNoValueSet(){ Document doc = Jsoup.parse("<form><input type=checkbox checked name=foo></form>"); FormElement form = (FormElement) doc.select("form").first(); List<Connection.KeyVal> data = form.formData(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public List<Connection.KeyVal> formData(){ ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>(); for (Element el: elements) { if (!el.tag().isFormSubmittable()) continue; String name = el.attr("name"); if (name.length() == 0) continue; String type = el.attr("type"); if ("select".equals(el.tagName())) { Elements options = el.select("option[selected]"); boolean set = false; for (Element option: options) { data.add(HttpConnection.KeyVal.create(name, option.val())); set = true; } if (!set) { Element option = el.select("option").first(); if (option != null) data.add(HttpConnection.KeyVal.create(name, option.val())); } } else if ("checkbox".equalsIgnoreCase(type) || "radio".equalsIgnoreCase(type)) { if (el.hasAttr("checked")) { final String val = el.val(); data.add(HttpConnection.KeyVal.create(name, val)); } } else { data.add(HttpConnection.KeyVal.create(name, el.val())); } } return data; }
@Test @Test public void testElementSiblingIndexSameContent(){ Document doc = Jsoup.parse("<div><p>One</p>...<p>One</p>...<p>One</p>"); Elements ps = doc.select("p"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Integer elementSiblingIndex(){ if (parent() == null) return 0; return indexInList(this, parent().children()); }
@Test @Test public void testGetSiblingsWithDuplicateContent(){ Document doc = Jsoup.parse("<div><p>Hello<p id=1>there<p>this<p>this<p>is<p>an<p id=last>element</div>"); Element p = doc.getElementById("1"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element previousElementSibling(){ if (parentNode == null) return null; List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (index > 0) return siblings.get(index-1); else return null; }
@Test @Test public void testGetSiblingsWithDuplicateContent(){ Document doc = Jsoup.parse("<div><p>Hello<p id=1>there<p>this<p>this<p>is<p>an<p id=last>element</div>"); Element p = doc.getElementById("1"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element nextElementSibling(){ if (parentNode == null) return null; List<Element> siblings = parent().children(); Integer index = indexInList(this, siblings); Validate.notNull(index); if (siblings.size() > index+1) return siblings.get(index+1); else return null; }
@Test @Test public void testGetSiblingsWithDuplicateContent(){ Document doc = Jsoup.parse("<div><p>Hello<p id=1>there<p>this<p>this<p>is<p>an<p id=last>element</div>"); Element p = doc.getElementById("1"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element firstElementSibling(){ List<Element> siblings = parent().children(); return siblings.size() > 1 ? siblings.get(0) : null; }
@Test @Test public void testGetSiblingsWithDuplicateContent(){ Document doc = Jsoup.parse("<div><p>Hello<p id=1>there<p>this<p>this<p>is<p>an<p id=last>element</div>"); Element p = doc.getElementById("1"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element lastElementSibling(){ List<Element> siblings = parent().children(); return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null; }
@Test @Test public void escapesGtInXmlAttributesButNotInHtml(){ String docHtml = "<a title='<p>One</p>'>One</a>"; Document doc = Jsoup.parse(docHtml); Element element = doc.select("a").first(); doc.outputSettings().escapeMode(base); "<AssertPlaceHolder>"; doc.outputSettings().escapeMode(xhtml); "<AssertPlaceHolder>"; } public OutputSettings escapeMode(Entities.EscapeMode escapeMode){ this.escapeMode = escapeMode; return this; }
@Test @Test public void escapesGtInXmlAttributesButNotInHtml(){ String docHtml = "<a title='<p>One</p>'>One</a>"; Document doc = Jsoup.parse(docHtml); Element element = doc.select("a").first(); doc.outputSettings().escapeMode(base); "<AssertPlaceHolder>"; doc.outputSettings().escapeMode(xhtml); "<AssertPlaceHolder>"; } public String outerHtml(){ return super.html(); }
@Test public void appendMustCorrectlyMoveChildrenInsideOneParentElement(){ Document doc = new Document(""); Element body = doc.appendElement("body"); body.appendElement("div1"); body.appendElement("div2"); final Element div3 = body.appendElement("div3"); div3.text("Check"); final Element div4 = body.appendElement("div4"); ArrayList<Element> toMove = new ArrayList<Element>(); toMove.add(div3); toMove.add(div4); body.insertChildren(0, toMove); String result = doc.toString().replaceAll("\\s+", ""); "<AssertPlaceHolder>"; } public Element appendElement(String tagName){ Element child = new Element(Tag.valueOf(tagName), baseUri()); appendChild(child); return child; }
@Test @Test public void testIsValidBodyHtml(){ String ok = "<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>"; String ok1 = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>"; String nok1 = "<p><script></script>Not <b>OK</b></p>"; String nok2 = "<p align=right>Test Not <b>OK</b></p>"; String nok3 = "<!-- comment --><p>Not OK</p>"; String nok4 = "<html><head>Foo</head><body><b>OK</b></body></html>"; String nok5 = "<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>"; String nok6 = "<p>Test <b><a href='http://example.com/'>OK</b></p>"; String nok7 = "</div>What"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isValid(Document dirtyDocument){ Validate.notNull(dirtyDocument); Document clean = Document.createShell(dirtyDocument.baseUri()); int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); return numDiscarded == 0; }
@Test @Test public void testIsValidDocument(){ String ok = "<html><head></head><body><p>Hello</p></body><html>"; String nok = "<html><head><script>woops</script><title>Hello</title></head><body><p>Hello</p></body><html>"; Whitelist relaxed = Whitelist.relaxed(); Cleaner cleaner = new Cleaner(relaxed); Document okDoc = Jsoup.parse(ok); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean isValid(Document dirtyDocument){ Validate.notNull(dirtyDocument); Document clean = Document.createShell(dirtyDocument.baseUri()); int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body()); return numDiscarded == 0; }
@Test @Test public void hasClassCaseInsensitive(){ Elements els = Jsoup.parse("<p Class=One>One <p class=Two>Two <p CLASS=THREE>THREE").select("p"); Element one = els.get(0); Element two = els.get(1); Element thr = els.get(2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean hasClass(String className){ for (Element element : this) { if (element.hasClass(className)) return true; } return false; }
@Test @Test public void testByClassCaseInsensitive(){ String html = "<p Class=foo>One <p Class=Foo>Two <p class=FOO>Three <p class=farp>Four"; Elements elsFromClass = Jsoup.parse(html).select("P.Foo"); Elements elsFromAttr = Jsoup.parse(html).select("p[class=foo]"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Elements select(String query){ return Selector.select(query, this); }
@Test @Test public void caseSensitiveParseTree(){ String html = "<r><X>A</X><y>B</y></r>"; Parser parser = Parser.htmlParser(); parser.settings(ParseSettings.preserveCase); Document doc = parser.parseInput(html, ""); "<AssertPlaceHolder>"; } static String normaliseWhitespace(String text){ text = StringUtil.normaliseWhitespace(text); return text; }
@Test @Test public void removeFormElement(){ String html = "<html>\n" + "  <body> \n" + "      <form action=\"/hello.php\" method=\"post\">\n" + "      User:<input type=\"text\" name=\"user\" />\n" + "      Password:<input type=\"password\" name=\"pass\" />\n" + "      <input type=\"submit\" name=\"login\" value=\"login\" />\n" + "   </form>\n" + "  </body>\n" + "</html>  "; Document doc = Jsoup.parse(html); FormElement form = (FormElement) doc.selectFirst("form"); Element pass = form.selectFirst("input[name=pass]"); pass.remove(); List<Connection.KeyVal> data = form.formData(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public List<Connection.KeyVal> formData(){ ArrayList<Connection.KeyVal> data = new ArrayList<>(); for (Element el: elements) { if (!el.tag().isFormSubmittable()) continue; if (el.hasAttr("disabled")) continue; String name = el.attr("name"); if (name.length() == 0) continue; String type = el.attr("type"); if ("select".equals(el.tagName())) { Elements options = el.select("option[selected]"); boolean set = false; for (Element option: options) { data.add(HttpConnection.KeyVal.create(name, option.val())); set = true; } if (!set) { Element option = el.select("option").first(); if (option != null) data.add(HttpConnection.KeyVal.create(name, option.val())); } } else if ("checkbox".equalsIgnoreCase(type) || "radio".equalsIgnoreCase(type)) { if (el.hasAttr("checked")) { final String val = el.val().length() >  0 ? el.val() : "on"; data.add(HttpConnection.KeyVal.create(name, val)); } } else { data.add(HttpConnection.KeyVal.create(name, el.val())); } } return data; }
@Test @Test public void preSkipsFirstNewline(){ Document doc = Jsoup.parse("<pre>\n\nOne\nTwo\n</pre>"); Element pre = doc.selectFirst("pre"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Element selectFirst(String cssQuery){ return Selector.selectFirst(cssQuery, this); }
@Test @Test public void booleanAttributesAreEmptyStringValues(){ Document doc = Jsoup.parse("<div hidden>"); Attributes attributes = doc.body().child(0).attributes(); "<AssertPlaceHolder>"; Attribute first = attributes.iterator().next(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Attributes attributes(){ if (!hasAttributes()) attributes = new Attributes(); return attributes; }
@Test @Test public void createsFormData(){ String html = "<form><input name='one' value='two'><select name='three'><option value='not'>" + "<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>" + "<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>" + "<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>" + "<input name='ten' value='text' disabled>" + "<input name='eleven' value='text' type='button'>" + "</form>"; Document doc = Jsoup.parse(html); FormElement form = (FormElement) doc.select("form").first(); List<Connection.KeyVal> data = form.formData(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public List<Connection.KeyVal> formData(){ ArrayList<Connection.KeyVal> data = new ArrayList<>(); for (Element el: elements) { if (!el.tag().isFormSubmittable()) continue; if (el.hasAttr("disabled")) continue; String name = el.attr("name"); if (name.length() == 0) continue; String type = el.attr("type"); if ("select".equals(el.normalName())) { Elements options = el.select("option[selected]"); boolean set = false; for (Element option: options) { data.add(HttpConnection.KeyVal.create(name, option.val())); set = true; } if (!set) { Element option = el.select("option").first(); if (option != null) data.add(HttpConnection.KeyVal.create(name, option.val())); } } else if ("checkbox".equalsIgnoreCase(type) || "radio".equalsIgnoreCase(type)) { if (el.hasAttr("checked")) { final String val = el.val().length() >  0 ? el.val() : "on"; data.add(HttpConnection.KeyVal.create(name, val)); } } else { data.add(HttpConnection.KeyVal.create(name, el.val())); } } return data; }
@Test public void testStringCreateNumberEnsureNoPrecisionLoss(){ String shouldBeFloat = "1.23"; String shouldBeDouble = "3.40282354e+38"; String shouldBeBigDecimal = "1.797693134862315759e+308"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static Number createNumber(final String str) throws NumberFormatException{ if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException("A blank string is not a valid number"); } final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"}; int pfxLen = 0; for(final String pfx : hex_prefixes) { if (str.startsWith(pfx)) { pfxLen += pfx.length(); break; } } if (pfxLen > 0) { final int hexDigits = str.length() - pfxLen; if (hexDigits > 16) { return createBigInteger(str); } if (hexDigits > 8) { return createLong(str); } return createInteger(str); } final char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; final int decPos = str.indexOf('.'); final int expPos = str.indexOf('e') + str.indexOf('E') + 1; int numDecimals = 0; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); numDecimals = dec.length(); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + " is not a valid number."); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } final String numeric = str.substring(0, str.length() - 1); final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (final NumberFormatException nfe) { } return createBigInteger(numeric); } throw new NumberFormatException(str + " is not a valid number."); case 'f' : case 'F' : try { final Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (final NumberFormatException nfe) { } case 'd' : case 'D' : try { final Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (final NumberFormatException nfe) { } try { return createBigDecimal(numeric); } catch (final NumberFormatException e) { } default : throw new NumberFormatException(str + " is not a valid number."); } } if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { try { return createInteger(str); } catch (final NumberFormatException nfe) { } try { return createLong(str); } catch (final NumberFormatException nfe) { } return createBigInteger(str); } final boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (final NumberFormatException nfe) { } try { final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (final NumberFormatException nfe) { } return createBigDecimal(str); }
@Test public void testLang882() throws IOException{ final LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { new StringBuffer("one"), new StringBuffer("two") } }); final StringWriter out = new StringWriter(); final int result = lt.translate(new StringBuffer("one"), 0, out); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public final void translate(final CharSequence input, final Writer out) throws IOException{ if (out == null) { throw new IllegalArgumentException("The Writer must not be null"); } if (input == null) { return; } int pos = 0; final int len = input.length(); while (pos < len) { final int consumed = translate(input, pos, out); if (consumed == 0) { final char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { pos += Character.charCount(Character.codePointAt(input, pt)); } } }
@Test public void testCalendarTimezoneRespected(){ String[] availableZones = TimeZone.getAvailableIDs(); TimeZone currentZone = TimeZone.getDefault(); TimeZone anotherZone = null; for (String zone : availableZones) { if (!zone.equals(currentZone.getID())) { anotherZone = TimeZone.getTimeZone(zone); } } "<AssertPlaceHolder>"; final String pattern = "h:mma z"; final Calendar cal = Calendar.getInstance(anotherZone); SimpleDateFormat sdf = new SimpleDateFormat(pattern); sdf.setTimeZone(anotherZone); String expectedValue = sdf.format(cal.getTime()); String actualValue = FastDateFormat.getInstance(pattern).format(cal); "<AssertPlaceHolder>"; } public TimeZone getTimeZone(){ return mTimeZone; }
@Test public void testEquals(){ final CharSequence fooCs = FOO, barCs = BAR, foobarCs = FOOBAR; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public boolean equals(Object obj){ if (obj == this) { return true; } else if (obj == null || obj.getClass() != getClass()) { return false; } else { @SuppressWarnings("unchecked") Range<T> range = (Range<T>) obj; return minimum.equals(range.minimum) && maximum.equals(range.maximum); } }
@Test public void testLang720(){ String input = new StringBuilder("\ud842\udfb7").append("A").toString(); String escaped = StringEscapeUtils.escapeXml(input); "<AssertPlaceHolder>"; } public static final String escapeXml(String input){ return ESCAPE_XML.translate(input); }
@Test public void testIsSameLocalTime_Cal(){ GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone("GMT+1")); GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone("GMT-1")); cal1.set(2004, 6, 9, 13, 45, 0); cal1.set(Calendar.MILLISECOND, 0); cal2.set(2004, 6, 9, 13, 45, 0); cal2.set(Calendar.MILLISECOND, 0); "<AssertPlaceHolder>"; Calendar cal3 = Calendar.getInstance(); Calendar cal4 = Calendar.getInstance(); cal3.set(2004, 6, 9, 4,  0, 0); cal4.set(2004, 6, 9, 16, 0, 0); cal3.set(Calendar.MILLISECOND, 0); cal4.set(Calendar.MILLISECOND, 0); "<AssertPlaceHolder>"; cal2.set(2004, 6, 9, 11, 45, 0); "<AssertPlaceHolder>"; try { DateUtils.isSameLocalTime((Calendar) null, (Calendar) null); fail(); } catch (IllegalArgumentException ex) {} } public static boolean isSameLocalTime(Calendar cal1, Calendar cal2){ if (cal1 == null || cal2 == null) { throw new IllegalArgumentException("The date must not be null"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); }
@Test public void testReducedFactory_int_int(){ Fraction f = null; f = Fraction.getReducedFraction(0, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(1, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(2, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(22, 7); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(-6, 10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(6, -10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(-6, -10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; try { f = Fraction.getReducedFraction(1, 0); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} try { f = Fraction.getReducedFraction(2, 0); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} try { f = Fraction.getReducedFraction(-3, 0); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} f = Fraction.getReducedFraction(0, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(2, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(2, 4); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(15, 10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(121, 22); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; try { f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) {} f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getNumerator(){ return numerator; }
@Test public void testReducedFactory_int_int(){ Fraction f = null; f = Fraction.getReducedFraction(0, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(1, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(2, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(22, 7); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(-6, 10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(6, -10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(-6, -10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; try { f = Fraction.getReducedFraction(1, 0); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} try { f = Fraction.getReducedFraction(2, 0); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} try { f = Fraction.getReducedFraction(-3, 0); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} f = Fraction.getReducedFraction(0, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(2, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(2, 4); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(15, 10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(121, 22); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; try { f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) {} f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getDenominator(){ return denominator; }
@Test public void testReducedFactory_int_int(){ Fraction f = null; f = Fraction.getReducedFraction(0, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(1, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(2, 1); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(22, 7); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(-6, 10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(6, -10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(-6, -10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; try { f = Fraction.getReducedFraction(1, 0); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} try { f = Fraction.getReducedFraction(2, 0); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} try { f = Fraction.getReducedFraction(-3, 0); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} f = Fraction.getReducedFraction(0, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(2, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(2, 4); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(15, 10); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(121, 22); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; try { f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) {} f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static Fraction getReducedFraction(int numerator, int denominator){ if (denominator == 0) { throw new ArithmeticException("The denominator must not be zero"); } if (numerator==0) { return ZERO; } if (denominator==Integer.MIN_VALUE && (numerator&1)==0) { numerator/=2; denominator/=2; } if (denominator < 0) { if (numerator==Integer.MIN_VALUE || denominator==Integer.MIN_VALUE) { throw new ArithmeticException("overflow: can't negate"); } numerator = -numerator; denominator = -denominator; } int gcd = greatestCommonDivisor(numerator, denominator); numerator /= gcd; denominator /= gcd; return new Fraction(numerator, denominator); }
@Test public void testReduce(){ Fraction f = null; f = Fraction.getFraction(50, 75); Fraction result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 1); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 100); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(Integer.MIN_VALUE, 2); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getNumerator(){ return numerator; }
@Test public void testReduce(){ Fraction f = null; f = Fraction.getFraction(50, 75); Fraction result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 1); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 100); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(Integer.MIN_VALUE, 2); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getDenominator(){ return denominator; }
@Test public void testReduce(){ Fraction f = null; f = Fraction.getFraction(50, 75); Fraction result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 1); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 100); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(Integer.MIN_VALUE, 2); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Fraction reduce(){ if (numerator == 0) { return equals(ZERO) ? this : ZERO; } int gcd = greatestCommonDivisor(Math.abs(numerator), denominator); if (gcd == 1) { return this; } return Fraction.getFraction(numerator / gcd, denominator / gcd); }
@Test public void testISO8859_1_ESCAPE(){ Set<String> col0 = new HashSet<String>(); Set<String> col1 = new HashSet<String>(); String [][] sa = EntityArrays.ISO8859_1_ESCAPE(); boolean success = true; for(int i =0; i <sa.length; i++){ boolean add0 = col0.add(sa[i][0]); boolean add1 = col1.add(sa[i][1]); if (!add0) { success = false; System.out.println("Already added entry 0: "+i+" "+sa[i][0]+" "+sa[i][1]); } if (!add1) { success = false; System.out.println("Already added entry 1: "+i+" "+sa[i][0]+" "+sa[i][1]); } } "<AssertPlaceHolder>"; } private static Object add(Object array, int index, Object element, Class<?> clss){ if (array == null) { if (index != 0) { throw new IndexOutOfBoundsException("Index: " + index + ", Length: 0"); } Object joinedArray = Array.newInstance(clss, 1); Array.set(joinedArray, 0, element); return joinedArray; } int length = Array.getLength(array); if (index > length || index < 0) { throw new IndexOutOfBoundsException("Index: " + index + ", Length: " + length); } Object result = Array.newInstance(clss, length + 1); System.arraycopy(array, 0, result, 0, index); Array.set(result, index, element); if (index < length) { System.arraycopy(array, index, result, index + 1, length - index); } return result; }
@Test public void testSupplementaryUnescaping(){ NumericEntityUnescaper neu = new NumericEntityUnescaper(); String input = "&#68642;"; String expected = "\uD803\uDC22"; String result = neu.translate(input); "<AssertPlaceHolder>"; } public final void translate(CharSequence input, Writer out) throws IOException{ if (out == null) { throw new IllegalArgumentException("The Writer must not be null"); } if (input == null) { return; } int sz = Character.codePointCount(input, 0, input.length()); for (int i = 0; i < sz; i++) { int consumed = translate(input, i, out); if(consumed == 0) { out.write( Character.toChars( Character.codePointAt(input, i) ) ); } else { for(int j=0; j<consumed; j++) { if(i < sz - 2) { i += Character.charCount( Character.codePointAt(input, i) ); } else { i++; } } i--; } } }
@Test public void testJavaVersionAsInt(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } static float toJavaVersionInt(String version){ return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }
@Test public void testContainsNone_CharArrayWithSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static boolean containsNone(CharSequence cs, String invalidChars){ if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); }
@Test public void testContainsNone_StringWithSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static boolean containsNone(CharSequence cs, String invalidChars){ if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); }
@Test public void testContainsAny_StringCharArrayWithBadSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static boolean containsAny(CharSequence cs, String searchChars){ if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); }
@Test public void testIndexOfAnyBut_StringStringWithSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static int indexOfAnyBut(String str, String searchChars){ if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND; }
@Test public void testContainsAny_StringWithBadSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static boolean containsAny(CharSequence cs, String searchChars){ if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); }
@Test public void testIndexOfAny_StringCharArrayWithSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static int indexOfAny(String str, String[] searchStrs){ if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; }
@Test public void testIndexOfAnyBut_StringCharArrayWithSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static int indexOfAnyBut(String str, String searchChars){ if (isEmpty(str) || isEmpty(searchChars)) { return INDEX_NOT_FOUND; } int strLen = str.length(); for (int i = 0; i < strLen; i++) { char ch = str.charAt(i); if (searchChars.indexOf(ch) < 0) { return i; } } return INDEX_NOT_FOUND; }
@Test public void testContainsNone_StringWithBadSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static boolean containsNone(CharSequence cs, String invalidChars){ if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); }
@Test public void testIndexOfAny_StringStringWithSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static int indexOfAny(String str, String[] searchStrs){ if (str == null || searchStrs == null) { return INDEX_NOT_FOUND; } int sz = searchStrs.length; int ret = Integer.MAX_VALUE; int tmp = 0; for (int i = 0; i < sz; i++) { String search = searchStrs[i]; if (search == null) { continue; } tmp = str.indexOf(search); if (tmp == INDEX_NOT_FOUND) { continue; } if (tmp < ret) { ret = tmp; } } return (ret == Integer.MAX_VALUE) ? INDEX_NOT_FOUND : ret; }
@Test public void testContainsNone_CharArrayWithBadSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static boolean containsNone(CharSequence cs, String invalidChars){ if (cs == null || invalidChars == null) { return true; } return containsNone(cs, invalidChars.toCharArray()); }
@Test public void testContainsAnyCharArrayWithSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static boolean containsAny(CharSequence cs, String searchChars){ if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); }
@Test public void testContainsAnyStringWithSupplementaryChars(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static boolean containsAny(CharSequence cs, String searchChars){ if (searchChars == null) { return false; } return containsAny(cs, searchChars.toCharArray()); }
@Test public void testReflectionHierarchy(){ ReflectionTestFixtureA baseA = new ReflectionTestFixtureA(); String baseStr = this.toBaseString(baseA); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; ReflectionTestFixtureB baseB = new ReflectionTestFixtureB(); baseStr = this.toBaseString(baseB); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionArrayCycle() throws Exception{ Object[] objects = new Object[1]; objects[0] = objects; "<AssertPlaceHolder>"; this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionLongArrayArray(){ long[][] array = new long[][] { { 1, 2 }, null, { 5 } }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionArrayArrayCycle() throws Exception{ Object[][] objects = new Object[2][2]; objects[0][0] = objects; objects[0][1] = objects; objects[1][0] = objects; objects[1][1] = objects; String basicToString = this.toBaseString(objects); "<AssertPlaceHolder>"; this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionFloatArray(){ float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionDoubleArrayArray(){ double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionBooleanArray(){ boolean[] array = new boolean[] { true, false, false }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionyteArray(){ byte[] array = new byte[] { 1, 2, -3, 4 }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionDoubleArray(){ double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionIntArrayArray(){ int[][] array = new int[][] { { 1, 2 }, null, { 5 } }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionLongArray(){ long[] array = new long[] { 1, 2, -3, 4 }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionhortArrayArray(){ short[][] array = new short[][] { { 1, 2 }, null, { 5 } }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionObjectArray(){ Object[] array = new Object[] { null, base, new int[] { 3, 6 } }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionBooleanArrayArray(){ boolean[][] array = new boolean[][] { { true, false }, null, { false } }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionByteArrayArray(){ byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionArrayCycleLevel2() throws Exception{ Object[] objects = new Object[1]; Object[] objectsLevel2 = new Object[1]; objects[0] = objectsLevel2; objectsLevel2[0] = objects; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionArrayAndObjectCycle() throws Exception{ Object[] objects = new Object[1]; SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects); objects[0] = simple; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionCharArrayArray(){ char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionShortArray(){ short[] array = new short[] { 1, 2, -3, 4 }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionIntArray(){ int[] array = new int[] { 1, 2, -3, 4 }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionCharArray(){ char[] array = new char[] { 'A', '2', '_', 'D' }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testReflectionFloatArrayArray(){ float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } }; String baseStr = this.toBaseString(array); "<AssertPlaceHolder>"; array = null; assertReflectionArray("<null>", array); this.validateNullToStringStyleRegistry(); } public static <T> String reflectionToString( T object, ToStringStyle style, boolean outputTransients, Class<? super T> reflectUpToClass){ return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass); }
@Test public void testLang538(){ final String dateTime = "2009-10-16T16:42:16.000Z"; GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8")); cal.clear(); cal.set(2009, 9, 16, 8, 42, 16); FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", TimeZone.getTimeZone("GMT")); "<AssertPlaceHolder>"; } public StringBuffer format(Calendar calendar, StringBuffer buf){ if (mTimeZoneForced) { calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }
@Test public void testContainsIgnoreCase_LocaleIndependence(){ Locale orig = Locale.getDefault(); Locale[] locales = { Locale.ENGLISH, new Locale("tr"), Locale.getDefault() }; String[][] tdata = { { "i", "I" }, { "I", "i" }, { "\u03C2", "\u03C3" }, { "\u03A3", "\u03C2" }, { "\u03A3", "\u03C3" }, }; String[][] fdata = { { "\u00DF", "SS" }, }; try { for (int i = 0; i < locales.length; i++) { Locale.setDefault(locales[i]); for (int j = 0; j < tdata.length; j++) { "<AssertPlaceHolder>"; } for (int j = 0; j < fdata.length; j++) { "<AssertPlaceHolder>"; } } } finally { Locale.setDefault(orig); } } public static boolean containsIgnoreCase(String str, String searchStr){ if (str == null || searchStr == null) { return false; } return contains(str.toUpperCase(), searchStr.toUpperCase()); }
@Test public void test_getShortClassName_Class(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static String getShortClassName(String className){ if (className == null) { return StringUtils.EMPTY; } if (className.length() == 0) { return StringUtils.EMPTY; } int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); int innerIdx = className.indexOf( INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1); String out = className.substring(lastDotIdx + 1); if (innerIdx != -1) { out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR); } return out; }
@Test public void test_getPackageName_Class(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static String getPackageName(String className){ if (className == null) { return StringUtils.EMPTY; } int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR); if (i == -1) { return StringUtils.EMPTY; } return className.substring(0, i); }
@Test public void testEscapeHtmlHighUnicode() throws java.io.UnsupportedEncodingException{ byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 }; String escaped = StringEscapeUtils.escapeHtml( new String(data, "UTF8") ); String unescaped = StringEscapeUtils.unescapeHtml( escaped ); "<AssertPlaceHolder>"; } public static void escapeHtml(Writer writer, String string) throws IOException{ if (writer == null ) { throw new IllegalArgumentException ("The Writer must not be null."); } if (string == null) { return; } Entities.HTML40.escape(writer, string); }
@Test public void testEscapeHtmlHighUnicode() throws java.io.UnsupportedEncodingException{ byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 }; String escaped = StringEscapeUtils.escapeHtml( new String(data, "UTF8") ); String unescaped = StringEscapeUtils.unescapeHtml( escaped ); "<AssertPlaceHolder>"; } public static void unescapeHtml(Writer writer, String string) throws IOException{ if (writer == null ) { throw new IllegalArgumentException ("The Writer must not be null."); } if (string == null) { return; } Entities.HTML40.unescape(writer, string); }
@Test public void testEscapeJavaWithSlash(){ final String input = "String with a slash (/) in it"; final String expected = input; final String actual = StringEscapeUtils.escapeJava(input); "<AssertPlaceHolder>"; } public static void escapeJava(Writer out, String str) throws IOException{ escapeJavaStyleString(out, str, false); }
@Test public void testReduce(){ Fraction f = null; f = Fraction.getFraction(50, 75); Fraction result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 1); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 100); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Fraction reduce(){ int gcd = greatestCommonDivisor(Math.abs(numerator), denominator); if (gcd == 1) { return this; } return Fraction.getFraction(numerator / gcd, denominator / gcd); }
@Test public void testReduce(){ Fraction f = null; f = Fraction.getFraction(50, 75); Fraction result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 1); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 100); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getNumerator(){ return numerator; }
@Test public void testReduce(){ Fraction f = null; f = Fraction.getFraction(50, 75); Fraction result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, -3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(-2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(2, 3); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 1); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; f = Fraction.getFraction(0, 100); result = f.reduce(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public int getDenominator(){ return denominator; }
@Test public void test_changeDefault_Locale_DateInstance(){ Locale realDefaultLocale = Locale.getDefault(); try { Locale.setDefault(Locale.US); FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY); FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL); Locale.setDefault(Locale.GERMANY); FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } finally { Locale.setDefault(realDefaultLocale); } } public Locale getLocale(){ return mLocale; }
@Test public void test_changeDefault_Locale_DateTimeInstance(){ Locale realDefaultLocale = Locale.getDefault(); try { Locale.setDefault(Locale.US); FastDateFormat format1 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL, Locale.GERMANY); FastDateFormat format2 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL); Locale.setDefault(Locale.GERMANY); FastDateFormat format3 = FastDateFormat.getDateTimeInstance(FastDateFormat.FULL, FastDateFormat.FULL); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } finally { Locale.setDefault(realDefaultLocale); } } public Locale getLocale(){ return mLocale; }
@Test public void testEscapeJavaScript(){ "<AssertPlaceHolder>"; try { StringEscapeUtils.escapeJavaScript(null, null); fail(); } catch (IOException ex) { fail(); } catch (IllegalArgumentException ex) { } try { StringEscapeUtils.escapeJavaScript(null, ""); fail(); } catch (IOException ex) { fail(); } catch (IllegalArgumentException ex) { } "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public static void escapeJavaScript(Writer out, String str) throws IOException{ escapeJavaStyleString(out, str, true); }
@Test public void testLang295(){ StrBuilder sb = new StrBuilder("onetwothree"); sb.deleteFirst("three"); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; sb.deleteFirst("three"); } public StrBuilder deleteFirst(StrMatcher matcher){ return replace(matcher, null, 0, size, 1); }
@Test public void testIndexOfLang294(){ StrBuilder sb = new StrBuilder("onetwothree"); sb.deleteFirst("three"); "<AssertPlaceHolder>"; } public StrBuilder deleteFirst(StrMatcher matcher){ return replace(matcher, null, 0, size, 1); }
@Test public void equals_should_return_true_when_equal() throws Exception{ DelegatingMethod equal = new DelegatingMethod(someMethod); "<AssertPlaceHolder>"; } public boolean equals(Object o){ return method.equals(o); }
@Test public void equals_should_return_true_when_self() throws Exception{ "<AssertPlaceHolder>"; } public boolean equals(Object o){ return method.equals(o); }
@Test public void should_compare_to_be_consistent_with_equals_when_comparing_the_same_reference(){ Date today    = mock(Date.class); Set<Date> set = new TreeSet<Date>(); set.add(today); set.add(today); "<AssertPlaceHolder>"; } public void add(Invocation invocation){ this.invocation = invocation; }
@Test @Test public void should_return_primitive(){ "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } Object returnValueFor(Class<?> clazz){ if (!ClassImposterizer.INSTANCE.canImposterise(clazz)) { return null; } return mockitoCore.mock(clazz, new MockSettingsImpl().defaultAnswer(this)); }
@Test public void should_return_the_usual_default_values_for_primitives() throws Throwable{ ReturnsMocks answer = new ReturnsMocks(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Object answer(InvocationOnMock invocation) throws Throwable{ Object ret = delegate.answer(invocation); if (ret != null) { return ret; } return returnValueFor(invocation.getMethod().getReturnType()); }
@Test public void should_return_the_usual_default_values_for_primitives() throws Throwable{ Answer<Object> answer = new ReturnsSmartNulls(); "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; "<AssertPlaceHolder>"; } public Object answer(InvocationOnMock invocation) throws Throwable{ Object ret = delegate.answer(invocation); if (ret != null) { return ret; } return returnValueFor(invocation.getMethod().getReturnType()); }
@Test public void shouldPrintTheParametersOnSmartNullPointerExceptionMessage() throws Throwable{ Answer<Object> answer = new ReturnsSmartNulls(); Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, "withArgs", "oompa", "lumpa")); try { smartNull.get(); fail(); } catch (SmartNullPointerException ex) { String message = ex.getMessage(); "<AssertPlaceHolder>"; } } public Object answer(InvocationOnMock invocation) throws Throwable{ Object ret = delegate.answer(invocation); if (ret != null) { return ret; } return returnValueFor(invocation.getMethod().getReturnType()); }
@Test public void shouldPrintTheParametersWhenCallingAMethodWithArgs() throws Throwable{ Answer<Object> answer = new ReturnsSmartNulls(); Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, "withArgs", "oompa", "lumpa")); "<AssertPlaceHolder>"; } public Object answer(InvocationOnMock invocation) throws Throwable{ Object ret = delegate.answer(invocation); if (ret != null) { return ret; } return returnValueFor(invocation.getMethod().getReturnType()); }
